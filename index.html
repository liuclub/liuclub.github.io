<!DOCTYPE html><html lang="[&quot;zh-Hans&quot;,&quot;default&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="人最大的问题就是习惯自我辩解，但我们远比自己想象中更许巍、下作和幽暗。"><meta name="keywords" content="Android,Kotlin"><meta name="author" content="liubo"><meta name="copyright" content="liubo"><title>凌晨三点的逗你玩</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s1.ax1x.com/2020/05/29/tmMe1O.jpg"></div><div class="author-info__name text-center">liubo</div><div class="author-info__description text-center">人最大的问题就是习惯自我辩解，但我们远比自己想象中更许巍、下作和幽暗。</div><div class="follow-button"><a href="https://github.com/liuclub">Follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">14</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><nav id="nav" style="background-image: url(https://s1.ax1x.com/2020/05/29/tmKQYV.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">凌晨三点的逗你玩</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">种类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">凌晨三点的逗你玩</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/liuclub" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fa"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Kotlin学习笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kotlin/">Kotlin</a></span><div class="content"><h6 id="为什么选择kotlin"><a class="markdownIt-Anchor" href="#为什么选择kotlin"></a> 为什么选择Kotlin？</h6>
<ul>
<li>
<p>简洁：大大减少样板代码的数量；</p>
</li>
<li>
<p>安全：避免空指针异常等整个类的错误；</p>
</li>
<li>
<p>互操作性：充分利用JVM、Android和浏览器的现有库；</p>
</li>
<li>
<p>工具友好：可用任何Java IDE或者命令行构建；</p>
</li>
</ul>
<h6 id="可变长参数函数"><a class="markdownIt-Anchor" href="#可变长参数函数"></a> 可变长参数函数</h6>
<blockquote>
<p>函数的可变长参数可以用 <strong>vararg</strong> 关键字进行标识</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">vars</span><span class="params">(<span class="keyword">vararg</span> params : <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(element int params)&#123;</span><br><span class="line">        println(<span class="string">"element = "</span>+element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    vars(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="定义常量与变量"><a class="markdownIt-Anchor" href="#定义常量与变量"></a> 定义常量与变量</h6>
<ol>
<li>变量定义</li>
</ol>
<blockquote>
<p>​		<strong>var</strong> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</p>
</blockquote>
<ol start="2">
<li>常量定义</li>
</ol>
<blockquote>
<p>​		<strong>val</strong> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">1</span>       <span class="comment">// 系统自动推断变量类型为Int</span></span><br><span class="line"><span class="keyword">val</span> c: <span class="built_in">Int</span>      <span class="comment">// 如果不在声明时初始化则必须提供变量类型</span></span><br><span class="line">c = <span class="number">1</span>           <span class="comment">// 明确赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>        <span class="comment">// 系统自动推断变量类型为Int</span></span><br><span class="line">x += <span class="number">1</span>           <span class="comment">// 变量可修改</span></span><br></pre></td></tr></table></figure>
<h6 id="字符串模板"><a class="markdownIt-Anchor" href="#字符串模板"></a> 字符串模板</h6>
<blockquote>
<p>$ 表示一个变量名或者变量值</p>
<p>$varName 表示变量值</p>
<p>${varName.fun()} 表示变量的方法返回值:</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// 模板中的简单名称：</span></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="string">"a is <span class="variable">$a</span>"</span> </span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="comment">// 模板中的任意表达式：</span></span><br><span class="line"><span class="keyword">val</span> s2 = <span class="string">"<span class="subst">$&#123;s1.replace(<span class="string">"is"</span>, <span class="string">"was"</span>)&#125;</span>, but now is <span class="variable">$a</span>"</span></span><br></pre></td></tr></table></figure>
<h6 id="null检查机制"><a class="markdownIt-Anchor" href="#null检查机制"></a> NULL检查机制</h6>
<blockquote>
<p>Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式</p>
<ol>
<li>字段后加!!像Java一样抛出空异常;</li>
<li>字段后加?可不做处理返回值为 null或配合?:做空判断处理</li>
</ol>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型后面加?表示可为空</span></span><br><span class="line"><span class="keyword">var</span> age: String? = <span class="string">"23"</span> </span><br><span class="line"><span class="comment">//抛出空指针异常</span></span><br><span class="line"><span class="keyword">val</span> ages = age!!.toInt()</span><br><span class="line"><span class="comment">//不做处理返回 null</span></span><br><span class="line"><span class="keyword">val</span> ages1 = age?.toInt()</span><br><span class="line"><span class="comment">//age为空返回-1</span></span><br><span class="line"><span class="keyword">val</span> ages2 = age?.toInt() ?: -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。</p>
</blockquote>
<blockquote>
<p>当 str 中的字符串内容不是一个整数时, 返回 null:</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str : <span class="type">String</span>)</span></span> : <span class="built_in">Int</span>?&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在使用返回值可为null的函数的时候，必须先对返回值做判空操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> x = parseInt(args[<span class="number">0</span>])</span><br><span class="line">   <span class="keyword">val</span> y = parseInt(args[<span class="number">1</span>])</span><br><span class="line">   <span class="keyword">if</span>(x != <span class="literal">null</span> &amp;&amp; y != <span class="literal">null</span>)&#123;</span><br><span class="line">       println(<span class="string">"x * y = <span class="subst">$&#123;x * y&#125;</span>"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="类型检测以及自动类型转换"><a class="markdownIt-Anchor" href="#类型检测以及自动类型转换"></a> 类型检测以及自动类型转换</h6>
<blockquote>
<p>使用__is__ 或者__!is__ 来检测一个表达式是或不是某类型的一个实例</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj : <span class="type">Any</span>)</span></span> : <span class="built_in">Int</span>?&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">is</span> String)&#123;</span><br><span class="line">        <span class="comment">//做过类型判断以后，obj会被系统自动转换成String类型</span></span><br><span class="line">        <span class="keyword">return</span> obj.length</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//在这里还有一种方法，与Java中instanceof不同，使用!is</span></span><br><span class="line">      <span class="comment">// if (obj !is String)&#123;</span></span><br><span class="line">      <span class="comment">//   // XXX</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里的obj仍然是Any类型的引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringlength</span><span class="params">(obj : <span class="type">Any</span>)</span></span> : <span class="built_in">Int</span>?&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj !<span class="keyword">is</span> String)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在这个分支中，'obj'的类型会被自动转换成'String'</span></span><br><span class="line">    <span class="keyword">return</span> obj.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="kotlin基本数据类型"><a class="markdownIt-Anchor" href="#kotlin基本数据类型"></a> Kotlin基本数据类型</h5>
<table>
<thead>
<tr>
<th>类型</th>
<th>位宽度</th>
</tr>
</thead>
<tbody>
<tr>
<td>Double</td>
<td>64</td>
</tr>
<tr>
<td>Float</td>
<td>32</td>
</tr>
<tr>
<td>Long</td>
<td>64</td>
</tr>
<tr>
<td>Int</td>
<td>32</td>
</tr>
<tr>
<td>Short</td>
<td>16</td>
</tr>
<tr>
<td>Byte</td>
<td>8</td>
</tr>
</tbody>
</table>
<h6 id="字面常量"><a class="markdownIt-Anchor" href="#字面常量"></a> 字面常量</h6>
<blockquote>
<p>十进制：123</p>
<p>长整型以大写的L结尾：123L</p>
<p>16进制以__0x__ 开头：0x0F</p>
<p>2进制以__0b__ 开头： 0b000101</p>
<p><strong>不支持8进制</strong></p>
</blockquote>
<p>Kotlin支持传统符号表示的浮点数值</p>
<blockquote>
<ul>
<li>Double默认写法：123.5，,13.5e10</li>
<li>Float 使用f或者F后缀：123.5f</li>
</ul>
</blockquote>
<p>可以使用__下划线__ ，使得数字常量更加易读</p>
<blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> creditCardNumber = <span class="number">1234_5678_9012_3456L</span></span><br><span class="line"><span class="keyword">val</span> socialSecurityNumber = <span class="number">999_99_9999L</span></span><br><span class="line"><span class="keyword">val</span> hexBytes = <span class="number">0xFF_EC_DE_5E</span></span><br><span class="line"><span class="keyword">val</span> bytes = <span class="number">0b11010010_01101001_10010100_10010010</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="比较两个数字"><a class="markdownIt-Anchor" href="#比较两个数字"></a> 比较两个数字</h6>
<blockquote>
<ul>
<li>
<p>Kotlin 中没有基础数据类型，只有封装的数字类型，<strong>每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针</strong>。</p>
</li>
<li>
<p>数字类型也一样，所有在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。</p>
</li>
</ul>
</blockquote>
<p>在Kotlin中</p>
<blockquote>
<p>===表示比较对象地址</p>
<p>==表示比较两个值的大小</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/13-%E5%B0%86Kotlin%E5%8D%8F%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/">13-将Kotlin协程与架构组件一起使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JetPack/">JetPack</a></span><div class="content"><blockquote>
<p><a href="https://developer.android.com/kotlin/coroutines" target="_blank" rel="noopener">Kotlin 协程</a>提供了一个可供您编写异步代码的 API。通过 Kotlin 协程，您可以定义 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/" target="_blank" rel="noopener"><code>CoroutineScope</code></a>，以帮助您管理何时应运行协程。每个异步操作都在特定范围内运行。</p>
</blockquote>
<h3 id="添加ktx依赖项"><a class="markdownIt-Anchor" href="#添加ktx依赖项"></a> 添加KTX依赖项</h3>
<p>本主题中介绍的内置协程范围包含在每个相应架构组件的 <a href="https://developer.android.com/kotlin/ktx" target="_blank" rel="noopener">KTX 扩展程序</a>中。请务必在使用这些范围时添加相应的依赖项。</p>
<ul>
<li>对于 <a href="https://developer.android.com/topic/libraries/architecture/coroutines#viewmodelscope" target="_blank" rel="noopener"><code>ViewModelScope</code></a>，请使用 <code>androidx.lifecycle:lifecycle-viewmodel-ktx:2.1.0-beta01</code> 或更高版本。</li>
<li>对于 <a href="https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope" target="_blank" rel="noopener"><code>LifecycleScope</code></a>，请使用 <code>androidx.lifecycle:lifecycle-runtime-ktx:2.2.0-alpha01</code> 或更高版本。</li>
<li>对于 <a href="https://developer.android.com/topic/libraries/architecture/coroutines#livedata" target="_blank" rel="noopener"><code>liveData</code></a>，请使用 <code>androidx.lifecycle:lifecycle-livedata-ktx:2.2.0-alpha01</code> 或更高版本。</li>
</ul>
<h3 id="生命周期感知型协程范围"><a class="markdownIt-Anchor" href="#生命周期感知型协程范围"></a> 生命周期感知型协程范围</h3>
<h4 id="viewmodelscope"><a class="markdownIt-Anchor" href="#viewmodelscope"></a> ViewModelScope</h4>
<p>为应用中的每个 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel" target="_blank" rel="noopener"><code>ViewModel</code></a> 定义了 <code>ViewModelScope</code>。如果 <code>ViewModel</code> 已清除，则在此范围内启动的协程都会自动取消。如果您具有仅在 <code>ViewModel</code> 处于活动状态时才需要完成的工作，此时协程非常有用。</p>
<blockquote>
<p>例如，如果要为布局计算某些数据，则应将工作范围限定至 <code>ViewModel</code>，以便在 <code>ViewModel</code> 清除后，系统会自动取消工作以避免消耗资源。</p>
</blockquote>
<p>您可以通过 ViewModel 的 <code>viewModelScope</code> 属性访问 <code>ViewModel</code> 的 <code>CoroutineScope</code>，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            viewModelScope.launch &#123;</span><br><span class="line">                <span class="comment">// Coroutine that will be canceled when the ViewModel is cleared.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="lifecyclescope"><a class="markdownIt-Anchor" href="#lifecyclescope"></a> LifecycleScope</h4>
<p>为每个 <a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 对象定义了 <code>LifecycleScope</code>。在此范围内启动的协程会在 <code>Lifecycle</code> 被销毁时取消。您可以通过 <code>lifecycle.coroutineScope</code> 或 <code>lifecycleOwner.lifecycleScope</code> 属性访问 <code>Lifecycle</code> 的 <code>CoroutineScope</code>。</p>
<p>以下示例演示了如何使用 <code>lifecycleOwner.lifecycleScope</code> 异步创建预计算文本：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span>: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">            viewLifecycleOwner.lifecycleScope.launch &#123;</span><br><span class="line">                <span class="keyword">val</span> params = TextViewCompat.getTextMetricsParams(textView)</span><br><span class="line">                <span class="keyword">val</span> precomputedText = withContext(Dispatchers.Default) &#123;</span><br><span class="line">                    PrecomputedTextCompat.create(longTextContent, params)</span><br><span class="line">                &#125;</span><br><span class="line">                TextViewCompat.setPrecomputedText(textView, precomputedText)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="暂停生命周期感知型协程"><a class="markdownIt-Anchor" href="#暂停生命周期感知型协程"></a> 暂停生命周期感知型协程</h3>
<p>即使 <code>CoroutineScope</code> 提供了适当的方法来自动取消长时间运行的操作，在某些情况下，您可能需要暂停执行代码块（除非 <code>Lifecycle</code> 处于特定状态）。例如，要运行 <code>FragmentTransaction</code>，您必须等到 <code>Lifecycle</code> 至少为 <code>STARTED</code>。对于这些情况，<code>Lifecycle</code> 提供了其他方法：<code>lifecycle.whenCreated</code>、<code>lifecycle.whenStarted</code> 和 <code>lifecycle.whenResumed</code>。如果 <code>Lifecycle</code> 未至少处于所需的最低状态，则会暂停在这些块内运行的任何协程。</p>
<p>以下示例包含仅当关联的 <code>Lifecycle</code> 至少处于 <code>STARTED</code> 状态时才会运行的代码块：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span>: <span class="type">Fragment &#123;</span></span></span><br><span class="line">        <span class="keyword">init</span> &#123; <span class="comment">// Notice that we can safely launch in the constructor of the Fragment.</span></span><br><span class="line">            lifecycleScope.launch &#123;</span><br><span class="line">                whenStarted &#123;</span><br><span class="line">                    <span class="comment">// The block inside will run only when Lifecycle is at least STARTED.</span></span><br><span class="line">                    <span class="comment">// It will start executing when fragment is started and</span></span><br><span class="line">                    <span class="comment">// can call other suspend methods.</span></span><br><span class="line">                    loadingView.visibility = View.VISIBLE</span><br><span class="line">                    <span class="keyword">val</span> canAccess = withContext(Dispatchers.IO) &#123;</span><br><span class="line">                        checkUserAccess()</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// When checkUserAccess returns, the next line is automatically</span></span><br><span class="line">                    <span class="comment">// suspended if the Lifecycle is not *at least* STARTED.</span></span><br><span class="line">                    <span class="comment">// We could safely run fragment transactions because we know the</span></span><br><span class="line">                    <span class="comment">// code won't run unless the lifecycle is at least STARTED.</span></span><br><span class="line">                    loadingView.visibility = View.GONE</span><br><span class="line">                    <span class="keyword">if</span> (canAccess == <span class="literal">false</span>) &#123;</span><br><span class="line">                        findNavController().popBackStack()</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        showContent()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// This line runs only after the whenStarted block above has completed.</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果在协程处于活动状态时通过某种 <code>when</code> 方法销毁了 <code>Lifecycle</code>，协程会自动取消。在以下示例中，一旦 <code>Lifecycle</code> 状态变为 <code>DESTROYED</code>，<code>finally</code> 块即会运行：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span>: <span class="type">Fragment &#123;</span></span></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            lifecycleScope.launchWhenStarted &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Call some suspend functions.</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// This line might execute after Lifecycle is DESTROYED.</span></span><br><span class="line">                    <span class="keyword">if</span> (lifecycle.state &gt;= STARTED) &#123;</span><br><span class="line">                        <span class="comment">// Here, since we've checked, it is safe to run any</span></span><br><span class="line">                        <span class="comment">// Fragment transactions.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：尽管这些方法为使用 <code>Lifecycle</code> 提供了便利，但只有当信息在 <code>Lifecycle</code> 的范围（例如预计算文本）内有效时才应使用它们。请记住，协程不会随着 Activity 重启而重启。</p>
</blockquote>
<h3 id="将协程与livedata一起使用"><a class="markdownIt-Anchor" href="#将协程与livedata一起使用"></a> 将协程与LiveData一起使用</h3>
<p>使用 <a href="https://developer.android.com/topic/libraries/architecture/livedata" target="_blank" rel="noopener"><code>LiveData</code></a> 时，您可能需要异步计算值。例如，您可能需要检索用户的偏好设置并将其传送给界面。在这些情况下，您可以使用 <code>liveData</code> 构建器函数调用 <code>suspend</code> 函数，并将结果作为 <code>LiveData</code> 对象传送。</p>
<p>在以下示例中，<code>loadUser()</code> 是在其他位置声明的暂停函数。使用 <code>liveData</code> 构建器函数异步调用 <code>loadUser()</code>，然后使用 <code>emit()</code> 发出结果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> user: LiveData&lt;User&gt; = liveData &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = database.loadUser() <span class="comment">// loadUser is a suspend function.</span></span><br><span class="line">        emit(<span class="keyword">data</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>liveData</code> 构建块用作协程和 <code>LiveData</code> 之间的<a href="https://medium.com/@elizarov/structured-concurrency-722d765aa952" target="_blank" rel="noopener">结构化并发基元</a>。</p>
<ul>
<li>
<p>当 <code>LiveData</code> 变为活动状态时，代码块开始执行；</p>
</li>
<li>
<p>当 <code>LiveData</code> 变为非活动状态时，代码块会在可配置的超时过后自动取消。</p>
</li>
<li>
<p>如果代码块在完成前取消，则会在 <code>LiveData</code> 再次变为活动状态后重启；</p>
</li>
<li>
<p>如果在上次运行中成功完成，则不会重启。</p>
<p>请注意，代码块只有在自动取消的情况下才会重启。如果代码块由于任何其他原因（例如，抛出 <code>CancelationException</code>）而取消，则<strong>不会</strong>重启。</p>
<p>还可以从代码块中发出多个值。每次 <code>emit()</code> 调用都会暂停执行代码块，直到在主线程上设置 <code>LiveData</code> 值。</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> user: LiveData&lt;Result&gt; = liveData &#123;</span><br><span class="line">        emit(Result.loading())</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            emit(Result.success(fetchUser()))</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ioException: Exception) &#123;</span><br><span class="line">            emit(Result.error(ioException))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>也可以将 <code>liveData</code> 与 <a href="https://developer.android.com/reference/androidx/lifecycle/Transformations" target="_blank" rel="noopener"><code>Transformations</code></a> 结合使用，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> userId: LiveData&lt;String&gt; = MutableLiveData()</span><br><span class="line">        <span class="keyword">val</span> user = userId.switchMap &#123; id -&gt;</span><br><span class="line">            liveData(context = viewModelScope.coroutineContext + Dispatchers.IO) &#123;</span><br><span class="line">                emit(database.loadUserById(id))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以从 <code>LiveData</code> 中发出多个值，方法是在每次想要发出新值时调用 <code>emitSource()</code> 函数。请注意，每次调用 <code>emit()</code> 或 <code>emitSource()</code> 都会移除之前添加的来源。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDao</span>: <span class="type">Dao &#123;</span></span></span><br><span class="line">        <span class="meta">@Query(<span class="meta-string">"SELECT * FROM User WHERE id = :id"</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(id: <span class="type">String</span>)</span></span>: LiveData&lt;User&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyRepository</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(id: <span class="type">String</span>)</span></span> = liveData&lt;User&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> disposable = emitSource(</span><br><span class="line">                userDao.getUser(id).map &#123;</span><br><span class="line">                    Result.loading(it)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> user = webservice.fetchUser(id)</span><br><span class="line">                <span class="comment">// Stop the previous emission to avoid dispatching the updated user</span></span><br><span class="line">                <span class="comment">// as `loading`.</span></span><br><span class="line">                disposable.dispose()</span><br><span class="line">                <span class="comment">// Update the database.</span></span><br><span class="line">                userDao.insert(user)</span><br><span class="line">                <span class="comment">// Re-establish the emission with success type.</span></span><br><span class="line">                emitSource(</span><br><span class="line">                    userDao.getUser(id).map &#123;</span><br><span class="line">                        Result.success(it)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125; <span class="keyword">catch</span>(exception: IOException) &#123;</span><br><span class="line">                <span class="comment">// Any call to `emit` disposes the previous one automatically so we don't</span></span><br><span class="line">                <span class="comment">// need to dispose it here as we didn't get an updated value.</span></span><br><span class="line">                emitSource(</span><br><span class="line">                    userDao.getUser(id).map &#123;</span><br><span class="line">                        Result.error(exception, it)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如需更多与协程相关的信息，请参阅以下链接：</p>
</blockquote>
<ul>
<li><a href="https://developer.android.com/kotlin/coroutines" target="_blank" rel="noopener">利用 Kotlin 协程提升应用性能</a></li>
<li><a href="https://kotlinlang.org/docs/reference/coroutines-overview.html" target="_blank" rel="noopener">协程概览</a></li>
<li><a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/coroutineworker" target="_blank" rel="noopener">在 CoroutineWorker 中进行线程处理</a></li>
</ul>
<h3 id="其他资源"><a class="markdownIt-Anchor" href="#其他资源"></a> 其他资源</h3>
<h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4>
<p><a href="https://github.com/googlesamples/android-architecture-components/tree/master/LiveDataSample">Kotlin 协程与架构组件</a></p>
<h4 id="博客"><a class="markdownIt-Anchor" href="#博客"></a> 博客</h4>
<ul>
<li><a href="https://medium.com/androiddevelopers/coroutines-on-android-part-iii-real-work-2ba8a2ec2f45" target="_blank" rel="noopener">Android 上的协程：应用模式</a></li>
<li><a href="https://medium.com/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471" target="_blank" rel="noopener">Android 中的简易协程：viewModelScope</a></li>
<li><a href="https://medium.com/androiddevelopers/testing-two-consecutive-livedata-emissions-in-coroutines-5680b693cbf8" target="_blank" rel="noopener">在协程中测试两个连续的 LiveData 发出对象</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/12-ViewModel%E7%9A%84%E5%B7%B2%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9D%97/">12-ViewModel的已保存状态模块</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JetPack/">JetPack</a></span><div class="content"><blockquote>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象可以处理配置更改，因此您无需担心旋转时或其他情况下的状态。但是，如果您需要处理系统发起的进程终止，则可以使用 <a href="https://developer.android.com/reference/android/app/Activity#onSaveInstanceState(android.os.Bundle)" target="_blank" rel="noopener"><code>onSaveInstanceState()</code></a> 作为备用方式。</p>
<p>界面状态通常在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象中（而不是 Activity 中）存储或引用；因此，使用 <a href="https://developer.android.com/reference/android/app/Activity#onSaveInstanceState(android.os.Bundle)" target="_blank" rel="noopener"><code>onSaveInstanceState()</code></a> 时需要该模块可以为您处理的某个样板。</p>
<p>模块设置好以后，<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象会通过其构造函数接收 <a href="https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle" target="_blank" rel="noopener"><code>SavedStateHandle</code></a> 对象。这是一个键值对映射，用于向已保存状态写入对象以及从其中检索对象。这些值会在进程被系统终止后继续保留，并通过同一对象保持可用状态。</p>
<p><strong>注意</strong>：状态必须是简单的轻量级状态。对于复杂或大型数据，您应该使用<a href="https://developer.android.com/topic/libraries/architecture/saving-states#use_local_persistence_to_handle_process_death_for_complex_or_large_data" target="_blank" rel="noopener">本地持久性存储</a>。</p>
</blockquote>
<h3 id="设置和使用"><a class="markdownIt-Anchor" href="#设置和使用"></a> 设置和使用</h3>
<p>声明</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Saved state module for ViewModel</span></span><br><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version"</span></span><br></pre></td></tr></table></figure>
<p>设置 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 来接收 SavedStateHandle，您需要使用可扩展 <a href="https://developer.android.com/reference/androidx/lifecycle/AbstractSavedStateVMFactory" target="_blank" rel="noopener"><code>AbstractSavedStateVMFactory</code></a> 的 Factory 来创建它们。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> vm = ViewModelProvider(<span class="keyword">this</span>, SavedStateVMFactory(<span class="keyword">this</span>))</span><br><span class="line">        .<span class="keyword">get</span>(SavedStateViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure>
<p>之后，ViewModel 便可以有一个接收 SavedStateHandle 的构造函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavedStateViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> state: SavedStateHandle) : ViewModel() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="存储和检索值"><a class="markdownIt-Anchor" href="#存储和检索值"></a> 存储和检索值</h3>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle" target="_blank" rel="noopener"><code>SavedStateHandle</code></a> 类包含键值对映射应有的方法：</p>
<ul>
<li><code>get(String key)</code></li>
<li><code>contains(String key)</code></li>
<li><code>remove(String key)</code></li>
<li><code>set(String key, T value)</code></li>
<li><code>keys()</code></li>
</ul>
<p>此外，还有一种特殊的方法：<a href="https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle#getLiveData(java.lang.String)" target="_blank" rel="noopener"><code>getLiveData(String key)</code></a>，用于返回封装在 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 可观察对象中的值。</p>
<h3 id="可接受的类"><a class="markdownIt-Anchor" href="#可接受的类"></a> 可接受的类</h3>
<table>
<thead>
<tr>
<th style="text-align:left">类型/类</th>
<th style="text-align:left">数组支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">double[]</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">int []</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">long []</td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">String[]</td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">byte[]</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">char[]</td>
</tr>
<tr>
<td style="text-align:left">CharSequence</td>
<td style="text-align:left">CharSequence[]</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">float[]</td>
</tr>
<tr>
<td style="text-align:left">Parcelable</td>
<td style="text-align:left">Parcelable[]</td>
</tr>
<tr>
<td style="text-align:left">Serializable</td>
<td style="text-align:left">Serializable[]</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">short[]</td>
</tr>
<tr>
<td style="text-align:left">SparseArray</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Binder</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Bundle</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">ArrayList</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Size (only in API 21+)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">SizeF (only in API 21+)</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h3 id="其他资源"><a class="markdownIt-Anchor" href="#其他资源"></a> 其他资源</h3>
<h4 id="codelab"><a class="markdownIt-Anchor" href="#codelab"></a> Codelab</h4>
<p><a href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#6" target="_blank" rel="noopener">Android 生命周期感知型组件 Codelab</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/11-%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81/">11-保存状态</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JetPack/">JetPack</a></span><div class="content"><blockquote>
<p>未编辑</p>
</blockquote>
<p>在发生系统发起的 Activity 或应用销毁后，需要及时保存和恢复 Activity 的界面状态，这是用户体验的一个至关重要的部分。在这些情况下，用户希望界面状态保持不变，但是系统会销毁 Activity 及其中存储的任何状态。</p>
<p>要使系统行为符合用户预期，可以把 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a> 对象、<a href="https://developer.android.com/reference/android/app/Activity#onSaveInstanceState(android.os.Bundle)" target="_blank" rel="noopener"><code>onSaveInstanceState()</code></a> 方法和/或本地存储空间结合起来使用，从而在发生此类应用和 Activity 实例转换后保持界面状态。在决定如何组合这些选项时，需要考虑界面数据的复杂程度、应用的用例以及检索速度与内存用量的权衡。</p>
<p>无论采用哪种方法，都应确保应用满足用户对其界面状态的预期，并提供流畅、简洁的界面（消除将数据载入界面过程中的延迟时间，尤其是在发生像旋转这样频繁的配置更改之后）。在大多数情况下，您应同时使用 ViewModel 和 onSaveInstanceState()。</p>
<p>本页讨论了用户对界面状态的预期，可用于保留状态的选项，以及每种选项的权衡因素和局限性。</p>
<h2 id="用户预期和系统行为"><a class="markdownIt-Anchor" href="#用户预期和系统行为"></a> 用户预期和系统行为</h2>
<p>根据用户执行的操作，他们会希望系统清除或保留 Activity 状态。在某些情况下，系统会自动执行用户预期的操作。但有时，系统会执行与用户预期相反的操作。</p>
<h3 id="用户发起的界面状态解除"><a class="markdownIt-Anchor" href="#用户发起的界面状态解除"></a> 用户发起的界面状态解除</h3>
<p>用户希望当他们启动 Activity 时，该 Activity 的暂时性界面状态会保持不变，直到用户完全关闭 Activity 为止。用户可以通过以下方式完全关闭 Activity：</p>
<ul>
<li>按返回按钮</li>
<li>从“概览”（“最近使用的应用”）屏幕中滑动关闭 Activity</li>
<li>从 Activity 向上导航</li>
<li>从“设置”屏幕中终止应用</li>
<li>完成某种“完成”Activity（由 Activity.finish() 提供支持）</li>
</ul>
<p>在这些完全关闭的情况下，用户会认为他们已经永久离开 Activity，如果他们重新打开 Activity，会希望 Activity 以干净的状态启动。系统在这些关闭场景中的基础行为符合用户预期，即 Activity 实例将连同其中存储的任何状态以及与该 Activity 关联的任何已保存实例状态记录一起被销毁并从内存中移除。</p>
<p>关于完全关闭的此规则有一些例外情况，例如用户可能希望浏览器为他们打开的是他们在使用返回按钮退出浏览器之前查看的网页。</p>
<h3 id="系统发起的界面状态解除"><a class="markdownIt-Anchor" href="#系统发起的界面状态解除"></a> 系统发起的界面状态解除</h3>
<p>用户希望 Activity 的界面状态在发生配置更改（例如旋转或切换到多窗口模式）后保持不变。但是，默认情况下，系统会在发生此类配置更改时销毁 Activity，从而清除存储在 Activity 实例中的任何界面状态。要详细了解设备配置，请参阅<a href="https://developer.android.com/reference/android/content/res/Configuration.html#lfields" target="_blank" rel="noopener">配置参考页面</a>。请注意，您可以替换针对配置更改的默认行为，但不建议这样做。如需了解详情，请参阅<a href="https://developer.android.com/guide/topics/resources/runtime-changes#HandlingTheChange" target="_blank" rel="noopener">自行处理配置更改</a>。</p>
<p>如果用户暂时切换到其他应用，稍后再返回到您的应用，他们也会希望 Activity 的界面状态保持不变。例如，用户在您的搜索 Activity 中执行搜索，然后按主屏幕按钮或接听电话，当他们返回搜索 Activity 时，希望看到搜索关键字和结果仍在原处，并和之前完全一样。</p>
<p>在这种情况下，您的应用会被置于后台，系统会尽最大努力将您的应用进程留在内存中。但是，当用户转而去与其他应用进行互动时，系统可能会销毁该应用进程。在这种情况下，Activity 实例连同其中存储的任何状态都会一起被销毁。当用户重新启动应用时，Activity 会出乎意料地处于干净状态。要详细了解进程终止行为，请参阅<a href="https://developer.android.com/guide/components/activities/process-lifecycle.html" target="_blank" rel="noopener">进程和应用生命周期</a>。</p>
<h2 id="用于保留界面状态的选项"><a class="markdownIt-Anchor" href="#用于保留界面状态的选项"></a> 用于保留界面状态的选项</h2>
<p>当用户对界面状态的预期与默认系统行为不符时，您必须保存并恢复用户的界面状态，以确保系统发起的销毁对用户完全透明。</p>
<p>按照以下几个会影响用户体验的维度考量，用于保留界面状态的每个选项都有所差异：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">ViewModel</th>
<th style="text-align:left">已保存实例状态</th>
<th style="text-align:left">持久性存储空间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">存储位置</td>
<td style="text-align:left">在内存中</td>
<td style="text-align:left">已序列化到磁盘</td>
<td style="text-align:left">在磁盘或网络上</td>
</tr>
<tr>
<td style="text-align:left">在配置更改后继续存在</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">在系统发起的进程终止后继续存在</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">在用户完成 Activity 关闭/onFinish() 后继续存在</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">数据限制</td>
<td style="text-align:left">支持复杂对象，但是空间受可用内存的限制</td>
<td style="text-align:left">仅适用于基元类型和简单的小对象，例如字符串</td>
<td style="text-align:left">仅受限于磁盘空间或从网络资源检索的成本/时间</td>
</tr>
<tr>
<td style="text-align:left">读取/写入时间</td>
<td style="text-align:left">快（仅限内存访问）</td>
<td style="text-align:left">慢（需要序列化/反序列化和磁盘访问）</td>
<td style="text-align:left">慢（需要磁盘访问或网络事务）</td>
</tr>
</tbody>
</table>
<h2 id="使用-viewmodel-处理配置更改"><a class="markdownIt-Anchor" href="#使用-viewmodel-处理配置更改"></a> 使用 ViewModel 处理配置更改</h2>
<p>ViewModel 非常适合在用户正活跃地使用应用时存储和管理界面相关数据。它支持快速访问界面数据，并且有助于避免在发生旋转、窗口大小调整和其他常见的配置更改后从网络或磁盘中重新获取数据。要了解如何实现 ViewModel，请参阅 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" target="_blank" rel="noopener">ViewModel 指南</a>。</p>
<p>ViewModel 将数据保留在内存中，这意味着成本要低于从磁盘或网络检索数据。ViewModel 与一个 Activity（或其他生命周期所有者）相关联，在配置更改期间保留在内存中，系统会自动将 ViewModel 与发生配置更改后产生的新 Activity 实例相关联。</p>
<p>当用户退出您的 Activity 或 Fragment 时，或者在您调用 finish() 的情况下，系统会自动销毁 ViewModel，这意味着状态会被清除，正如用户在这些场景中所预期的一样。</p>
<p>与已保存实例状态不同，ViewModel 在系统发起的进程终止过程中会被销毁。因此，您应将 ViewModel 对象与 onSaveInstanceState()（或其他一些磁盘持久性功能）结合使用，并将标识符存储在 savedInstanceState 中，以帮助视图模型在系统终止后重新加载数据。</p>
<p>如果您已有用于在发生配置更改后存储界面状态的内存中解决方案，则可能不需要使用 ViewModel。</p>
<h2 id="使用-onsaveinstancestate-作为后备方法来处理系统发起的进程终止"><a class="markdownIt-Anchor" href="#使用-onsaveinstancestate-作为后备方法来处理系统发起的进程终止"></a> 使用 onSaveInstanceState() 作为后备方法来处理系统发起的进程终止</h2>
<p><a href="https://developer.android.com/reference/android/app/Activity#onSaveInstanceState(android.os.Bundle)" target="_blank" rel="noopener"><code>onSaveInstanceState()</code></a> 回调会存储一些数据，如果系统销毁后又重新创建界面控制器（如 Activity 或 Fragment），则需要使用这些数据重新加载该控制器的状态。要了解如何实现已保存实例状态，请参阅 <a href="https://developer.android.com/guide/components/activities/activity-lifecycle.html#asem" target="_blank" rel="noopener">Activity 生命周期指南</a>中的“保存和恢复 Activity 状态”。</p>
<p>已保存实例状态捆绑包在配置更改和进程终止后都会保留，但受限于存储容量和速度，因为 onSavedInstanceState() 会将数据序列化到磁盘。如果序列化的对象很复杂，序列化会占用大量的内存。因为此过程在配置更改期间发生在主线程上，所以如果耗时太长，序列化可能会导致丢帧和视觉卡顿。</p>
<p>请勿将 onSavedInstanceState() 用于存储大量的数据（如位图），也不要用于存储需要冗长的序列化或反序列化操作的复杂数据结构，而是只能用于存储基本类型和简单的小对象，例如字符串。因此，请使用 onSaveInstanceState() 存储最少量的数据（例如 ID），如果其他持久性机制失效，需要使用这些数据来重新创建必要的数据以将界面恢复到之前的状态。大多数应用都应实现 onSaveInstanceState() 来处理系统发起的进程终止。</p>
<p>根据应用的用例，您可能完全不需要使用 <a href="https://developer.android.com/reference/android/app/Activity#onSaveInstanceState(android.os.Bundle)" target="_blank" rel="noopener"><code>onSaveInstanceState()</code></a>。例如，浏览器可能会将用户带回他们在退出浏览器之前正在查看的确切网页。如果 Activity 表现出这种行为，则您可以放弃使用 <a href="https://developer.android.com/reference/android/app/Activity#onSaveInstanceState(android.os.Bundle)" target="_blank" rel="noopener"><code>onSaveInstanceState()</code></a>，改为在本地保留所有内容。</p>
<p>此外，如果您从 intent 打开 Activity，则当配置发生更改以及系统恢复该 Activity 时，会将 extra 捆绑包传送给该 Activity。在 Activity 启动时，如果一段界面状态数据（例如搜索查询）作为 intent extra 传入，则您可以使用 extra 捆绑包而不是 onSaveInstanceState() 捆绑包。要详细了解 intent extra，请参阅 <a href="https://developer.android.com/guide/components/intents-filters" target="_blank" rel="noopener">Intent 过滤器和 Intent 过滤器</a>。</p>
<p>在上述任一情况下，您仍然可以使用 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 来避免因在配置更改期间从数据库重新加载数据而浪费周期时间。</p>
<p>如果要保留的是简单的轻量级界面数据，那么您可以单独使用 <code>onSaveInstanceState()</code> 来保留状态数据。</p>
<p><strong>注意</strong>：您现在可以通过 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate" target="_blank" rel="noopener">ViewModel 的已保存状态模块</a>（目前为 Alpha 版）在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象中提供对已保存状态的访问途径。已保存状态可通过 <a href="https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle" target="_blank" rel="noopener"><code>SavedStateHandle</code></a> 对象来访问。您可以在 <a href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#6/" target="_blank" rel="noopener">Android 生命周期感知型组件 Codelab</a> 中查看其使用方式。</p>
<h2 id="针对复杂或大型数据使用本地持久性存储来处理进程终止"><a class="markdownIt-Anchor" href="#针对复杂或大型数据使用本地持久性存储来处理进程终止"></a> 针对复杂或大型数据使用本地持久性存储来处理进程终止</h2>
<p>只要您的应用安装在用户的设备上，持续性本地存储（例如数据库或共享偏好设置）就会继续存在（除非用户清除应用的数据）。虽然此类本地存储空间会在系统启动的活动和应用进程终止后继续存在，但由于必须从本地存储空间读取到内存，因此检索成本高昂。这种持久性本地存储通常已经属于应用架构的一部分，用于存储您打开和关闭 Activity 时不想丢失的所有数据。</p>
<p>ViewModel 和已保存实例状态均不是长期存储解决方案，因此不能替代本地存储空间，例如数据库。您只应该使用这些机制来暂时存储瞬时界面状态，对于其他应用数据，应使用持久性存储空间。请参阅<a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank" rel="noopener">应用架构指南</a>，详细了解如何充分利用本地存储空间长期保留您的应用模型数据（例如在重启设备后）。</p>
<h2 id="管理界面状态分而治之"><a class="markdownIt-Anchor" href="#管理界面状态分而治之"></a> 管理界面状态：分而治之</h2>
<p>您可以通过在各种类型的持久性机制之间划分工作，高效地保存和恢复界面状态。在大多数情况下，这些机制中的每一种都应存储 Activity 中使用的不同类型的数据，具体取决于数据复杂度、访问速度和生命周期的权衡：</p>
<ul>
<li>
<p>本地持久性存储：存储在您打开和关闭 Activity 时不希望丢失的所有数据。</p>
<ul>
<li>示例：歌曲对象的集合，其中可能包括音频文件和元数据。</li>
</ul>
</li>
<li>
<p><code>ViewModel</code></p>
<p>：在内存中存储显示关联界面控制器所需的所有数据。</p>
<ul>
<li>示例：最近搜索的歌曲对象和最近的搜索查询。</li>
</ul>
</li>
<li>
<pre class="highlight"><code class="">onSaveInstanceState()
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：存储当系统停止后又重新创建界面控制器时轻松重新加载 Activity 状态所需的少量数据。这里指的是将复杂的对象保留在本地存储空间中，并将这些对象的唯一 ID 存储在</span><br></pre></td></tr></table></figure>
onSaveInstanceState()
</code></pre>
<p>中，而不是存储复杂的对象。</p>
<ul>
<li>示例：存储最近的搜索查询。</li>
</ul>
</li>
</ul>
<p>例如，假设有一个用于搜索歌曲库的 Activity。应按如下方式处理不同的事件：</p>
<p>当用户添加歌曲时，<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 会立即委托在本地保留此数据。如果新添加的这首歌曲应显示在界面中，则您还应更新 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象中的数据以表明该歌曲已添加。切记在主线程以外执行所有数据库插入操作。</p>
<p>当用户搜索歌曲时，针对界面控制器从数据库加载的任何复杂歌曲数据都应立即存储在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象中。您还应将搜索查询本身保存在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象中。</p>
<p>当 Activity 进入后台时，系统会调用 <code>onSaveInstanceState()</code>。您应将搜索查询保存在 <code>onSaveInstanceState()</code> 捆绑包中。该少量数据很容易保存。这也是使 Activity 恢复到当前状态所需的所有信息。</p>
<h2 id="恢复复杂的状态重组碎片"><a class="markdownIt-Anchor" href="#恢复复杂的状态重组碎片"></a> 恢复复杂的状态：重组碎片</h2>
<p>当到了用户该返回 Activity 的时候，重新创建 Activity 存在两种可能情况：</p>
<ul>
<li>在系统停止 Activity 后重新创建该 Activity。该 Activity 将查询保存在 <code>onSaveInstanceState()</code> 捆绑包中，并且应将查询传递给 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a>。<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 发现它没有缓存搜索结果，并使用指定的搜索查询委托加载搜索结果。</li>
<li>在配置更改后创建 Activity。该 Activity 将查询保存在 <code>onSaveInstanceState()</code> 捆绑包中，而且 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 已缓存搜索结果。您将查询从 <code>onSaveInstanceState()</code> 捆绑包传递到 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a>，以此确定它已加载必要的数据，且无需要从数据库重新查询数据。</li>
</ul>
<p><strong>注意</strong>：最初创建 Activity 时，<code>onSaveInstanceState()</code> 捆绑包不包含任何数据，且 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象为空。创建 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象时，您将传递空白查询，以此告知 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象尚没有要加载的数据。因此，Activity 以空状态启动。</p>
<h2 id="其他资源"><a class="markdownIt-Anchor" href="#其他资源"></a> 其他资源</h2>
<p>要详细了解如何保存界面状态，请参阅以下资源。</p>
<h3 id="博客"><a class="markdownIt-Anchor" href="#博客"></a> 博客</h3>
<ul>
<li><a href="https://medium.com/androiddevelopers/viewmodels-a-simple-example-ed5ac416317e" target="_blank" rel="noopener">ViewModel：简单示例</a></li>
<li><a href="https://medium.com/androiddevelopers/viewmodels-persistence-onsaveinstancestate-restoring-ui-state-and-loaders-fc7cc4a6c090" target="_blank" rel="noopener">ViewModel：持久性、onSaveInstanceState()、恢复界面状态和加载器</a></li>
<li><a href="https://codelabs.developers.google.com/codelabs/android-lifecycles/" target="_blank" rel="noopener">Android 生命周期感知型组件 Codelab</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/10-WorkManager/">10-WorkManager</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JetPack/">JetPack</a></span><div class="content"><h3 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h3>
<p>使用 WorkManager API 可以轻松地调度即使在应用退出或设备重启时仍应运行的可延迟异步任务。</p>
<p><strong>主要功能</strong>：</p>
<ul>
<li>最高向后兼容到 API 14
<ul>
<li>在运行 API 23 (Android 6.0)及以上级别的设备上使用 JobScheduler</li>
<li>在运行 API 14-22 的设备上结合使用 BroadcastReceiver 和 AlarmManager</li>
</ul>
</li>
<li>添加网络可用性或充电状态等工作约束</li>
<li>调度一次性或周期性异步任务</li>
<li>监控和管理计划任务</li>
<li>将任务链接起来</li>
<li>确保任务执行，即使应用或设备重启也同样执行任务</li>
<li>遵循低电耗模式等省电功能</li>
</ul>
<p>WorkManager 旨在用于<strong>可延迟</strong>运行（即不需要立即运行）并且在应用退出或设备重启时必须能够可靠运行的任务。例如：</p>
<ul>
<li>向后端服务发送日志或分析数据</li>
<li>定期将应用数据与服务器同步</li>
</ul>
<p>WorkManager 不适用于应用进程结束时能够安全终止的运行中后台工作，也不适用于需要立即执行的任务。请查看<a href="https://developer.android.com/guide/background" target="_blank" rel="noopener">后台处理指南</a>，了解哪种解决方案符合您的需求。</p>
<h3 id="使用入门"><a class="markdownIt-Anchor" href="#使用入门"></a> 使用入门</h3>
<h4 id="将workmanager添加到项目中"><a class="markdownIt-Anchor" href="#将workmanager添加到项目中"></a> 将WorkManager添加到项目中</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  def work_version = <span class="string">"2.3.1"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (Java only)</span></span><br><span class="line">    implementation <span class="string">"androidx.work:work-runtime:<span class="variable">$work_version</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin + coroutines</span></span><br><span class="line">    implementation <span class="string">"androidx.work:work-runtime-ktx:<span class="variable">$work_version</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava2 support</span></span><br><span class="line">    implementation <span class="string">"androidx.work:work-rxjava2:<span class="variable">$work_version</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - GCMNetworkManager support</span></span><br><span class="line">    implementation <span class="string">"androidx.work:work-gcm:<span class="variable">$work_version</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers</span></span><br><span class="line">    androidTestImplementation <span class="string">"androidx.work:work-testing:<span class="variable">$work_version</span>"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建后台任务"><a class="markdownIt-Anchor" href="#创建后台任务"></a> 创建后台任务</h4>
<p>任务是使用 <a href="https://developer.android.com/reference/androidx/work/Worker" target="_blank" rel="noopener"><code>Worker</code></a> 类定义的。<code>doWork()</code> 方法在 WorkManager 提供的后台线程上同步运行。</p>
<p>要创建后台任务，请扩展 <code>Worker</code> 类并替换 <code>doWork()</code> 方法。</p>
<p>例如，要创建上传图像的 <code>Worker</code>，您可以执行以下操作：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadWorker</span></span>(appContext: Context, workerParams: WorkerParameters)</span><br><span class="line">    : Worker(appContext, workerParams) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="comment">// Do the work here--in this case, upload the images.</span></span><br><span class="line"></span><br><span class="line">        uploadImages()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Indicate whether the task finished successfully with the Result</span></span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从 <code>doWork()</code> 返回的 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result" target="_blank" rel="noopener"><code>Result</code></a> 会通知 WorkManager 任务是否：</p>
<ul>
<li>
<p>已成功完成：<code>Result.success()</code></p>
</li>
<li>
<p>已失败：<code>Result.failure()</code></p>
</li>
<li>
<p>需要稍后重试：<code>Result.retry()</code></p>
</li>
</ul>
</blockquote>
<h4 id="配置运行任务的方式和时间"><a class="markdownIt-Anchor" href="#配置运行任务的方式和时间"></a> 配置运行任务的方式和时间</h4>
<p><code>Worker</code> 定义工作单元，<a href="https://developer.android.com/reference/androidx/work/WorkRequest" target="_blank" rel="noopener"><code>WorkRequest</code></a> 则定义工作的运行方式和时间。</p>
<blockquote>
<p>任务可以是一次性的，也可以是周期性的。</p>
<ul>
<li>
<p>一次性 <code>WorkRequest</code>，请使用 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" target="_blank" rel="noopener"><code>OneTimeWorkRequest</code></a>;</p>
</li>
<li>
<p>周期性工作，请使用 <a href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest" target="_blank" rel="noopener"><code>PeriodicWorkRequest</code></a></p>
</li>
</ul>
</blockquote>
<p>在本例中，为 UploadWorker 构建 <code>WorkRequest</code> 最简单的示例为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;().build()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>WorkRequest</code> 中还可以包含其他信息，例如任务在运行时应遵循的约束、工作输入、延迟，以及重试工作的退避时间政策。</p>
</blockquote>
<h4 id="将任务提交给系统"><a class="markdownIt-Anchor" href="#将任务提交给系统"></a> 将任务提交给系统</h4>
<p>定义 <code>WorkRequest</code> 之后，您现在可以通过 <a href="https://developer.android.com/reference/androidx/work/WorkManager" target="_blank" rel="noopener"><code>WorkManager</code></a> 使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#enqueue(androidx.work.WorkRequest)" target="_blank" rel="noopener"><code>enqueue()</code></a> 方法来调度它。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(myContext).enqueue(uploadWorkRequest)</span><br></pre></td></tr></table></figure>
<h4 id="后续步骤"><a class="markdownIt-Anchor" href="#后续步骤"></a> 后续步骤</h4>
<blockquote>
<ul>
<li>查看 WorkManager 在<a href="https://github.com/googlesamples/android-architecture-components/tree/master/WorkManagerSample">简单的图像处理应用</a>中的运行情况</li>
<li>使用 <a href="https://codelabs.developers.google.com/codelabs/android-workmanager-kt/" target="_blank" rel="noopener">Kotlin</a>、<a href="https://codelabs.developers.google.com/codelabs/android-workmanager/" target="_blank" rel="noopener">Java</a> 在 codelab 中进行实操练习</li>
<li>了解<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work" target="_blank" rel="noopener">如何添加工作约束</a>。</li>
</ul>
</blockquote>
<h3 id="方法指南"><a class="markdownIt-Anchor" href="#方法指南"></a> 方法指南</h3>
<h4 id="定义workrequest"><a class="markdownIt-Anchor" href="#定义workrequest"></a> 定义WorkRequest</h4>
<h5 id="工作约束"><a class="markdownIt-Anchor" href="#工作约束"></a> 工作约束</h5>
<p>您可以向工作添加 <code>Constraints</code>，以指明工作何时可以运行。</p>
<p>例如，您可以指定工作应仅在设备空闲且接通电源时运行。</p>
<p>下面的代码展示了如何将这些约束添加到 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" target="_blank" rel="noopener"><code>OneTimeWorkRequest</code></a>。有关所支持约束的完整列表，请参阅 <a href="https://developer.android.com/reference/androidx/work/Constraints.Builder" target="_blank" rel="noopener"><code>Constraints.Builder</code> 参考文档</a>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a Constraints object that defines when the task should run</span></span><br><span class="line"><span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">        .setRequiresDeviceIdle(<span class="literal">true</span>)</span><br><span class="line">        .setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...then create a OneTimeWorkRequest that uses those constraints</span></span><br><span class="line"><span class="keyword">val</span> compressionWork = OneTimeWorkRequestBuilder&lt;CompressWorker&gt;().setConstraints(constraints).build()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果指定了多个约束，您的任务将仅在满足所有约束时才会运行。</p>
<p>如果在任务运行期间某个约束不再得到满足，则 WorkManager 将停止工作器。当约束继续得到满足时，系统将重新尝试执行该任务。</p>
</blockquote>
<h5 id="初始延迟"><a class="markdownIt-Anchor" href="#初始延迟"></a> 初始延迟</h5>
<p>如果您的工作没有约束，或者工作加入队列时所有约束均已得到满足，则系统可能会选择立即运行任务。如果您不希望任务立即运行，则可以将工作指定为在经过最短的初始延迟后启动。</p>
<p>下面的示例展示了如何将任务设置为在加入队列后至少经过 10 分钟再运行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;()</span><br><span class="line">        .setInitialDelay(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：执行工作器的确切时间还取决于 WorkRequest 中使用的约束和系统优化。WorkManager 经过设计，能够在满足这些约束的情况下提供可能的最佳行为。</p>
<h5 id="重试和退避政策"><a class="markdownIt-Anchor" href="#重试和退避政策"></a> 重试和退避政策</h5>
<p>如果您需要让 WorkManager 重新尝试执行您的任务，可以从工作器返回 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result#retry()" target="_blank" rel="noopener"><code>Result.retry()</code></a>。</p>
<p>然后，系统会根据默认的退避延迟时间和政策重新调度您的工作。退避延迟时间指定重试工作前的最短等待时间。<a href="https://developer.android.com/reference/androidx/work/BackoffPolicy" target="_blank" rel="noopener">退避政策</a>定义了在后续重试的尝试过程中，退避延迟时间随时间以怎样的方式增长；默认情况下按 <a href="https://developer.android.com/reference/androidx/work/BackoffPolicy" target="_blank" rel="noopener"><code>EXPONENTIAL</code></a> 延长。</p>
<p>以下是自定义退避延迟时间和政策的示例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;()</span><br><span class="line">          .setBackoffCriteria(</span><br><span class="line">                  BackoffPolicy.LINEAR,</span><br><span class="line">                  OneTimeWorkRequest.MIN_BACKOFF_MILLIS,</span><br><span class="line">                  TimeUnit.MILLISECONDS)</span><br><span class="line">          .build()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Criteria 	 标准, 准则, 规范</p>
</blockquote>
<h5 id="定义任务的输入输出"><a class="markdownIt-Anchor" href="#定义任务的输入输出"></a> 定义任务的输入/输出</h5>
<p>任务可能需要数据以输入参数的形式传入，或者将数据返回为结果。例如，某个任务负责处理图像上传，它要求以要上传的图像的 URI 为输入，并且可能要求用已上传图像的网址作为输出。</p>
<p>输入和输出值以键值对的形式存储在 <a href="https://developer.android.com/reference/androidx/work/Data" target="_blank" rel="noopener"><code>Data</code></a> 对象中。下面的代码展示了如何在 <code>WorkRequest</code> 中设置输入数据。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// workDataOf (part of KTX) converts a list of pairs to a [Data] object.</span></span><br><span class="line"><span class="keyword">val</span> imageData = workDataOf(Constants.KEY_IMAGE_URI to imageUriString)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;()</span><br><span class="line">        .setInputData(imageData)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>
<p><code>Worker</code> 类可通过调用 Worker.getInputData() 访问输入参数。</p>
<p>类似地，<code>Data</code> 类可用于输出返回值。要返回 <code>Data</code> 对象，请将它包含到 <code>Result</code> 的 <code>Result.success()</code> 或 <code>Result.failure()</code> 中，如下所示。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadWorker</span></span>(appContext: Context, workerParams: WorkerParameters)</span><br><span class="line">    : Worker(appContext, workerParams) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the input</span></span><br><span class="line">            <span class="keyword">val</span> imageUriInput = getInputData().getString(Constants.KEY_IMAGE_URI)</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> validate inputs.</span></span><br><span class="line">            <span class="comment">// Do the work</span></span><br><span class="line">            <span class="keyword">val</span> response = uploadFile(imageUriInput)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the output of the work</span></span><br><span class="line">            <span class="keyword">val</span> outputData = workDataOf(Constants.KEY_IMAGE_URL to response.imageUrl)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Return the output</span></span><br><span class="line">            <span class="keyword">return</span> Result.success(outputData)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：按照设计，<code>Data</code> 对象应该很小，值可以是字符串、基元类型或数组变体。如果需要将更多数据传入和传出工作器，应该将数据放在其他位置，例如 Room 数据库。Data 对象的大小上限为 10KB。</p>
<h5 id="标记工作"><a class="markdownIt-Anchor" href="#标记工作"></a> 标记工作</h5>
<p>可以通过为任意 <a href="https://developer.android.com/reference/androidx/work/WorkRequest" target="_blank" rel="noopener"><code>WorkRequest</code></a> 对象分配标记字符串，按逻辑对任务进行分组。这样就可以对使用特定标记的所有任务执行操作。</p>
<p>例如，<a href="https://developer.android.com/reference/androidx/work/WorkManager#cancelAllWorkByTag(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.cancelAllWorkByTag(String)</code></a> 会取消使用特定标记的所有任务，而 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfosByTagLiveData(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfosByTagLiveData(String)</code></a> 会返回 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 和具有该标记的所有任务的状态列表。</p>
<p>以下代码展示了如何使用 <a href="https://developer.android.com/reference/androidx/work/WorkRequest.Builder#addTag(java.lang.String)" target="_blank" rel="noopener"><code>WorkRequest.Builder.addTag(String)</code></a> 向任务添加“cleanup”标记：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> cacheCleanupTask =</span><br><span class="line">        OneTimeWorkRequestBuilder&lt;CacheCleanupWorker&gt;()</span><br><span class="line">    .setConstraints(constraints)</span><br><span class="line">    .addTag(<span class="string">"cleanup"</span>)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>
<h4 id="观察工作状态"><a class="markdownIt-Anchor" href="#观察工作状态"></a> 观察工作状态</h4>
<h5 id="工作状态"><a class="markdownIt-Anchor" href="#工作状态"></a> 工作状态</h5>
<p>在工作的整个生命周期内，它会经历多个不同的 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State" target="_blank" rel="noopener"><code>State</code></a></p>
<ul>
<li>如果有尚未完成的<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/chain-work" target="_blank" rel="noopener">前提性工作</a>，则工作处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#BLOCKED" target="_blank" rel="noopener"><code>BLOCKED</code></a> <code>State</code>。</li>
<li>如果工作能够在满足 <a href="https://developer.android.com/reference/androidx/work/Constraints" target="_blank" rel="noopener"><code>Constraints</code></a> 和时机条件后立即运行，则被视为处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#ENQUEUED" target="_blank" rel="noopener"><code>ENQUEUED</code></a> 状态。</li>
<li>当工作器在活跃地执行时，其处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#RUNNING" target="_blank" rel="noopener"><code>RUNNING</code></a> <code>State</code>。</li>
<li>如果工作器返回 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result#success()" target="_blank" rel="noopener"><code>Result.success()</code></a>，则被视为处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#SUCCEEDED" target="_blank" rel="noopener"><code>SUCCEEDED</code></a> 状态。这是一种终止 <code>State</code>；只有 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" target="_blank" rel="noopener"><code>OneTimeWorkRequest</code></a> 可以进入这种 <code>State</code>。</li>
<li>相反，如果工作器返回 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result#failure()" target="_blank" rel="noopener"><code>Result.failure()</code></a>，则被视为处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#FAILED" target="_blank" rel="noopener"><code>FAILED</code></a> 状态。这也是一个终止 <code>State</code>；只有 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" target="_blank" rel="noopener"><code>OneTimeWorkRequest</code></a> 可以进入这种 <code>State</code>。所有依赖工作也会被标记为 <code>FAILED</code>，并且不会运行。</li>
<li>当您明确<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work" target="_blank" rel="noopener">取消</a>尚未终止的 <code>WorkRequest</code> 时，它会进入 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#CANCELLED" target="_blank" rel="noopener"><code>CANCELLED</code></a> <code>State</code>。所有依赖工作也会被标记为 <code>CANCELLED</code>，并且不会运行。</li>
</ul>
<h5 id="观察工作状态-2"><a class="markdownIt-Anchor" href="#观察工作状态-2"></a> 观察工作状态</h5>
<p>将工作加入队列后，您可以通过 WorkManager 检查其状态。相关信息在 <a href="https://developer.android.com/reference/androidx/work/WorkInfo" target="_blank" rel="noopener"><code>WorkInfo</code></a> 对象中提供，包括工作的 <code>id</code>、标签、当前 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State" target="_blank" rel="noopener"><code>State</code></a> 和任何输出数据。</p>
<p>您通过以下三种方式之一来获取 <code>WorkInfo</code>：</p>
<ul>
<li>对于特定的 <a href="https://developer.android.com/reference/androidx/work/WorkRequest" target="_blank" rel="noopener"><code>WorkRequest</code></a>，您可以利用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfoById(java.util.UUID)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfoById(UUID)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfoByIdLiveData(java.util.UUID)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfoByIdLiveData(UUID)</code></a> 来通过 <code>WorkRequest</code> <code>id</code> 检索其 <code>WorkInfo</code>。</li>
<li>对于指定的<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work#tag" target="_blank" rel="noopener">标记</a>，您可以利用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfosByTag(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfosByTag(String)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfosByTagLiveData(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfosByTagLiveData(String)</code></a> 检索所有匹配的 <code>WorkRequest</code> 的 <code>WorkInfo</code> 对象。</li>
<li>对于<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/unique-work" target="_blank" rel="noopener">唯一工作名称</a>，您可以利用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfosForUniqueWork(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfosForUniqueWork(String)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfosForUniqueWorkLiveData(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfosForUniqueWorkLiveData(String)</code></a> 检索所有匹配的 <code>WorkRequest</code> 的 <code>WorkInfo</code> 对象。</li>
</ul>
<p>利用每个方法的 <a href="https://developer.android.com/topic/libraries/architecture/livedata" target="_blank" rel="noopener"><code>LiveData</code></a> 变量，您可以通过注册监听器来观察 <code>WorkInfo</code> 的变化。例如，如果您想要在某项工作成功完成后向用户显示消息，您可以进行如下设置：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(myContext).getWorkInfoByIdLiveData(uploadWorkRequest.id)</span><br><span class="line">        .observe(lifecycleOwner, Observer &#123; workInfo -&gt;</span><br><span class="line">            <span class="keyword">if</span> (workInfo != <span class="literal">null</span> &amp;&amp; workInfo.state == WorkInfo.State.SUCCEEDED) &#123;</span><br><span class="line">                displayMessage(<span class="string">"Work finished!"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="观察工作器的中间进度"><a class="markdownIt-Anchor" href="#观察工作器的中间进度"></a> 观察工作器的中间进度</h4>
<blockquote>
<p>WorkManager <code>2.3.0-alpha01</code> 为设置和观察工作器的中间进度添加了一流支持。如果应用在前台运行时，工作器保持运行状态，也可以使用返回 <a href="https://developer.android.com/reference/androidx/work/WorkInfo" target="_blank" rel="noopener"><code>WorkInfo</code></a> 的 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 的 API 向用户显示此信息。</p>
<p><a href="https://developer.android.com/reference/androidx/work/ListenableWorker" target="_blank" rel="noopener"><code>ListenableWorker</code></a> 现在支持 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#setProgressAsync(androidx.work.Data)" target="_blank" rel="noopener"><code>setProgressAsync()</code></a> API，此类 API 可以保留中间进度。借助这些 API，开发者能够设置可通过界面观察到的中间进度。进度由 <a href="https://developer.android.com/reference/androidx/work/Data" target="_blank" rel="noopener"><code>Data</code></a> 类型表示，这是一个可序列化的属性容器（类似于 <a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced#params" target="_blank" rel="noopener"><code>input</code> 和 <code>output</code></a>，并且受到相同的限制）。</p>
<p>只有在 <code>ListenableWorker</code> 运行时才能观察到和更新进度信息。如果尝试在 <code>ListenableWorker</code> 完成执行后在其中设置进度，则将会被忽略。您还可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfoById(java.util.UUID)" target="_blank" rel="noopener"><code>getWorkInfoBy…()</code> 或 <code>getWorkInfoBy…LiveData()</code></a> 方法来观察进度信息。这两个方法会返回 <a href="https://developer.android.com/reference/androidx/work/WorkInfo" target="_blank" rel="noopener"><code>WorkInfo</code></a> 的实例，后者有一个返回 <code>Data</code> 的新 <a href="https://developer.android.com/reference/androidx/work/WorkInfo#getProgress()" target="_blank" rel="noopener"><code>getProgress()</code></a> 方法。</p>
</blockquote>
<h5 id="更新进度"><a class="markdownIt-Anchor" href="#更新进度"></a> 更新进度</h5>
<p>对于使用 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker" target="_blank" rel="noopener"><code>ListenableWorker</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/Worker" target="_blank" rel="noopener"><code>Worker</code></a> 的 Java 开发者，<a href="https://developer.android.com/reference/androidx/work/ListenableWorker#setProgressAsync(androidx.work.Data)" target="_blank" rel="noopener"><code>setProgressAsync()</code></a> API 会返回 <code>ListenableFuture&lt;Void&gt;</code>；更新进度是异步过程，因为更新过程包括将进度信息存储在数据库中。在 Kotlin 中，您可以使用 <a href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker" target="_blank" rel="noopener"><code>CoroutineWorker</code></a> 对象的 <a href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker#setprogress" target="_blank" rel="noopener"><code>setProgress()</code></a> 扩展函数来更新进度信息。</p>
<p>此示例展示了一个简单的 <code>ProgressWorker</code>。该 <code>Worker</code> 启动时将进度设置为 0，完成时将进度值更新为 100。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> androidx.work.CoroutineWorker</span><br><span class="line"><span class="keyword">import</span> androidx.work.Data</span><br><span class="line"><span class="keyword">import</span> androidx.work.WorkerParameters</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.delay</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgressWorker</span></span>(context: Context, parameters: WorkerParameters) :</span><br><span class="line">    CoroutineWorker(context, parameters) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> Progress = <span class="string">"Progress"</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> delayDuration = <span class="number">1L</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="keyword">val</span> firstUpdate = workDataOf(Progress to <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> lastUpdate = workDataOf(Progress to <span class="number">100</span>)</span><br><span class="line">        setProgress(firstUpdate)</span><br><span class="line">        delay(delayDuration)</span><br><span class="line">        setProgress(lastUpdate)</span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="观察进度"><a class="markdownIt-Anchor" href="#观察进度"></a> 观察进度</h5>
<p>观察进度信息也很简单。您可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfoById(java.util.UUID)" target="_blank" rel="noopener"><code>getWorkInfoBy…()</code> 或 <code>getWorkInfoBy…LiveData()</code></a> 方法，并引用 <a href="https://developer.android.com/reference/androidx/work/WorkInfo" target="_blank" rel="noopener"><code>WorkInfo</code></a>。</p>
<p>以下是使用 <code>getWorkInfoByIdLiveData</code> API 的示例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(applicationContext)</span><br><span class="line">    <span class="comment">// requestId is the WorkRequest id</span></span><br><span class="line">    .getWorkInfoByIdLiveData(requestId)</span><br><span class="line">    .observe(observer, Observer &#123; workInfo: WorkInfo? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (workInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> progress = workInfo.progress</span><br><span class="line">                <span class="keyword">val</span> value = progress.getInt(Progress, <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// Do something with progress information</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="将工作链接在一起"><a class="markdownIt-Anchor" href="#将工作链接在一起"></a> 将工作链接在一起</h4>
<h5 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h5>
<p>使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager" target="_blank" rel="noopener">WorkManager</a> 创建工作链并为其排队。工作链用于指定多个关联任务并定义这些任务的运行顺序。当您需要以特定的顺序运行多个任务时，这尤其有用。</p>
<p>要创建工作链，您可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#beginWith(androidx.work.OneTimeWorkRequest)" target="_blank" rel="noopener"><code>WorkManager.beginWith(OneTimeWorkRequest)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkManager#beginWith(java.util.List)" target="_blank" rel="noopener"><code>WorkManager.beginWith(List)</code></a>，这会返回 <a href="https://developer.android.com/reference/androidx/work/WorkContinuation" target="_blank" rel="noopener"><code>WorkContinuation</code></a> 实例。</p>
<p>然后，可以通过 <code>WorkContinuation</code> 使用 <a href="https://developer.android.com/reference/androidx/work/WorkContinuation#then(androidx.work.OneTimeWorkRequest)" target="_blank" rel="noopener"><code>WorkContinuation.then(OneTimeWorkRequest)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkContinuation#then(java.util.List)" target="_blank" rel="noopener"><code>WorkContinuation.then(List)</code></a> 来添加从属 <code>OneTimeWorkRequest</code>。</p>
<p>每次调用 <code>WorkContinuation.then(...)</code> 都会返回一个新的 <code>WorkContinuation</code> 实例。如果添加了 <code>OneTimeWorkRequest</code> 的 <code>List</code>，这些请求可能会并行运行。</p>
<p>最后，您可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkContinuation#enqueue()" target="_blank" rel="noopener"><code>WorkContinuation.enqueue()</code></a> 方法为 <code>WorkContinuation</code> 链排队。</p>
<p>让我们看一个示例：某个应用对 3 个不同的图像执行图像滤镜（可能会并行执行），然后将这些图像压缩在一起，再上传它们。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(myContext)</span><br><span class="line">    <span class="comment">// Candidates to run in parallel</span></span><br><span class="line">    .beginWith(listOf(filter1, filter2, filter3))</span><br><span class="line">    <span class="comment">// Dependent work (only runs after all previous work in chain)</span></span><br><span class="line">    .then(compress)</span><br><span class="line">    .then(upload)</span><br><span class="line">    <span class="comment">// Don't forget to enqueue()</span></span><br><span class="line">    .enqueue()</span><br></pre></td></tr></table></figure>
<h5 id="input-merger"><a class="markdownIt-Anchor" href="#input-merger"></a> Input Merger</h5>
<p>在使用 <code>OneTimeWorkRequest</code> 链时，父级 <code>OneTimeWorkRequest</code> 的输出将作为输入传递给子级。因此在上面的示例中，<code>filter1</code>、<code>filter2</code> 和 <code>filter3</code> 的输出将作为输入传递给 <code>compress</code> 请求。</p>
<p>为了管理来自多个父级 <code>OneTimeWorkRequest</code> 的输入，WorkManager 使用 <a href="https://developer.android.com/reference/androidx/work/InputMerger" target="_blank" rel="noopener"><code>InputMerger</code></a>。</p>
<p>WorkManager 提供两种不同类型的 <code>InputMerger</code>：</p>
<ul>
<li><a href="https://developer.android.com/reference/androidx/work/OverwritingInputMerger" target="_blank" rel="noopener"><code>OverwritingInputMerger</code></a> 会尝试将所有输入中的所有键添加到输出中。如果发生冲突，它会覆盖先前设置的键。</li>
<li><a href="https://developer.android.com/reference/androidx/work/ArrayCreatingInputMerger" target="_blank" rel="noopener"><code>ArrayCreatingInputMerger</code></a> 会尝试合并输入，并在必要时创建数组。</li>
</ul>
<p>对于上面的示例，假设我们要保留所有图像滤镜的输出，则应使用 <code>ArrayCreatingInputMerger</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> compress: OneTimeWorkRequest = OneTimeWorkRequestBuilder&lt;CompressWorker&gt;()</span><br><span class="line">    .setInputMerger(ArrayCreatingInputMerger::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">    .setConstraints(constraints)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>
<h5 id="链接和工作状态"><a class="markdownIt-Anchor" href="#链接和工作状态"></a> 链接和工作状态</h5>
<p>创建 <code>OneTimeWorkRequest</code> 链时，需要注意以下几点：</p>
<ul>
<li>从属 <code>OneTimeWorkRequest</code> 仅在其所有父级 <code>OneTimeWorkRequest</code> 都成功完成（即返回 <code>Result.success()</code>）时才会被解除阻塞（变为 <code>ENQUEUED</code> 状态）。</li>
<li>如果有任何父级 <code>OneTimeWorkRequest</code> 失败（返回 <code>Result.failure()</code>），则所有从属 <code>OneTimeWorkRequest</code> 也会被标记为 <code>FAILED</code>。</li>
<li>如果有任何父级 <code>OneTimeWorkRequest</code> 被取消，则所有从属 <code>OneTimeWorkRequest</code> 也会被标记为 <code>CANCELLED</code>。</li>
</ul>
<h4 id="取消和停止工作"><a class="markdownIt-Anchor" href="#取消和停止工作"></a> 取消和停止工作</h4>
<p>如果您不再需要运行先前加入队列的作业，则可以申请取消。最简单的方法是使用其 <code>id</code> 并调用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#cancelWorkById(java.util.UUID)" target="_blank" rel="noopener"><code>WorkManager.cancelWorkById(UUID)</code></a> 来取消单个 WorkRequest：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">WorkManager.cancelWorkById(workRequest.id)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在后台，WorkManager 会检查工作的 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State" target="_blank" rel="noopener"><code>State</code></a>。如果工作已经<a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#isFinished()" target="_blank" rel="noopener">完成</a>，则不会发生任何变化。否则，其状态将更改为 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#CANCELLED" target="_blank" rel="noopener"><code>CANCELLED</code></a>，之后就不会运行这个工作。任何<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/chain-work" target="_blank" rel="noopener">依赖于这项工作</a>的 <a href="https://developer.android.com/reference/androidx/work/WorkRequest" target="_blank" rel="noopener"><code>WorkRequests</code></a> 的状态也将变为 <code>CANCELLED</code>。</p>
<p>此外，如果工作当前的状态为 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#RUNNING" target="_blank" rel="noopener"><code>RUNNING</code></a>，则工作器也会收到对 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#onStopped()" target="_blank" rel="noopener"><code>ListenableWorker.onStopped()</code></a> 的调用。替换此方法以处理任何可能的清理操作。我们会<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work#stopping" target="_blank" rel="noopener">在下文</a>详细讨论相关内容。</p>
<p>您也可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#cancelAllWorkByTag(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.cancelAllWorkByTag(String)</code></a> 按标记取消 WorkRequest。请注意，此方法会取消所有具有此标记的工作。此外，您还可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#cancelUniqueWork(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.cancelUniqueWork(String)</code></a> 取消具有唯一名称的所有工作。</p>
</blockquote>
<h5 id="停止正在运行的工作器"><a class="markdownIt-Anchor" href="#停止正在运行的工作器"></a> 停止正在运行的工作器</h5>
<p>WorkManager 停止正在运行的工作器可能有几种不同的原因：</p>
<ul>
<li>您明确要求取消它（例如，通过调用 <code>WorkManager.cancelWorkById(UUID)</code> 取消）。</li>
<li>如果是<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/unique-work" target="_blank" rel="noopener">唯一工作</a>，使用 <a href="https://developer.android.com/reference/androidx/work/ExistingWorkPolicy" target="_blank" rel="noopener"><code>ExistingWorkPolicy</code></a> <a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/' target="_blank" rel="noopener"reference/androidx/work/ExistingWorkPolicy#REPLACE"><code>REPLACE</code></a> 明确地将新的 <code>WorkRequest</code> 加入队列。旧的 <code>WorkRequest</code> 会立即被视为已终止。</li>
<li>您的工作约束已不再得到满足。</li>
<li>系统出于某种原因指示您的应用停止工作。如果超过 10 分钟的执行期限，可能会发生这种情况。系统将工作安排在稍后重试。</li>
</ul>
<p>在这些情况下，您的员工会收到对 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#onStopped()" target="_blank" rel="noopener"><code>ListenableWorker.onStopped()</code></a> 的调用。如果操作系统决定关闭您的应用，您应执行清理工作并以协作方式完成工作器。例如，您应该在此时或者尽早关闭数据库和文件的打开句柄。此外，如果您想要确认系统是否已经停止您的应用，都可以调用 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#isStopped()" target="_blank" rel="noopener"><code>ListenableWorker.isStopped()</code></a>。即使您通过在调用 <code>onStopped()</code> 后返回 <a href="https://developer.android.com/reference/androidx/work/Result" target="_blank" rel="noopener"><code>Result</code></a> 来指示工作已完成，WorkManager 都会忽略该 <code>Result</code>，因为工作器已经被视为停止。</p>
<h4 id="处理重复性工作"><a class="markdownIt-Anchor" href="#处理重复性工作"></a> 处理重复性工作</h4>
<blockquote>
<p>应用场景：</p>
<p>应用有时可能需要定期运行某些任务。例如，您可能要定期备份数据、下载应用中的新鲜内容，或者上传日志到服务器。将 <a href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest" target="_blank" rel="noopener"><code>PeriodicWorkRequest</code></a> 用于这种需要定期执行的任务。</p>
</blockquote>
<p><code>PeriodicWorkRequest</code> 无法<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/chain-work" target="_blank" rel="noopener">链接</a>。如果您的任务需要链接任务，请考虑 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" target="_blank" rel="noopener"><code>OneTimeWorkRequest</code></a>。</p>
<p>您可以按照以下方式创建 PeriodicWorkRequest：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">        .setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> saveRequest =</span><br><span class="line">PeriodicWorkRequestBuilder&lt;SaveImageToFileWorker&gt;(<span class="number">1</span>, TimeUnit.HOURS)</span><br><span class="line">    .setConstraints(constraints)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(myContext)</span><br><span class="line">    .enqueue(saveRequest)</span><br></pre></td></tr></table></figure>
<p>示例中展示了一个重复间隔为一小时的定期工作请求。</p>
<p>重复间隔定义为重复之间的最短时间。工作器的确切执行时间取决于您在工作请求中使用的约束，也取决于系统进行的优化。</p>
<p>在示例中，PeriodicWorkRequest 还要求设备接通电源。在这种情况下，即使过了定义的一小时重复间隔，PeriodicWorkRequest 也将在设备接通电源时运行。</p>
<p><strong>注意</strong>：可以定义的最短重复间隔是 15 分钟（与 <a href="https://developer.android.com/reference/android/app/job/JobScheduler" target="_blank" rel="noopener">JobScheduler API</a> 相同）。</p>
<h4 id="处理唯一作业"><a class="markdownIt-Anchor" href="#处理唯一作业"></a> 处理唯一作业</h4>
<blockquote>
<p>唯一工作是一个概念性非常强的术语，可确保一次只有一个具有特定名称的工作链。与 <code>id</code> 不同的是，唯一名称是人类可读的，由开发者指定，而不是由 WorkManager 自动生成。与<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work#tag" target="_blank" rel="noopener">标记</a>不同，唯一名称仅与“一个”工作链关联。</p>
</blockquote>
<p>您可以通过调用 [<code>WorkManager.enqueueUniqueWork(String, ExistingWorkPolicy, OneTimeWorkRequest)</code>](<a href="https://developer.android.com/reference/androidx/work/WorkManager#enqueueUniqueWork" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/work/WorkManager#enqueueUniqueWork</a>(java.lang.String, androidx.work.ExistingWorkPolicy, androidx.work.OneTimeWorkRequest)) 或 [<code>WorkManager.enqueueUniquePeriodicWork(String, ExistingPeriodicWorkPolicy, PeriodicWorkRequest)</code>](<a href="https://developer.android.com/reference/androidx/work/WorkManager#enqueueUniquePeriodicWork" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/work/WorkManager#enqueueUniquePeriodicWork</a>(java.lang.String, androidx.work.ExistingPeriodicWorkPolicy, androidx.work.PeriodicWorkRequest)) 创建唯一工作序列。第一个参数是唯一名称 - 这是我们用来标识 <code>WorkRequest</code> 的键。第二个参数是冲突解决策略，它指定了如果已经存在一个具有该唯一名称的未完成工作链，WorkManager 应该如何处理：</p>
<ul>
<li>取消现有工作链，并将其 <a href="https://developer.android.com/reference/androidx/work/ExistingWorkPolicy#REPLACE" target="_blank" rel="noopener"><code>REPLACE</code></a> 为新工作链。</li>
<li><a href="https://developer.android.com/reference/androidx/work/ExistingWorkPolicy#KEEP" target="_blank" rel="noopener"><code>KEEP</code></a> 现有序列并忽略您的新请求。</li>
<li>将新序列 <a href="https://developer.android.com/reference/androidx/work/ExistingWorkPolicy#APPEND" target="_blank" rel="noopener"><code>APPEND</code></a> 到现有序列，在现有序列的最后一个任务完成后运行新序列的第一个任务。您不能将 <code>APPEND</code> 与 <code>PeriodicWorkRequest</code> 一起使用。</li>
</ul>
<p>当您有不能够多次排队的任务时，唯一工作将非常有用。例如，如果您的应用需要将其数据同步到网络，您可能需要对一个名为“sync”的序列进行排队，并指定当已经存在具有该名称的序列时，应该忽略新的任务。</p>
<p>当您需要逐步构建一个长任务链时，也可以利用唯一工作序列。例如，照片编辑应用可能允许用户撤消一长串操作。其中的每一项撤消操作可能都需要一些时间来完成，但必须按正确的顺序执行。在这种情况下，应用可以创建一个“撤消”链，并根据需要将每个撤消操作附加到该链上。</p>
<p>最后，如果您需要创建一个唯一工作链，可以使用 [<code>WorkManager.beginUniqueWork(String, ExistingWorkPolicy, OneTimeWorkRequest)</code>](<a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=en#beginUniqueWork" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/work/WorkManager?hl=en#beginUniqueWork</a>(java.lang.String, androidx.work.ExistingWorkPolicy, androidx.work.OneTimeWorkRequest)) 代替 <code>beginWith()</code>。</p>
<h4 id="测试worker实现"><a class="markdownIt-Anchor" href="#测试worker实现"></a> 测试Worker实现</h4>
<blockquote>
<p>从2.1.0版本开始，WorkerManager提供了APIs，用来测试Woker，ListenableWorker，以及ListenableWorker的子类（CoroutineWorker / RxWorker / Worker）</p>
<p>在V2.1.0之前，如果要测试Workers，需要使用WorkManagerTestInitHelper去初始化WorkerManager。通过V2.1.0，不需要WorkerManagerTestInitHelper，就可以测试Woker的实现。</p>
</blockquote>
<h5 id="测试listenableworker及其子类"><a class="markdownIt-Anchor" href="#测试listenableworker及其子类"></a> 测试ListenableWorker及其子类</h5>
<p>测试ListenableWorker或者它的子类（CoroutineWorker / RxWorker），使用TestListenableWorkerBuilder。这个构建器可以帮助构建ListenableWorker的实例，用于测试Worker的业务逻辑。</p>
<p>比如，假设我们需要测试一个如下的CoroutineWorker：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepWorker</span></span>(context: Context, parameters: WorkerParameters) :</span><br><span class="line">    CoroutineWorker(context, parameters) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        delay(<span class="number">1000</span>) <span class="comment">// milliseconds</span></span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了测试SleepWorker，我们首先通过TestListenableWorkerBuilder创建Worker的实例。这个构建器也可以用来设置标签、inputData、runAttemptCount等等。具体请参考 <a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/reference/androidx/work/testing/TestListenableWorkerBuilder" target="_blank" rel="noopener"><code>TestListenableWorker</code></a></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(AndroidJUnit4::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepWorkerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> context: Context</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        context = ApplicationProvider.getApplicationContext()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testSleepWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Kotlin code can use the TestListenableWorkerBuilder extension to</span></span><br><span class="line">        <span class="comment">// build the ListenableWorker</span></span><br><span class="line">        <span class="keyword">val</span> worker = TestListenableWorkerBuilder&lt;SleepWorker&gt;(context).build()</span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            <span class="keyword">val</span> result = worker.doWork()</span><br><span class="line">            assertThat(result, `<span class="keyword">is</span>`(Result.success()))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试workers"><a class="markdownIt-Anchor" href="#测试workers"></a> 测试Workers</h5>
<p>假设我们有一个Worker，如下所示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepWorker</span></span>(context: Context, parameters: WorkerParameters) :</span><br><span class="line">    Worker(context, parameters) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> SLEEP_DURATION = <span class="string">"SLEEP_DURATION"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="comment">// Sleep on a background thread.</span></span><br><span class="line">        <span class="keyword">val</span> sleepDuration = inputData.getLong(SLEEP_DURATION, <span class="number">1000</span>)</span><br><span class="line">        Thread.sleep(sleepDuration)</span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了测试这个Worker，现在我们可以使用TestWorkerBuilder。TestWorkerBuilder和TestListenableWorkerBuilder的主要区别在于，TestWorkerBuilder允许你指定Executor来运行Worker</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kotlin code can use the TestWorkerBuilder extension to</span></span><br><span class="line"><span class="comment">// build the Worker</span></span><br><span class="line"><span class="meta">@RunWith(AndroidJUnit4::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepWorkerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> context: Context</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> executor: Executor</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        context = ApplicationProvider.getApplicationContext()</span><br><span class="line">        executor = Executors.newSingleThreadExecutor()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testSleepWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> worker = TestWorkerBuilder&lt;SleepWorker&gt;(</span><br><span class="line">            context = context,</span><br><span class="line">            executor = executor,</span><br><span class="line">            inputData = workDataOf(<span class="string">"SLEEP_DURATION"</span> to <span class="number">10000L</span>)</span><br><span class="line">        ).build()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> result = worker.doWork()</span><br><span class="line">        assertThat(result, `<span class="keyword">is</span>`(Result.success()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用workmanager进行集成测试"><a class="markdownIt-Anchor" href="#使用workmanager进行集成测试"></a> 使用WorkManager进行集成测试</h4>
<h5 id="介绍和设置"><a class="markdownIt-Anchor" href="#介绍和设置"></a> 介绍和设置</h5>
<p>WorkManager提供了一个work-testing神器，可以帮助Wokers进行Android Instrumentation测试的单元测试。</p>
<p>为了使用work-testing神器，需要在build.gradle添加依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// optional - Test helpers</span></span><br><span class="line">       androidTestImplementation <span class="string">"androidx.work:work-testing:$work_version"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：从2.1.0开始，WorkManager提供了新的TestWorkerBuilder和TestListenableWorkerBuilder类，这两个类可以让你在不需要用WorkManagerTestInitHelper初始化WorkManager的情况下，就可以测试Worker中的业务逻辑。本页中的材料对于你需要在Worker实现之外进行Worker测试时仍然很有用。</p>
</blockquote>
<h5 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h5>
<p>测试模式下，work-testing提供了WorkerManager的特殊实现，通过WorkerManagerTestInitHelper初始化。</p>
<p>work-testing还提供了一个SynchronousExecutor，它让我们可以更容易地以同步的方式编写测试，而不需要处理多个线程、锁或锁的问题。</p>
<p>通过下面的例子，来展示一起使用这些类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(AndroidJUnit4::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicInstrumentationTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> context = InstrumentationRegistry.getTargetContext()</span><br><span class="line">        <span class="keyword">val</span> config = Configuration.Builder()</span><br><span class="line">            <span class="comment">// Set log level to Log.DEBUG to make it easier to debug</span></span><br><span class="line">            .setMinimumLoggingLevel(Log.DEBUG)</span><br><span class="line">            <span class="comment">// Use a SynchronousExecutor here to make it easier to write tests</span></span><br><span class="line">            .setExecutor(SynchronousExecutor())</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize WorkManager for instrumentation tests.</span></span><br><span class="line">        WorkManagerTestInitHelper.initializeTestWorkManager(context, config)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="结构化测试"><a class="markdownIt-Anchor" href="#结构化测试"></a> 结构化测试</h5>
<p>假设我们有一个EchoWorker，期望有一些输入数据，并简单地将其复制（回传）到其输出数据</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoWorker</span></span>(context: Context, parameters: WorkerParameters)</span><br><span class="line">   : Worker(context, parameters) &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">when</span>(inputData.size()) &#123;</span><br><span class="line">           <span class="number">0</span> -&gt; Result.failure()</span><br><span class="line">           <span class="keyword">else</span> -&gt; Result.success(inputData)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="基本测试"><a class="markdownIt-Anchor" href="#基本测试"></a> 基本测试</h6>
<p>​    下面是一个测试EchoWorker的Android Instrumentation测试。这里的要点是，在测试模式下测试EchoWorker与实际应用中使用EchoWorker的方式非常相似。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Throws(Exception::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testSimpleEchoWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Define input data</span></span><br><span class="line">    <span class="keyword">val</span> input = workDataOf(KEY_1 to <span class="number">1</span>, KEY_2 to <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create request</span></span><br><span class="line">    <span class="keyword">val</span> request = OneTimeWorkRequestBuilder&lt;EchoWorker&gt;()</span><br><span class="line">        .setInputData(input)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> workManager = WorkManager.getInstance(applicationContext)</span><br><span class="line">    <span class="comment">// Enqueue and wait for result. This also runs the Worker synchronously</span></span><br><span class="line">    <span class="comment">// because we are using a SynchronousExecutor.</span></span><br><span class="line">    workManager.enqueue(request).result.<span class="keyword">get</span>()</span><br><span class="line">    <span class="comment">// Get WorkInfo and outputData</span></span><br><span class="line">    <span class="keyword">val</span> workInfo = workManager.getWorkInfoById(request.id).<span class="keyword">get</span>()</span><br><span class="line">    <span class="keyword">val</span> outputData = workInfo.outputData</span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    assertThat(workInfo.state, `<span class="keyword">is</span>`(WorkInfo.State.SUCCEEDED))</span><br><span class="line">    assertThat(outputData, `<span class="keyword">is</span>`(input))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当EchoWorker没有获取到任何输入数据的时候，我们希望返回的Result是Result.failure()</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Throws(Exception::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testEchoWorkerNoInput</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// Create request</span></span><br><span class="line">   <span class="keyword">val</span> request = OneTimeWorkRequestBuilder&lt;EchoWorker&gt;()</span><br><span class="line">       .build()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> workManager = WorkManager.getInstance(applicationContext)</span><br><span class="line">   <span class="comment">// Enqueue and wait for result. This also runs the Worker synchronously</span></span><br><span class="line">   <span class="comment">// because we are using a SynchronousExecutor.</span></span><br><span class="line">   workManager.enqueue(request).result.<span class="keyword">get</span>()</span><br><span class="line">   <span class="comment">// Get WorkInfo</span></span><br><span class="line">   <span class="keyword">val</span> workInfo = workManager.getWorkInfoById(request.id).<span class="keyword">get</span>()</span><br><span class="line">   <span class="comment">// Assert</span></span><br><span class="line">   assertThat(workInfo.state, `<span class="keyword">is</span>`(WorkInfo.State.FAILED))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="模拟约束-延迟和周期性工作"><a class="markdownIt-Anchor" href="#模拟约束-延迟和周期性工作"></a> 模拟约束、延迟和周期性工作</h5>
<blockquote>
<p>WorkManagerTestInitHelper为你提供了一个TestDriver的实例，它可以用来模拟初始化延迟、ListenableWorkers满足约束的条件，以及PeriodicWorkRequests的时间间隔。</p>
</blockquote>
<h6 id="测试初始化延迟"><a class="markdownIt-Anchor" href="#测试初始化延迟"></a> 测试初始化延迟</h6>
<p>Worker可以有初始延迟。要测试EchoWorker的初始延迟，相比于在测试中等待初始延迟，我们更倾向于使用TestDriver将WorkRequests的初始延迟标记为满足。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Throws(Exception::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testWithInitialDelay</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Define input data</span></span><br><span class="line">    <span class="keyword">val</span> input = workDataOf(KEY_1 to <span class="number">1</span>, KEY_2 to <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create request</span></span><br><span class="line">    <span class="keyword">val</span> request = OneTimeWorkRequestBuilder&lt;EchoWorker&gt;()</span><br><span class="line">        .setInputData(input)</span><br><span class="line">        .setInitialDelay(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> workManager = WorkManager.getInstance(getApplicationContext())</span><br><span class="line">    <span class="keyword">val</span> testDriver = WorkManagerTestInitHelper.getTestDriver()</span><br><span class="line">    <span class="comment">// Enqueue and wait for result.</span></span><br><span class="line">    workManager.enqueue(request).result.<span class="keyword">get</span>()</span><br><span class="line">    testDriver.setInitialDelayMet(request.id)</span><br><span class="line">    <span class="comment">// Get WorkInfo and outputData</span></span><br><span class="line">    <span class="keyword">val</span> workInfo = workManager.getWorkInfoById(request.id).<span class="keyword">get</span>()</span><br><span class="line">    <span class="keyword">val</span> outputData = workInfo.outputData</span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    assertThat(workInfo.state, `<span class="keyword">is</span>`(WorkInfo.State.SUCCEEDED))</span><br><span class="line">    assertThat(outputData, `<span class="keyword">is</span>`(input))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="测试约束"><a class="markdownIt-Anchor" href="#测试约束"></a> 测试约束</h6>
<p>TestDriver通过setAllConstraintsMet方法，可以标记约束条件被满足。</p>
<p>下面是一个关于如何用约束来测试Worker的例子。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Throws(Exception::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testWithConstraints</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Define input data</span></span><br><span class="line">    <span class="keyword">val</span> input = workDataOf(KEY_1 to <span class="number">1</span>, KEY_2 to <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">        .setRequiredNetworkType(NetworkType.CONNECTED)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create request</span></span><br><span class="line">    <span class="keyword">val</span> request = OneTimeWorkRequestBuilder&lt;EchoWorker&gt;()</span><br><span class="line">        .setInputData(input)</span><br><span class="line">        .setConstraints(constraints)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> workManager = WorkManager.getInstance(myContext)</span><br><span class="line">    <span class="keyword">val</span> testDriver = WorkManagerTestInitHelper.getTestDriver()</span><br><span class="line">    <span class="comment">// Enqueue and wait for result.</span></span><br><span class="line">    workManager.enqueue(request).result.<span class="keyword">get</span>()</span><br><span class="line">    testDriver.setAllConstraintsMet(request.id)</span><br><span class="line">    <span class="comment">// Get WorkInfo and outputData</span></span><br><span class="line">    <span class="keyword">val</span> workInfo = workManager.getWorkInfoById(request.id).<span class="keyword">get</span>()</span><br><span class="line">    <span class="keyword">val</span> outputData = workInfo.outputData</span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    assertThat(workInfo.state, `<span class="keyword">is</span>`(WorkInfo.State.SUCCEEDED))</span><br><span class="line">    assertThat(outputData, `<span class="keyword">is</span>`(input))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="测试周期性工作"><a class="markdownIt-Anchor" href="#测试周期性工作"></a> 测试周期性工作</h6>
<p>TestDriver还公开了一个setPeriodDelayMet，它可以用来表示一个间隔已经完成。</p>
<p>下面是一个使用setPeriodDelayMet的例子。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Throws(Exception::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testPeriodicWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Define input data</span></span><br><span class="line">    <span class="keyword">val</span> input = workDataOf(KEY_1 to <span class="number">1</span>, KEY_2 to <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create request</span></span><br><span class="line">    <span class="keyword">val</span> request = PeriodicWorkRequestBuilder&lt;EchoWorker&gt;(<span class="number">15</span>, MINUTES)</span><br><span class="line">        .setInputData(input)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> workManager = WorkManager.getInstance(myContext)</span><br><span class="line">    <span class="keyword">val</span> testDriver = WorkManagerTestInitHelper.getTestDriver()</span><br><span class="line">    <span class="comment">// Enqueue and wait for result.</span></span><br><span class="line">    workManager.enqueue(request).result.<span class="keyword">get</span>()</span><br><span class="line">    <span class="comment">// Tells the testing framework the period delay is met</span></span><br><span class="line">    testDriver.setPeriodDelayMet(request.id)</span><br><span class="line">    <span class="comment">// Get WorkInfo and outputData</span></span><br><span class="line">    <span class="keyword">val</span> workInfo = workManager.getWorkInfoById(request.id).<span class="keyword">get</span>()</span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    assertThat(workInfo.state, `<span class="keyword">is</span>`(WorkInfo.State.ENQUEUED))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调试workmanager"><a class="markdownIt-Anchor" href="#调试workmanager"></a> 调试WorkManager</h4>
<h3 id="高级概念"><a class="markdownIt-Anchor" href="#高级概念"></a> 高级概念</h3>
<h4 id="配置和初始化"><a class="markdownIt-Anchor" href="#配置和初始化"></a> 配置和初始化</h4>
<blockquote>
<p>默认情况下，当您的应用启动时，WorkManager 使用适合大多数应用的合理选项自动进行配置。如果您需要进一步控制 WorkManager 管理和调度工作的方式，可以通过自己初始化 WorkManager 自定义 WorkManager 配置。</p>
</blockquote>
<h5 id="workmanager-210及更高版本"><a class="markdownIt-Anchor" href="#workmanager-210及更高版本"></a> WorkManager 2.1.0及更高版本</h5>
<blockquote>
<p>WorkManager 2.1.0 有多种配置 WorkManager 的方式。为 WorkManager 提供自定义初始化的最灵活方式是使用 WorkManager 2.1.0 及更高版本中提供的<a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/custom-configuration#on-demand" target="_blank" rel="noopener"><em>按需初始化</em></a>。</p>
</blockquote>
<h6 id="按需初始化"><a class="markdownIt-Anchor" href="#按需初始化"></a> 按需初始化</h6>
<p>通过按需初始化，您可以仅在需要 WorkManager 时创建该组件，而不必每次应用启动时都创建。这样做可将 WorkManager 从关键启动路径中移出，从而提高应用启动性能。</p>
<h6 id="移除默认初始化程序"><a class="markdownIt-Anchor" href="#移除默认初始化程序"></a> 移除默认初始化程序</h6>
<p>要提供自己的配置，必须先移除默认初始化程序。为此，请使用合并规则 <code>tools:node=&quot;remove&quot;</code> 更新 <a href="https://developer.android.com/guide/topics/manifest/manifest-intro" target="_blank" rel="noopener"><code>AndroidManifest.xml</code></a>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"androidx.work.impl.WorkManagerInitializer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.workmanager-init"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:node</span>=<span class="string">"remove"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>要详细了解如何在清单中使用合并规则，请参阅有关<a href="https://developer.android.com/studio/build/manifest-merge" target="_blank" rel="noopener">合并多个清单文件</a>的文档。</p>
</blockquote>
<h6 id="实现configrationprovider"><a class="markdownIt-Anchor" href="#实现configrationprovider"></a> 实现Configration.Provider</h6>
<p>让您的 <code>Application</code> 类实现 <a href="https://developer.android.com/reference/androidx/work/Configuration.Provider" target="_blank" rel="noopener"><code>Configuration.Provider</code></a> 接口，并提供您自己的 <a href="https://developer.android.com/reference/androidx/work/Configuration.Provider#getWorkManagerConfiguration()" target="_blank" rel="noopener"><code>Configuration.Provider.getWorkManagerConfiguration()</code></a> 实现。</p>
<p>当您需要使用 WorkManager 时，请确保调用方法 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getInstance(android.content.Context)" target="_blank" rel="noopener"><code>WorkManager.getInstance(Context)</code></a>。WorkManager 调用应用的自定义 <code>getWorkManagerConfiguration()</code> 方法来发现其 <code>Configuration</code>。（您无需自己调用 <code>WorkManager.initialize()</code>。）</p>
<p><strong>注意</strong>：如果您在 WorkManager 初始化之前调用已弃用的无参数 <code>WorkManager.getInstance()</code> 方法，该方法将抛出异常。您应始终使用 <code>WorkManager.getInstance(Context)</code> 方法，即使您不自定义 WorkManager。</p>
<p>以下示例展示了自定义 <code>getWorkManagerConfiguration()</code> 实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myApplication</span></span>() : Application(), Configuration.Provider &#123;</span><br><span class="line">     <span class="keyword">override</span> getWorkManagerConfiguration() =</span><br><span class="line">           Configuration.Builder()</span><br><span class="line">                .setMinimumLoggingLevel(android.util.Log.INFO)</span><br><span class="line">                .build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="workmanager-201及更早版本"><a class="markdownIt-Anchor" href="#workmanager-201及更早版本"></a> WorkManager 2.0.1及更早版本</h5>
<h6 id="默认初始化"><a class="markdownIt-Anchor" href="#默认初始化"></a> 默认初始化</h6>
<blockquote>
<p>当您的应用启动时，WorkManager 使用自定义 <code>ContentProvider</code> 进行初始化。此代码位于内部类 <code>androidx.work.impl.WorkManagerInitializer</code> 中，并使用默认 <a href="https://developer.android.com/reference/androidx/work/Configuration" target="_blank" rel="noopener"><code>Configuration</code></a>。自动使用默认初始化程序（除非<a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/custom-configuration#remove-default" target="_blank" rel="noopener">明确停用它</a>）。默认初始化程序适合大多数应用。</p>
</blockquote>
<h6 id="自定义初始化"><a class="markdownIt-Anchor" href="#自定义初始化"></a> 自定义初始化</h6>
<p>如果您想控制初始化进程，则必须<a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/custom-configuration#remove-default" target="_blank" rel="noopener">停用默认初始化程序</a>，然后定义您自己的自定义配置。</p>
<p>移除默认初始化程序后，可以手动初始化 WorkManager：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// provide custom configuration</span></span><br><span class="line"><span class="keyword">val</span> myConfig = Configuration.Builder()</span><br><span class="line">    .setMinimumLoggingLevel(android.util.Log.INFO)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize WorkManager</span></span><br><span class="line">WorkManager.initialize(<span class="keyword">this</span>, myConfig)</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.android.com/reference/androidx/work/WorkManager" target="_blank" rel="noopener"><code>WorkManager</code></a> 单例。确保初始化在 <a href="https://developer.android.com/reference/android/app/Application#onCreate()" target="_blank" rel="noopener"><code>Application.onCreate()</code></a> 或 <a href="https://developer.android.com/reference/android/content/ContentProvider#onCreate()" target="_blank" rel="noopener"><code>ContentProvider.onCreate()</code></a> 中运行。</p>
<p>有关可用自定义的完整列表，请参阅 <a href="https://developer.android.com/reference/androidx/work/Configuration.Builder" target="_blank" rel="noopener"><code>Configuration.Builder()</code></a> 参考文档。</p>
<h4 id="workmanager中的线程处理"><a class="markdownIt-Anchor" href="#workmanager中的线程处理"></a> WorkManager中的线程处理</h4>
<h5 id="概览-2"><a class="markdownIt-Anchor" href="#概览-2"></a> 概览</h5>
<p>WorkManager 提供了四种不同类型的工作基元：</p>
<ul>
<li><a href="https://developer.android.com/reference/androidx/work/Worker" target="_blank" rel="noopener"><code>Worker</code></a> 是最简单的实现，前面几节已经有所介绍。WorkManager 会在后台线程上自动运行它（您可以将它替换掉）。请参阅<a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/worker" target="_blank" rel="noopener">工作器中的线程处理</a>，详细了解 <code>Worker</code> 中的线程处理。</li>
<li>建议 Kotlin 用户实现 <a href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker" target="_blank" rel="noopener"><code>CoroutineWorker</code></a>。<code>CoroutineWorker</code> 针对后台工作公开挂起函数。默认情况下，它们运行默认的 <code>Dispatcher</code>，您可以对其进行自定义。请参阅 <a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/coroutineworker" target="_blank" rel="noopener">CorventineWorker 中的线程处理</a>，详细了解 <code>CoroutineWorker</code> 中的线程处理。</li>
<li>建议 RxJava2 用户实现 <a href="https://developer.android.com/reference/androidx/work/RxWorker" target="_blank" rel="noopener"><code>RxWorker</code></a>。如果您有很多现有异步代码是用 RxJava 建模的，则应使用 RxWirkers。与所有 RxJava2 概念一样，您可以自由选择所需的线程处理策略。请参阅 <a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/rxworker" target="_blank" rel="noopener">RxWorker 中的线程处理</a>，详细了解 <code>RxWorker</code> 中的线程处理。</li>
<li><a href="https://developer.android.com/reference/androidx/work/ListenableWorker" target="_blank" rel="noopener"><code>ListenableWorker</code></a> 是 <code>Worker</code>、<code>CoroutineWorker</code> 和 <code>RxWorker</code> 的基类。该类专为需要与基于回调的异步 API（例如 <code>FusedLocationProviderClient</code>）进行交互并且不使用 RxJava2 的 Java 开发者而设计。请参阅 <a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/listenableworker" target="_blank" rel="noopener">ListenableWorker 中的线程处理</a>，详细了解 <code>ListenableWorker</code> 中的线程处理。</li>
</ul>
<h5 id="用worker处理线程"><a class="markdownIt-Anchor" href="#用worker处理线程"></a> 用Worker处理线程</h5>
<p>​    当您使用 <a href="https://developer.android.com/reference/androidx/work/Worker" target="_blank" rel="noopener"><code>Worker</code></a> 时，WorkManager 会自动在后台线程中调用 <a href="https://developer.android.com/reference/androidx/work/Worker#doWork()" target="_blank" rel="noopener"><code>Worker.doWork()</code></a>。该后台线程来自于 WorkManager 的 <a href="https://developer.android.com/reference/androidx/work/Configuration" target="_blank" rel="noopener"><code>Configuration</code></a> 中指定的 <code>Executor</code>。</p>
<p>​    默认情况下，WorkManager 会为您设置 <code>Executor</code>，但您也可以自己进行自定义。</p>
<p>​    例如，您可以在应用中共享现有的后台 <code>Executor</code>，也可以创建单线程 <code>Executor</code> 以确保所有后台工作都按顺序执行，甚至可以指定一个具有不同线程数的 <code>ThreadPool</code>。</p>
<p>​    要自定义 <code>Executor</code>，请确保您已启用 <a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/custom-configuration" target="_blank" rel="noopener">WorkManager 的手动初始化</a>。在配置 WorkManager 时，您可以按以下方式指定 <code>Executor</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">WorkManager.initialize(</span><br><span class="line">    context,</span><br><span class="line">    Configuration.Builder()</span><br><span class="line">        .setExecutor(Executors.newFixedThreadPool(<span class="number">8</span>))</span><br><span class="line">        .build())</span><br></pre></td></tr></table></figure>
<p>下面是一个简单的工作器示例，它按顺序下载某些网站的内容：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadWorker</span></span>(context: Context, params: WorkerParameters) : Worker(context, params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: ListenableWorker.Result &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">99</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                downloadSynchronously(<span class="string">"https://www.google.com"</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">return</span> ListenableWorker.Result.failure()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ListenableWorker.Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，<a href="https://developer.android.com/reference/androidx/work/Worker#doWork()" target="_blank" rel="noopener"><code>Worker.doWork()</code></a> 是同步调用 - 您将会以阻塞方式完成整个后台工作，并在方法退出时完成工作。如果您在 <code>doWork()</code> 中调用异步 API 并返回 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result" target="_blank" rel="noopener"><code>Result</code></a>，则回调可能无法正常运行。如果您遇到这种情况，请考虑使用 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker" target="_blank" rel="noopener"><code>ListenableWorker</code></a>（请参阅<a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/listenableworker" target="_blank" rel="noopener">在 ListenableWorker 中进行线程处理</a>）。</p>
</blockquote>
<p>当前正在运行的 <code>Worker</code> <a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work" target="_blank" rel="noopener">因为任何原因而停止</a>时，它会收到对 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#onStopped()" target="_blank" rel="noopener"><code>Worker.onStopped()</code></a> 的调用。替换此方法或在代码的检查点处调用 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#isStopped()" target="_blank" rel="noopener"><code>Worker.isStopped()</code></a>，并在必要时释放资源。当上述示例中的 <code>Worker</code> 被停止时，下载项目可能才下载了一半，并且会继续下载，即使已经被停止也不受影响。要优化此行为，您可以执行以下操作：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadWorker</span></span>(context: Context, params: WorkerParameters) : Worker(context, params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: ListenableWorker.Result &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">99</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isStopped) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                downloadSynchronously(<span class="string">"https://www.google.com"</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">return</span> ListenableWorker.Result.failure()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ListenableWorker.Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Worker</code> 停止后，从 <code>Worker.doWork()</code> 返回什么已不重要；<code>Result</code> 将被忽略。</p>
<h5 id="用coroutineworker处理线程"><a class="markdownIt-Anchor" href="#用coroutineworker处理线程"></a> 用CoroutineWorker处理线程</h5>
<p>对于 Kotlin 用户，WorkManager 为<a href="https://kotlinlang.org/docs/reference/coroutines-overview.html" target="_blank" rel="noopener">协程</a>提供了一流的支持。要开始使用，请将 <a href="https://developer.android.com/jetpack/androidx/releases/work#declaring_dependencies" target="_blank" rel="noopener"><code>work-runtime-ktx</code> 包含到您的 gradle 文件中</a>。不要扩展 <a href="https://developer.android.com/reference/androidx/work/Worker" target="_blank" rel="noopener"><code>Worker</code></a>，而应扩展 <a href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker" target="_blank" rel="noopener"><code>CoroutineWorker</code></a>，后者使用的 API 略有不同。例如，如果要构建简单的 <code>CoroutineWorker</code> 来执行某些网络操作，则需要执行以下操作：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineDownloadWorker</span></span>(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result = coroutineScope &#123;</span><br><span class="line">        <span class="keyword">val</span> jobs = (<span class="number">0</span> until <span class="number">100</span>).map &#123;</span><br><span class="line">            async &#123;</span><br><span class="line">                downloadSynchronously(<span class="string">"https://www.google.com"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// awaitAll will throw an exception if a download fails, which CoroutineWorker will treat as a failure</span></span><br><span class="line">        jobs.awaitAll()</span><br><span class="line">        Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<a href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker#doWork()" target="_blank" rel="noopener"><code>CoroutineWorker.doWork()</code></a> 是一个“挂起”函数。不同于 <code>Worker</code>，此代码不会在 <a href="https://developer.android.com/reference/androidx/work/Configuration" target="_blank" rel="noopener"><code>Configuration</code></a> 中指定的 <code>Executor</code> 上运行，而是默认为 <code>Dispatchers.Default</code>。您可以提供自己的 <code>CoroutineContext</code> 来自定义这个行为。在上面的示例中，您可能希望在 <code>Dispatchers.IO</code> 上完成此操作，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineDownloadWorker</span></span>(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext = Dispatchers.IO</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result = coroutineScope &#123;</span><br><span class="line">        <span class="keyword">val</span> jobs = (<span class="number">0</span> until <span class="number">100</span>).map &#123;</span><br><span class="line">            async &#123;</span><br><span class="line">                downloadSynchronously(<span class="string">"https://www.google.com"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// awaitAll will throw an exception if a download fails, which CoroutineWorker will treat as a failure</span></span><br><span class="line">        jobs.awaitAll()</span><br><span class="line">        Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CoroutineWorker</code> 通过取消协程并传播取消信号来自动处理停工情况。您无需执行任何特殊操作来处理<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work" target="_blank" rel="noopener">停工情况</a>。</p>
<h5 id="用rxworker处理线程"><a class="markdownIt-Anchor" href="#用rxworker处理线程"></a> 用RxWorker处理线程</h5>
<p>我们提供了 WorkManager 与 RxJava2 之间的互操作性。要开始使用这种互操作性，除了 <a href="https://developer.android.com/jetpack/androidx/releases/work#declaring_dependencies" target="_blank" rel="noopener"><code>work-runtime</code>，还应将 <code>work-rxjava2</code></a> 包含到 gradle 文件中。然后，您应该扩展 <code>RxWorker</code>，而不是扩展 <code>Worker</code>。最后替换 <a href="https://developer.android.com/reference/androidx/work/RxWorker#createWork()" target="_blank" rel="noopener"><code>RxWorker.createWork()</code></a> 方法以返回 <code>Single&lt;Result&gt;</code>，用于表示您执行的 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result" target="_blank" rel="noopener"><code>Result</code></a>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxDownloadWorker</span> <span class="keyword">extends</span> <span class="title">RxWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RxDownloadWorker</span><span class="params">(Context context, WorkerParameters params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Single&lt;Result&gt; <span class="title">createWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.range(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">            .flatMap &#123; download(<span class="string">"https://www.google.com"</span>) &#125;</span><br><span class="line">            .toList()</span><br><span class="line">            .map &#123; Result.success() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>RxWorker.createWork()</code> 在主线程上调用，但默认情况下会在后台线程上订阅返回值。您可以替换 <a href="https://developer.android.com/reference/androidx/work/RxWorker#getBackgroundScheduler()" target="_blank" rel="noopener"><code>RxWorker.getBackgroundScheduler()</code></a> 来更改订阅线程。</p>
<p>停止 <code>RxWorker</code> 会妥善处理 <code>Observer</code>，因此您无需以任何特殊方式处理<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work" target="_blank" rel="noopener">停工</a>。</p>
<h5 id="用listenableworker处理线程"><a class="markdownIt-Anchor" href="#用listenableworker处理线程"></a> 用ListenableWorker处理线程</h5>
<p>在某些情况下，您可能需要提供自定义线程处理策略。例如，您可能需要处理基于回调的异步操作。在这种情况下，不能只依靠 <code>Worker</code> 来完成操作，因为它无法以阻塞方式完成这项任务。WorkManager 通过 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker" target="_blank" rel="noopener"><code>ListenableWorker</code></a> 支持该用例。<code>ListenableWorker</code> 是最低层级的工作器 API；<a href="https://developer.android.com/reference/androidx/work/Worker" target="_blank" rel="noopener"><code>Worker</code></a>、<a href="https://developer.android.com/reference/androidx/work/CoroutineWorker" target="_blank" rel="noopener"><code>CoroutineWorker</code></a> 和 <a href="https://developer.android.com/reference/androidx/work/RxWorker" target="_blank" rel="noopener"><code>RxWorker</code></a> 都是从这个类衍生而来的。<code>ListenableWorker</code> 只会发出信号以表明应该开始和停止工作，而线程处理则完全交由您负责完成。开始工作信号在主线程上调用，因此请务必手动转到您选择的后台线程。</p>
<p>抽象方法 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#startWork()" target="_blank" rel="noopener"><code>ListenableWorker.startWork()</code></a> 会返回一个将使用操作的 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result" target="_blank" rel="noopener"><code>Result</code></a> 设置的 <code>ListenableFuture</code>。<code>ListenableFuture</code> 是一个轻量级接口：它是一个 <code>Future</code>，用于提供附加监听器和传播异常的功能。在 <code>startWork</code> 方法中，应该返回 <code>ListenableFuture</code>，完成操作后，您需要使用操作的 <code>Result</code> 设置这个返回结果。您可以通过以下两种方式创建 <code>ListenableFuture</code>：</p>
<ol>
<li>如果您使用的是 Guava，请使用 <code>ListeningExecutorService</code>。</li>
<li>否则，请将 <a href="https://developer.android.com/jetpack/androidx/releases/concurrent#declaring_dependencies" target="_blank" rel="noopener"><code>councurrent-futures</code></a> 包含到您的 gradle 文件并使用 <a href="https://developer.android.com/reference/androidx/concurrent/futures/CallbackToFutureAdapter" target="_blank" rel="noopener"><code>CallbackToFutureAdapter</code></a>。</li>
</ol>
<p>如果您希望基于异步回调执行某些工作，可以执行如下操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackWorker</span> <span class="keyword">extends</span> <span class="title">ListenableWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallbackWorker</span><span class="params">(Context context, WorkerParameters params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListenableFuture&lt;Result&gt; <span class="title">startWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CallbackToFutureAdapter.getFuture(completer -&gt; &#123;</span><br><span class="line">            Callback callback = <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                <span class="keyword">int</span> successes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                    completer.setException(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> </span>&#123;</span><br><span class="line">                    ++successes;</span><br><span class="line">                    <span class="keyword">if</span> (successes == <span class="number">100</span>) &#123;</span><br><span class="line">                        completer.set(Result.success());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">                downloadAsynchronously(<span class="string">"https://www.google.com"</span>, callback);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> callback;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您的工作<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work" target="_blank" rel="noopener">停止</a>会发生什么？如果预计工作会停止，则始终会取消 <code>ListenableWorker</code> 的 <code>ListenableFuture</code>。通过使用 <code>CallbackToFutureAdapter</code>，您只需添加一个取消监听器即可，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackWorker</span> <span class="title">extends</span> <span class="title">ListenableWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CallbackWorker(Context context, WorkerParameters params) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ListenableFuture&lt;Result&gt; startWork() &#123;</span><br><span class="line">        <span class="keyword">return</span> CallbackToFutureAdapter.getFuture(completer -&gt; &#123;</span><br><span class="line">            Callback callback = new Callback() &#123;</span><br><span class="line">                int successes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> void onFailure(Call call, IOException e) &#123;</span><br><span class="line">                    completer.setException(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> void onResponse(Call call, Response response) &#123;</span><br><span class="line">                    ++successes;</span><br><span class="line">                    <span class="keyword">if</span> (successes == <span class="number">100</span>) &#123;</span><br><span class="line">                        completer.<span class="keyword">set</span>(Result.success());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            completer.addCancellationListener(cancelDownloadsRunnable, executor);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">                downloadAsynchronously(<span class="string">"https://www.google.com"</span>, callback);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> callback;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="支持长时间运行的工作器"><a class="markdownIt-Anchor" href="#支持长时间运行的工作器"></a> 支持长时间运行的工作器</h4>
<p>​    WorkManager 2.3.0-alpha02增加了对长期运行的工作者的一流支持。在这种情况下，WorkManager可以向操作系统提供一个信号，即如果可能的话，在执行该工作的同时，应该保持进程的活力。这些Worker的运行时间可以超过10分钟。这个新功能的用例包括批量上传或下载（不能分组），在本地进行ML模型的压缩，或对应用的用户来说很重要的任务。</p>
<p>​    在引擎盖下，WorkManager代表你管理并运行一个前台服务来执行WorkRequest，同时也会显示一个可配置的通知。</p>
<p>​    ListenableWorker现在支持setForegroundAsync()API，而CoroutineWorker则支持暂停setForeground()API。这些API允许开发人员指定这个WorkRequest是重要的（从用户的角度来看）或长期运行的WorkRequest。</p>
<p>​    从 2.3.0-alpha03 版本开始，WorkManager还允许用户创建一个PendingIntent，无需使用createCancelPendingIntent()API注册一个新的Android组件，就可以用来取消Worker。这种方法在与setForegroundAsync()或setForeground()API一起使用时特别有用，可以用来添加一个取消Worker的通知动作。</p>
<h5 id="创建和管理长时间运行的任务"><a class="markdownIt-Anchor" href="#创建和管理长时间运行的任务"></a> 创建和管理长时间运行的任务</h5>
<h6 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h6>
<p>使用ListenableWorker或Worker的开发者可以调用setForegroundAsync()API，返回一个ListenableFuture<Void>。你也可以调用setForegroundAsync()，来更新一个正在运行的Notification。</p>
<p>下面是一个简单的例子，它是一个长期运行的worker下载文件。这个Worker会跟踪进度，更新一个正在进行的Notification，显示下载进度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_INPUT_URL = <span class="string">"KEY_INPUT_URL"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_OUTPUT_FILE_NAME = <span class="string">"KEY_OUTPUT_FILE_NAME"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NotificationManager notificationManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadWorker</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull WorkerParameters parameters)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(context, parameters);</span><br><span class="line">            notificationManager = (NotificationManager)</span><br><span class="line">                context.getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Data inputData = getInputData();</span><br><span class="line">        String inputUrl = inputData.getString(KEY_INPUT_URL);</span><br><span class="line">        String outputFile = inputData.getString(KEY_OUTPUT_FILE_NAME);</span><br><span class="line">        <span class="comment">// Mark the Worker as important</span></span><br><span class="line">        String progress = <span class="string">"Starting Download"</span>;</span><br><span class="line">        setForegroundAsync(createForegroundInfo(progress));</span><br><span class="line">        download(inputUrl, outputFile);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String inputUrl, String outputFile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Downloads a file and updates bytes read</span></span><br><span class="line">        <span class="comment">// Calls setForegroundInfoAsync() periodically when it needs to update</span></span><br><span class="line">       <span class="comment">// the ongoing Notification</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ForegroundInfo <span class="title">createForegroundInfo</span><span class="params">(@NonNull String progress)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Build a notification using bytesRead and contentLength</span></span><br><span class="line"></span><br><span class="line">        Context context = getApplicationContext();</span><br><span class="line">        String id = context.getString(R.string.notification_channel_id);</span><br><span class="line">        String title = context.getString(R.string.notification_title);</span><br><span class="line">        String cancel = context.getString(R.string.cancel_download);</span><br><span class="line">        <span class="comment">// This PendingIntent can be used to cancel the worker</span></span><br><span class="line">        PendingIntent intent = WorkManager.getInstance(context)</span><br><span class="line">                .createCancelPendingIntent(getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            createChannel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Notification notification = <span class="keyword">new</span> NotificationCompat.Builder(context, id)</span><br><span class="line">                .setContentTitle(title)</span><br><span class="line">                .setTicker(title)</span><br><span class="line">                .setSmallIcon(R.drawable.ic_work_notification)</span><br><span class="line">                .setOngoing(<span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">// Add the cancel action to the notification which can</span></span><br><span class="line">                <span class="comment">// be used to cancel the worker</span></span><br><span class="line">                .addAction(android.R.drawable.ic_delete, cancel, intent)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForegroundInfo(notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi</span>(Build.VERSION_CODES.O)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a Notification channel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h6>
<p>Kotlin开发者应该使用CoroutineWorker，而不是使用setForegroundAsync()，你可以使用该方法的悬浮版本的setForeground()来代替。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadWorker</span></span>(context: Context, parameters: WorkerParameters) :</span><br><span class="line">    CoroutineWorker(context, parameters) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> notificationManager =</span><br><span class="line">        context.getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span></span><br><span class="line">                NotificationManager</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="keyword">val</span> inputUrl = inputData.getString(KEY_INPUT_URL)</span><br><span class="line">                       ?: <span class="keyword">return</span> Result.failure()</span><br><span class="line">        <span class="keyword">val</span> outputFile = inputData.getString(KEY_OUTPUT_FILE_NAME)</span><br><span class="line">                       ?: <span class="keyword">return</span> Result.failure()</span><br><span class="line">        <span class="comment">// Mark the Worker as important</span></span><br><span class="line">        <span class="keyword">val</span> progress = <span class="string">"Starting Download"</span></span><br><span class="line">        setForeground(createForegroundInfo(progress))</span><br><span class="line">        download(inputUrl, outputFile)</span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">download</span><span class="params">(inputUrl: <span class="type">String</span>, outputFile: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Downloads a file and updates bytes read</span></span><br><span class="line">        <span class="comment">// Calls setForegroundInfo() periodically when it needs to update</span></span><br><span class="line">        <span class="comment">// the ongoing Notification</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Creates an instance of ForegroundInfo which can be used to update the</span></span><br><span class="line">    <span class="comment">// ongoing notification.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createForegroundInfo</span><span class="params">(progress: <span class="type">String</span>)</span></span>: ForegroundInfo &#123;</span><br><span class="line">        <span class="keyword">val</span> id = applicationContext.getString(R.string.notification_channel_id)</span><br><span class="line">        <span class="keyword">val</span> title = applicationContext.getString(R.string.notification_title)</span><br><span class="line">        <span class="keyword">val</span> cancel = applicationContext.getString(R.string.cancel_download)</span><br><span class="line">        <span class="comment">// This PendingIntent can be used to cancel the worker</span></span><br><span class="line">        <span class="keyword">val</span> intent = WorkManager.getInstance(applicationContext)</span><br><span class="line">                .createCancelPendingIntent(getId())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a Notification channel if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            createChannel()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> notification = NotificationCompat.Builder(applicationContext, id)</span><br><span class="line">            .setContentTitle(title)</span><br><span class="line">            .setTicker(title)</span><br><span class="line">            .setContentText(progress)</span><br><span class="line">            .setSmallIcon(R.drawable.ic_work_notification)</span><br><span class="line">            .setOngoing(<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// Add the cancel action to the notification which can</span></span><br><span class="line">            <span class="comment">// be used to cancel the worker</span></span><br><span class="line">            .addAction(android.R.drawable.ic_delete, cancel, intent)</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ForegroundInfo(notification)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.O)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Create a Notification channel</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> KEY_INPUT_URL = <span class="string">"KEY_INPUT_URL"</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> KEY_OUTPUT_FILE_NAME = <span class="string">"KEY_OUTPUT_FILE_NAME"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从firebase-jobdispatcher迁移"><a class="markdownIt-Anchor" href="#从firebase-jobdispatcher迁移"></a> 从Firebase JobDispatcher迁移</h3>
<h3 id="从gcmnetworkmanager迁移"><a class="markdownIt-Anchor" href="#从gcmnetworkmanager迁移"></a> 从GCMNetworkManager迁移</h3>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/9-ViewModel/">9-ViewModel</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JetPack/">JetPack</a></span><div class="content"><p>ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续存在。</p>
<p>在ViewModel之前，面临的问题：</p>
<ul>
<li>
<p>如果系统销毁或重新创建界面控制器，则存储在其中的任何临时性界面相关数据都会丢失。</p>
<blockquote>
<p>对于简单的数据，Activity 可以使用 <code>onSaveInstanceState()</code> 方法从 <code>onCreate()</code> 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。</p>
</blockquote>
</li>
<li>
<p>界面控制器经常需要进行异步调用，这些调用可能需要一些时间才能返回结果。</p>
<blockquote>
<p>界面控制器需要管理这些调用，并确保系统在其销毁后清理这些调用以避免潜在的内存泄露。此项管理需要大量的维护工作，并且在因配置更改而重新创建对象的情况下，会造成资源的浪费，因为对象可能需要重新发出已经发出过的调用。</p>
</blockquote>
</li>
</ul>
<h3 id="实现viewmodel"><a class="markdownIt-Anchor" href="#实现viewmodel"></a> 实现ViewModel</h3>
<p>架构组件为界面控制器提供了 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 辅助程序类，该类负责为界面准备数据。 在配置更改期间会自动保留 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象，以便它们存储的数据立即可供下一个 Activity 或 Fragment 实例使用。</p>
<p>例如，如果您需要在应用中显示用户列表，请确保将获取和保留该用户列表的责任分配给 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a>，而不是 Activity 或 Fragment，如以下示例代码所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> users: MutableLiveData&lt;List&lt;User&gt;&gt; <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        MutableLiveData().also &#123;</span><br><span class="line">            loadUsers()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUsers</span><span class="params">()</span></span>: LiveData&lt;List&lt;User&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> users</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadUsers</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Do an asynchronous operation to fetch users.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，您可以从 Activity 访问该列表，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class="line">        <span class="comment">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> model = ViewModelProviders.of(<span class="keyword">this</span>)[MyViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>]</span></span><br><span class="line">        model.getUsers().observe(<span class="keyword">this</span>, Observer&lt;List&lt;User&gt;&gt;&#123; users -&gt;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果重新创建了该 Activity，它接收的 <code>MyViewModel</code> 实例与第一个 Activity 创建的实例相同。当所有者 Activity 完成时，框架会调用 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象的 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel#onCleared()" target="_blank" rel="noopener"><code>onCleared()</code></a> 方法，以便它可以清理资源。</p>
<blockquote>
<p><strong>注意</strong>：<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 绝不能引用视图、<a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 或可能存储对 Activity 上下文的引用的任何类。</p>
</blockquote>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象存在的时间比视图或 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwners</code></a> 的特定实例存在的时间更长。这还意味着，您可以更轻松地编写涵盖 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 的测试，因为它不了解视图和 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 对象。<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象可以包含 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver" target="_blank" rel="noopener"><code>LifecycleObservers</code></a>，如 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象。但是，<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象绝不能观察对生命周期感知型可观察对象（如 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象）的更改。 如果 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 需要 <code>Application</code> 上下文（例如，为了查找系统服务），它可以扩展 <a href="https://developer.android.com/reference/androidx/lifecycle/AndroidViewModel" target="_blank" rel="noopener"><code>AndroidViewModel</code></a> 类并设置用于接收 <code>Application</code> 的构造函数，因为 <code>Application</code> 类会扩展 <code>Context</code>。</p>
<h3 id="viewmodel的生命周期"><a class="markdownIt-Anchor" href="#viewmodel的生命周期"></a> ViewModel的生命周期</h3>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象存在的时间范围是获取 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 时传递给 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModelProvider" target="_blank" rel="noopener"><code>ViewModelProvider</code></a> 的 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a>。<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 将一直留在内存中，直到限定其存在时间范围的 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 永久消失：对于 Activity，是在 Activity 完成时；而对于 Fragment，是在 Fragment 分离时。</p>
<p>下图说明了 Activity 经历屏幕旋转而后结束的过程中所处的各种生命周期状态。该图还在关联的 Activity 生命周期的旁边显示了 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 的生命周期。此图表说明了 Activity 的各种状态。这些基本状态同样适用于 Fragment 的生命周期。</p>
<p><img src="/Users/liubo/Desktop/%E7%AC%94%E8%AE%B0/Jetpack/viewmodel-lifecycle.png" alt="viewmodel-lifecycle" /></p>
<p>通常在系统首次调用 Activity 对象的 onCreate() 方法时请求 ViewModel。系统可能会在 Activity 的整个生命周期内多次调用 onCreate()，如在旋转设备屏幕时。ViewModel 存在的时间范围是从首次请求 ViewModel 直到 Activity 完成并销毁。</p>
<h3 id="在fragment之间共享数据"><a class="markdownIt-Anchor" href="#在fragment之间共享数据"></a> 在Fragment之间共享数据</h3>
<blockquote>
<p>问题背景描述：</p>
<p>Activity 中的两个或更多 Fragment 需要相互通信是一种很常见的情况。想象一下主从 Fragment 的常见情况，假设您有一个 Fragment，在该 Fragment 中，用户从列表中选择一项，还有另一个 Fragment，用于显示选定项的内容。这种情况不太容易处理，因为这两个 Fragment 都需要定义某种接口描述，并且所有者 Activity 必须将两者绑定在一起。此外，这两个 Fragment 都必须处理另一个 Fragment 尚未创建或不可见的情况。</p>
</blockquote>
<p>可以使用 ViewModel 对象解决这一常见的难点。这两个 Fragment 可以使用其 Activity 范围共享 ViewModel 来处理此类通信，如以下示例代码所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> selected = MutableLiveData&lt;Item&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">select</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">        selected.value = item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> itemSelector: Selector</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> model: SharedViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        model = activity?.run &#123;</span><br><span class="line">            ViewModelProviders.of(<span class="keyword">this</span>)[SharedViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>]</span></span><br><span class="line">        &#125; ?: <span class="keyword">throw</span> Exception(<span class="string">"Invalid Activity"</span>)</span><br><span class="line">        itemSelector.setOnClickListener &#123; item -&gt;</span><br><span class="line">            <span class="comment">// Update the UI</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> model: SharedViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        model = activity?.run &#123;</span><br><span class="line">            ViewModelProviders.of(<span class="keyword">this</span>)[SharedViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>]</span></span><br><span class="line">        &#125; ?: <span class="keyword">throw</span> Exception(<span class="string">"Invalid Activity"</span>)</span><br><span class="line">        model.selected.observe(<span class="keyword">this</span>, Observer&lt;Item&gt; &#123; item -&gt;</span><br><span class="line">            <span class="comment">// Update the UI</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，这两个 Fragment 都会检索包含它们的 Activity。这样，当这两个 Fragment 各自获取 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModelProvider" target="_blank" rel="noopener"><code>ViewModelProvider</code></a> 时，它们会收到相同的 <code>SharedViewModel</code> 实例（其范围限定为该 Activity）。</p>
</blockquote>
<p>此方法具有以下优势：</p>
<ul>
<li>Activity 不需要执行任何操作，也不需要对此通信有任何了解。</li>
<li>除了 <code>SharedViewModel</code> 约定之外，Fragment 不需要相互了解。如果其中一个 Fragment 消失，另一个 Fragment 将继续照常工作。</li>
<li>每个 Fragment 都有自己的生命周期，而不受另一个 Fragment 的生命周期的影响。如果一个 Fragment 替换另一个 Fragment，界面将继续工作而没有任何问题。</li>
</ul>
<h3 id="将加载器替换为viewmodel"><a class="markdownIt-Anchor" href="#将加载器替换为viewmodel"></a> 将加载器替换为ViewModel</h3>
<p>诸如 <code>CursorLoader</code> 之类的加载器类经常用于使应用界面中的数据与数据库保持同步。您可以将 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 与一些其他类一起使用来替换加载器。使用 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 可将界面控制器与数据加载操作分离，这意味着类之间的强引用更少。</p>
<p>在使用加载器的一种常见方法中，应用可能会使用 <code>CursorLoader</code> 观察数据库的内容。当数据库中的值发生更改时，加载器会自动触发数据的重新加载并更新界面：</p>
<p><img src="/Users/liubo/Desktop/%E7%AC%94%E8%AE%B0/Jetpack/viewmodel-loader.png" alt="viewmodel-loader" /></p>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 与 <a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="noopener">Room</a> 和 <a href="https://developer.android.com/topic/libraries/architecture/livedata" target="_blank" rel="noopener">LiveData</a> 一起使用可替换加载器。<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 确保数据在设备配置更改后仍然存在。<a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="noopener">Room</a> 在数据库发生更改时通知 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a>，<a href="https://developer.android.com/topic/libraries/architecture/livedata" target="_blank" rel="noopener">LiveData</a> 进而使用修订后的数据更新界面。</p>
<p><img src="/Users/liubo/Desktop/%E7%AC%94%E8%AE%B0/Jetpack/viewmodel-replace-loader.png" alt="viewmodel-replace-loader" /></p>
<h3 id="将协程与viewmodel一起使用"><a class="markdownIt-Anchor" href="#将协程与viewmodel一起使用"></a> 将协程与ViewModel一起使用</h3>
<p><code>ViewModel</code> 支持 Kotlin 协程。如需了解详情，请参阅<a href="https://developer.android.com/topic/libraries/architecture/coroutines" target="_blank" rel="noopener">将 Kotlin 协程与 Android 架构组件一起使用</a>。</p>
<h3 id="更多信息"><a class="markdownIt-Anchor" href="#更多信息"></a> 更多信息</h3>
<blockquote>
<p>随着数据变得越来越复杂，您可能会选择使用单独的类加载数据。<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 的用途是封装界面控制器的数据，以使数据在配置更改后仍然存在。有关如何在配置更改后加载、保留和管理数据的信息，请参阅<a href="https://developer.android.com/topic/libraries/architecture/saving-states" target="_blank" rel="noopener">保存界面状态</a>。</p>
<p><a href="https://developer.android.com/topic/libraries/architecture/guide#fetching_data" target="_blank" rel="noopener">Android 应用架构指南</a>建议构建存储区类来处理这些功能。</p>
</blockquote>
<h3 id="其他资源"><a class="markdownIt-Anchor" href="#其他资源"></a> 其他资源</h3>
<h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4>
<ul>
<li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/BasicSample">Android 架构组件基本示例</a></li>
<li><a href="https://github.com/googlesamples/android-sunflower">Sunflower</a>，这是一款园艺应用，展示了使用 Android Jetpack 进行 Android 开发的最佳做法。</li>
</ul>
<h4 id="codelab"><a class="markdownIt-Anchor" href="#codelab"></a> Codelab</h4>
<ul>
<li>带 View 的 Android Room <a href="https://codelabs.developers.google.com/codelabs/android-room-with-a-view" target="_blank" rel="noopener">(Java)</a> <a href="https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin" target="_blank" rel="noopener">(Kotlin)</a></li>
<li><a href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#0" target="_blank" rel="noopener">Android 生命周期感知型组件 Codelab</a></li>
</ul>
<h4 id="博客"><a class="markdownIt-Anchor" href="#博客"></a> 博客</h4>
<ul>
<li><a href="https://medium.com/androiddevelopers/viewmodels-a-simple-example-ed5ac416317e" target="_blank" rel="noopener">ViewModel：简单示例</a></li>
<li><a href="https://medium.com/androiddevelopers/viewmodels-persistence-onsaveinstancestate-restoring-ui-state-and-loaders-fc7cc4a6c090" target="_blank" rel="noopener">ViewModel：持久性、onSaveInstanceState()、恢复界面状态和加载器</a></li>
<li><a href="https://medium.com/androiddevelopers/viewmodels-and-livedata-patterns-antipatterns-21efaef74a54" target="_blank" rel="noopener">ViewModel 和 LiveData：模式 + 反模式</a></li>
<li><a href="https://medium.com/androiddevelopers/kotlin-demystified-understanding-shorthand-lamba-syntax-74724028dcc5" target="_blank" rel="noopener">Kotlin 揭秘：理解速记 Lambda 语法</a></li>
<li><a href="https://medium.com/androiddevelopers/kotlin-demystified-scope-functions-57ca522895b1" target="_blank" rel="noopener">Kotlin 揭秘：范围函数</a></li>
<li><a href="https://medium.com/androiddevelopers/kotlin-demystified-when-to-use-custom-accessors-939a6e998899" target="_blank" rel="noopener">Kotlin 揭秘：何时使用自定义访问器</a></li>
<li><a href="https://medium.com/google-developers/lifecycle-aware-data-loading-with-android-architecture-components-f95484159de4" target="_blank" rel="noopener">使用架构组件加载生命周期感知数据</a></li>
</ul>
<h4 id="视频"><a class="markdownIt-Anchor" href="#视频"></a> 视频</h4>
<ul>
<li>[Android Jetpack：ViewModel](</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/8-Room%E6%8C%81%E4%B9%85%E6%80%A7%E5%BA%93/">8-Room持久性库</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JetPack/">JetPack</a></span><div class="content"><h2 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h2>
<p>Room 在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。</p>
<p>Room 包含 3 个主要组件：</p>
<ul>
<li>
<p><a href="https://developer.android.com/reference/androidx/room/Database" target="_blank" rel="noopener"><strong>数据库</strong></a>：包含数据库持有者，并作为应用已保留的持久关系型数据的底层连接的主要接入点。</p>
<p>使用 <a href="https://developer.android.com/reference/androidx/room/Database" target="_blank" rel="noopener"><code>@Database</code></a> 注释的类应满足以下条件：</p>
<ul>
<li>是扩展 <a href="https://developer.android.com/reference/androidx/room/RoomDatabase" target="_blank" rel="noopener"><code>RoomDatabase</code></a> 的抽象类。</li>
<li>在注释中添加与数据库关联的实体列表。</li>
<li>包含具有 0 个参数且返回使用 <a href="https://developer.android.com/reference/androidx/room/Dao" target="_blank" rel="noopener"><code>@Dao</code></a> 注释的类的抽象方法。</li>
</ul>
<p>在运行时，您可以通过调用 [<code>Room.databaseBuilder()</code>](<a href="https://developer.android.com/reference/androidx/room/Room#databaseBuilder" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/room/Room#databaseBuilder</a>(android.content.Context, java.lang.Class, java.lang.String)) 或 [<code>Room.inMemoryDatabaseBuilder()</code>](<a href="https://developer.android.com/reference/androidx/room/Room#inMemoryDatabaseBuilder" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/room/Room#inMemoryDatabaseBuilder</a>(android.content.Context, java.lang.Class)) 获取 <a href="https://developer.android.com/reference/androidx/room/Database" target="_blank" rel="noopener"><code>Database</code></a> 的实例。</p>
</li>
<li>
<p><a href="https://developer.android.com/training/data-storage/room/defining-data" target="_blank" rel="noopener"><strong>Entity</strong></a>：表示数据库中的表。</p>
</li>
<li>
<p><a href="https://developer.android.com/training/data-storage/room/accessing-data" target="_blank" rel="noopener"><strong>DAO</strong></a>：包含用于访问数据库的方法。</p>
</li>
</ul>
<p>Room架构图如下所示：</p>
<p><img src="/Users/liubo/Desktop/%E7%AC%94%E8%AE%B0/Jetpack/room_architecture.png" alt="room_architecture" /></p>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
<blockquote>
<p>以下代码段包含具有一个实体和一个 DAO 的示例数据库配置。</p>
</blockquote>
<p>User</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> uid: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"first_name"</span>)</span> <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"last_name"</span>)</span> <span class="keyword">val</span> lastName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>UserDao</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAll</span><span class="params">()</span></span>: List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user WHERE uid IN (:userIds)"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadAllByIds</span><span class="params">(userIds: <span class="type">IntArray</span>)</span></span>: List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user WHERE first_name LIKE :first AND "</span> +</span></span><br><span class="line"><span class="meta">           <span class="meta-string">"last_name LIKE :last LIMIT 1"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findByName</span><span class="params">(first: <span class="type">String</span>, last: <span class="type">String</span>)</span></span>: User</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertAll</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AppDatabase</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database(entities = arrayOf(User::class)</span>, version = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">userDao</span><span class="params">()</span></span>: UserDao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取数据库实例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> db = Room.databaseBuilder(</span><br><span class="line">            applicationContext,</span><br><span class="line">            AppDatabase::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">"database-name"</span></span></span><br><span class="line">        ).build()</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：如果您的应用在单个进程中运行，则在实例化 <code>AppDatabase</code> 对象时应遵循单例设计模式。每个 <a href="https://developer.android.com/reference/androidx/room/RoomDatabase" target="_blank" rel="noopener"><code>RoomDatabase</code></a> 实例的成本相当高，而您几乎不需要在单个进程中访问多个实例。</p>
<p>如果您的应用在多个进程中运行，请在数据库构建器调用中包含 <code>enableMultiInstanceInvalidation()</code>。这样，如果您在每个进程中都有一个 <code>AppDatabase</code> 实例，就可以在一个进程中使共享数据库文件失效，并且这种失效会自动传播到其他进程中的 <code>AppDatabase</code> 实例。</p>
<h3 id="声明依赖项"><a class="markdownIt-Anchor" href="#声明依赖项"></a> 声明依赖项</h3>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> room_version = <span class="string">"2.2.3"</span></span><br><span class="line"></span><br><span class="line">  implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">  annotationProcessor <span class="string">"androidx.room:room-compiler:$room_version"</span> <span class="comment">// For Kotlin use kapt instead of annotationProcessor</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Kotlin Extensions and Coroutines support for Room</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-ktx:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - RxJava support for Room</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-guava:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test helpers</span></span><br><span class="line">  testImplementation <span class="string">"androidx.room:room-testing:$room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置编译器选项"><a class="markdownIt-Anchor" href="#配置编译器选项"></a> 配置编译器选项</h3>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> room_version = <span class="string">"2.2.3"</span></span><br><span class="line"></span><br><span class="line">  implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">  annotationProcessor <span class="string">"androidx.room:room-compiler:$room_version"</span> <span class="comment">// For Kotlin use kapt instead of annotationProcessor</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Kotlin Extensions and Coroutines support for Room</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-ktx:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - RxJava support for Room</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-guava:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test helpers</span></span><br><span class="line">  testImplementation <span class="string">"androidx.room:room-testing:$room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下代码段举例说明了如何配置这些选项：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [</span><br><span class="line">                    <span class="string">"room.schemaLocation"</span>:<span class="string">"$projectDir/schemas"</span>.toString(),</span><br><span class="line">                    <span class="string">"room.incremental"</span>:<span class="string">"true"</span>,</span><br><span class="line">                    <span class="string">"room.expandProjection"</span>:<span class="string">"true"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用实体定义数据"><a class="markdownIt-Anchor" href="#使用实体定义数据"></a> 使用实体定义数据</h2>
<p>以下代码段展示了如何定义实体：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">var</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">var</span> firstName: String?,</span><br><span class="line">    <span class="keyword">var</span> lastName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要保留某个字段，Room 必须拥有该字段的访问权限。您可以将某个字段设为公开字段，也可以为其提供 getter 和 setter。如果您使用 getter 和 setter 方法，则请注意，这些方法需遵循 Room 中的 JavaBeans 规范。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：实体可以具有空的构造函数（如果相应的 <a href="https://developer.android.com/training/data-storage/room/accessing-data" target="_blank" rel="noopener">DAO</a> 类可以访问保留的每个字段），也可以具有其参数包含的类型和名称与该实体中字段的类型和名称一致的构造函数。Room 还可以使用完整或部分构造函数，例如仅接收部分字段的构造函数。</p>
</blockquote>
<h3 id="使用主键"><a class="markdownIt-Anchor" href="#使用主键"></a> 使用主键</h3>
<p>每个实体必须将至少 1 个字段定义为主键。即使只有 1 个字段，您仍然需要为该字段添加 <a href="https://developer.android.com/reference/androidx/room/PrimaryKey" target="_blank" rel="noopener"><code>@PrimaryKey</code></a> 注释。此外，如果您想让 Room 为实体分配自动 ID，则可以设置 <code>@PrimaryKey</code> 的 <a href="https://developer.android.com/reference/androidx/room/PrimaryKey#autoGenerate()" target="_blank" rel="noopener"><code>autoGenerate</code></a> 属性。如果实体具有复合主键，您可以使用 <a href="https://developer.android.com/reference/androidx/room/Entity" target="_blank" rel="noopener"><code>@Entity</code></a> 注释的 <a href="https://developer.android.com/reference/androidx/room/Entity#primaryKeys()" target="_blank" rel="noopener"><code>primaryKeys</code></a> 属性，如</p>
<p>以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(primaryKeys = arrayOf(<span class="meta-string">"firstName"</span>, <span class="meta-string">"lastName"</span>)</span>)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="keyword">val</span> lastName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>默认情况下，Room 将类名称用作数据库表名称。如果您希望表具有不同的名称，请设置 <a href="https://developer.android.com/reference/androidx/room/Entity" target="_blank" rel="noopener"><code>@Entity</code></a> 注释的 <a href="https://developer.android.com/reference/androidx/room/Entity#tableName()" target="_blank" rel="noopener"><code>tableName</code></a> 属性，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">"users"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：SQLite 中的表名称不区分大小写。</p>
</blockquote>
<p>与 <a href="https://developer.android.com/reference/androidx/room/Entity#tableName()" target="_blank" rel="noopener"><code>tableName</code></a> 属性类似，Room 将字段名称用作数据库中的列名称。如果您希望列具有不同的名称，请将 <a href="https://developer.android.com/reference/androidx/room/ColumnInfo" target="_blank" rel="noopener"><code>@ColumnInfo</code></a> 注释添加到字段，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">"users"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"first_name"</span>)</span> <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"last_name"</span>)</span> <span class="keyword">val</span> lastName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="忽略字段"><a class="markdownIt-Anchor" href="#忽略字段"></a> 忽略字段</h3>
<p>默认情况下，Room 会为在实体中定义的每个字段创建一个列。如果某个实体中有您不想保留的字段，则可以使用 <a href="https://developer.android.com/reference/androidx/room/Ignore" target="_blank" rel="noopener"><code>@Ignore</code></a> 为这些字段注释，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="keyword">val</span> lastName: String?,</span><br><span class="line">    <span class="meta">@Ignore</span> <span class="keyword">val</span> picture: Bitmap?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果实体继承了父实体的字段，则使用 <code>@Entity</code> 属性的 <a href="https://developer.android.com/reference/androidx/room/Entity#ignoredcolumns" target="_blank" rel="noopener"><code>ignoredColumns</code></a> 属性通常会更容易：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> picture: Bitmap? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity(ignoredColumns = arrayOf(<span class="meta-string">"picture"</span>)</span>)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteUser</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> hasVpn: <span class="built_in">Boolean</span></span><br><span class="line">) : User()</span><br></pre></td></tr></table></figure>
<h3 id="提供表搜索支持"><a class="markdownIt-Anchor" href="#提供表搜索支持"></a> 提供表搜索支持</h3>
<blockquote>
<p>Room 支持多种类型的注释，可让您更轻松地搜索数据库表中的详细信息。</p>
<p>除非应用的 <code>minSdkVersion</code> 低于 16，否则请使用全文搜索。</p>
</blockquote>
<h4 id="支持全文搜索ftsfull-text-search"><a class="markdownIt-Anchor" href="#支持全文搜索ftsfull-text-search"></a> 支持全文搜索(FTS：Full-text Search)</h4>
<p>如果您的应用需要通过全文搜索 (FTS) 快速访问数据库信息，请使用虚拟表（使用 FTS3 或 FTS4 SQLite 扩展模块）为您的实体提供支持。要使用 Room 2.1.0 及更高版本中提供的这项功能，请将 @Fts3 或 @Fts4 注释添加到给定实体，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use `@Fts3` only if your app has strict disk space requirements or if you</span></span><br><span class="line"><span class="comment">// require compatibility with an older SQLite version.</span></span><br><span class="line"><span class="meta">@Fts4</span></span><br><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">"users"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="comment">/* Specifying a primary key for an FTS-table-backed entity is optional, but</span></span><br><span class="line"><span class="comment">       if you include one, it must use this type and column name. */</span></span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="meta">@ColumnInfo(name = <span class="meta-string">"rowid"</span>)</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"first_name"</span>)</span> <span class="keyword">val</span> firstName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：启用 FTS 的表始终使用 <code>INTEGER</code> 类型的主键且列名称为“rowid”。如果是由 FTS 表支持的实体定义主键，则<strong>必须</strong>使用相应的类型和列名称。</p>
<p>如果表支持以多种语言显示的内容，请使用 <code>languageId</code> 选项指定用于存储每一行语言信息的列：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Fts4(languageId = <span class="meta-string">"lid"</span>)</span></span><br><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">"users"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"lid"</span>)</span> <span class="keyword">val</span> languageId: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Room 提供了其他几个选项来定义由 FTS 支持的实体，包括结果排序、令牌生成器类型以及作为外部内容管理的表。如需详细了解这些选项，请参阅 <a href="https://developer.android.com/reference/androidx/room/FtsOptions" target="_blank" rel="noopener"><code>FtsOptions</code></a> 参考。</p>
</blockquote>
<h4 id="将特定列编入索引"><a class="markdownIt-Anchor" href="#将特定列编入索引"></a> 将特定列编入索引</h4>
<p>如果您的应用必须支持不允许使用由 FTS3 或 FTS4 表支持的实体的 SDK 版本，您仍可以将数据库中的某些列编入索引，以加快查询速度。要为实体添加索引，请在 <a href="https://developer.android.com/reference/androidx/room/Entity" target="_blank" rel="noopener"><code>@Entity</code></a> 注释中添加 <a href="https://developer.android.com/reference/androidx/room/Entity#indices()" target="_blank" rel="noopener"><code>indices</code></a> 属性，以列出要在索引或复合索引中包含的列的名称。</p>
<p>以下代码段演示了此注释过程：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(indices = arrayOf(Index(value = [<span class="meta-string">"last_name"</span>, <span class="meta-string">"address"</span>])</span>))</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="keyword">val</span> address: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"last_name"</span>)</span> <span class="keyword">val</span> lastName: String?,</span><br><span class="line">    <span class="meta">@Ignore</span> <span class="keyword">val</span> picture: Bitmap?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>有时，数据库中的某些字段或字段组必须是唯一的。您可以通过将 <a href="https://developer.android.com/reference/androidx/room" target="_blank" rel="noopener"><code>@Index</code></a> 注释的 <a href="https://developer.android.com/reference/androidx/room#unique()" target="_blank" rel="noopener"><code>unique</code></a> 属性设为 <code>true</code> 来强制实施此唯一性属性。</p>
<p>以下代码示例可防止表格具有包含 <code>firstName</code> 和 <code>lastName</code> 列的同一组值的两行：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(indices = arrayOf(Index(value = [<span class="meta-string">"first_name"</span>, <span class="meta-string">"last_name"</span>],</span></span><br><span class="line"><span class="meta">        unique = true)</span>))</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"first_name"</span>)</span> <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"last_name"</span>)</span> <span class="keyword">val</span> lastName: String?,</span><br><span class="line">    <span class="meta">@Ignore</span> <span class="keyword">var</span> picture: Bitmap?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="添加基于autovalue的对象"><a class="markdownIt-Anchor" href="#添加基于autovalue的对象"></a> 添加基于AutoValue的对象</h3>
<blockquote>
<p>此功能旨在用于基于 Java 的实体。要在基于 Kotlin 的实体中实现相同的功能，最好改用<a href="https://kotlinlang.org/docs/reference/data-classes.html" target="_blank" rel="noopener">数据类</a>。</p>
</blockquote>
<p>在 Room 2.1.0 及更高版本中，您可以将基于 Java 的<a href="https://github.com/google/auto/blob/master/value/userguide/index.md">不可变值类</a>（使用 <code>@AutoValue</code> 为其注释）用作应用的数据库中的实体。此支持在实体的两个实例被视为相等（如果这两个实例的列包含相同的值）时尤为有用。</p>
<p>将带有 <code>@AutoValue</code> 注释的类用作实体时，您可以使用 <code>@PrimaryKey</code>、<code>@ColumnInfo</code>、<code>@Embedded</code> 和 <code>@Relation</code> 为类的抽象方法注释。不过，您必须在每次使用这些注释时添加 <code>@CopyAnnotations</code> 注释，以便 Room 可以正确解释这些方法的自动生成实现。</p>
<p>以下代码段展示了一个使用 <code>@AutoValue</code> 注释的类（Room 将其标识为实体）的示例：</p>
<p>User.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoValue</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Supported annotations must include `@CopyAnnotations`.</span></span><br><span class="line">    <span class="meta">@CopyAnnotations</span></span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getFirstName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getLastName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Room uses this factory method to create User objects.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">create</span><span class="params">(<span class="keyword">long</span> id, String firstName, String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoValue_User(id, firstName, lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义对象之间的关系"><a class="markdownIt-Anchor" href="#定义对象之间的关系"></a> 定义对象之间的关系</h2>
<blockquote>
<p>由于 SQLite 是关系型数据库，因此您可以指定各个对象之间的关系。尽管大多数对象关系映射库都允许实体对象互相引用，但 Room 明确禁止这样做</p>
</blockquote>
<h3 id="定义一对多关系"><a class="markdownIt-Anchor" href="#定义一对多关系"></a> 定义一对多关系</h3>
<p>即使您不能使用直接关系，Room 仍允许您定义实体之间的外键约束。</p>
<p>例如，如果存在另一个名为 <code>Book</code> 的实体，您可以使用 <a href="https://developer.android.com/reference/androidx/room/ForeignKey" target="_blank" rel="noopener"><code>@ForeignKey</code></a> 注释定义该实体与 <code>User</code> 实体的关系，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(foreignKeys = arrayOf(ForeignKey(</span></span><br><span class="line"><span class="meta">            entity = User::class,</span></span><br><span class="line"><span class="meta">            parentColumns = arrayOf(<span class="meta-string">"id"</span>)</span>,</span><br><span class="line">            childColumns = arrayOf(<span class="string">"user_id"</span>))</span><br><span class="line">       )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> bookId: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> title: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"user_id"</span>)</span> <span class="keyword">val</span> userId: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>由于零个或更多个 <code>Book</code> 实例可以通过 <code>user_id</code> 外键关联到一个 <code>User</code> 实例，因此这会在 <code>User</code> 和 <code>Book</code> 之间构建一对多关系模型。</p>
<p>外键非常强大，可让您指定引用的实体更新后会发生什么。例如，您可以通过在 <a href="https://developer.android.com/reference/androidx/room/ForeignKey" target="_blank" rel="noopener"><code>@ForeignKey</code></a> 注释中添加 <a href="https://developer.android.com/reference/androidx/room/ForeignKey#onDelete()" target="_blank" rel="noopener"><code>onDelete = CASCADE</code></a>，在 <code>User</code> 的对应实例删除后告知 SQLite 删除该用户的所有图书。</p>
<blockquote>
<p><strong>注意</strong>：SQLite 将 <a href="https://developer.android.com/reference/androidx/room/OnConflictStrategy#REPLACE" target="_blank" rel="noopener"><code>@Insert(onConflict = REPLACE)</code></a> 作为一组 <code>REMOVE</code> 和 <code>REPLACE</code> 操作（而不是单个 <code>UPDATE</code> 操作）处理。这种替换冲突值的方法可能会影响您的外键约束。如需了解详情，请参阅有关 <code>ON_CONFLICT</code> 子句的 <a href="https://sqlite.org/lang_conflict.html" target="_blank" rel="noopener">SQLite 文档</a>。</p>
</blockquote>
<h3 id="创建嵌套对象"><a class="markdownIt-Anchor" href="#创建嵌套对象"></a> 创建嵌套对象</h3>
<p>有时，您可能希望在数据库逻辑中将某个实体或数据对象表示为一个紧密的整体，即使该对象包含多个字段也是如此。在这些情况下，您可以使用 <a href="https://developer.android.com/reference/androidx/room/Embedded" target="_blank" rel="noopener"><code>@Embedded</code></a> 注释表示要解构到表中其子字段的对象。然后，您可以像查询其他各个列一样查询嵌套字段。</p>
<p>例如，您的 <code>User</code> 类可以包含类型 <code>Address</code> 的字段，该类型表示一组分别名为 <code>street</code>、<code>city</code>、<code>state</code> 和 <code>postCode</code> 的字段。要在表中单独存储组成的列，请在 <code>User</code> 类（使用 <a href="https://developer.android.com/reference/androidx/room/Embedded" target="_blank" rel="noopener"><code>@Embedded</code></a> 注释）中添加 <code>Address</code> 字段，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>(</span><br><span class="line">    <span class="keyword">val</span> street: String?,</span><br><span class="line">    <span class="keyword">val</span> state: String?,</span><br><span class="line">    <span class="keyword">val</span> city: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"post_code"</span>)</span> <span class="keyword">val</span> postCode: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="meta">@Embedded</span> <span class="keyword">val</span> address: Address?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>然后，表示 <code>User</code> 对象的表会包含具有以下名称的列：<code>id</code>、<code>firstName</code>、<code>street</code>、<code>state</code>、<code>city</code> 和 <code>post_code</code>。</p>
<blockquote>
<p><strong>注意</strong>：嵌套字段还可以包含其他嵌套字段。</p>
</blockquote>
<p>如果某个实体具有同一类型的多个嵌套字段，您可以通过设置 <a href="https://developer.android.com/reference/androidx/room/Embedded#prefix()" target="_blank" rel="noopener"><code>prefix</code></a> 属性确保每个列都独一无二。然后，Room 会将提供的值添加到嵌套对象中每个列名称的开头。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Embedded(prefix = <span class="meta-string">"loc_"</span>)</span></span><br><span class="line"> Coordinates coordinates;</span><br></pre></td></tr></table></figure>
<h3 id="定义多对多关系"><a class="markdownIt-Anchor" href="#定义多对多关系"></a> 定义多对多关系</h3>
<p>您通常希望在关系型数据库中构建的另一种关系模型是两个实体之间的多对多关系，其中每个实体都可以关联到另一个实体的零个或更多个实例。</p>
<p>例如，假设有一个音乐在线播放应用，用户可以在该应用中将自己喜爱的歌曲整理到播放列表中。每个播放列表都可以包含任意数量的歌曲，每首歌曲都可以包含在任意数量的播放列表中。</p>
<p>要构建这种关系的模型，您需要创建下面三个对象：</p>
<ol>
<li>播放列表的实体类。</li>
<li>歌曲的实体类。</li>
<li>用于保存每个播放列表中的歌曲相关信息的中间类。</li>
</ol>
<p>您可以将实体类定义为独立单元：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Playlist</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">var</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> name: String?,</span><br><span class="line">    <span class="keyword">val</span> description: String?</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Song</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">var</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> songName: String?,</span><br><span class="line">    <span class="keyword">val</span> artistName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>然后，将中间类定义为包含对 <code>Song</code> 和 <code>Playlist</code> 的外键引用的实体：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">"playlist_song_join"</span>,</span></span><br><span class="line"><span class="meta">        primaryKeys = arrayOf(<span class="meta-string">"playlistId"</span>,<span class="meta-string">"songId"</span>)</span>,</span><br><span class="line">        foreignKeys = arrayOf(</span><br><span class="line">                         ForeignKey(entity = Playlist::<span class="class"><span class="keyword">class</span>,<span class="type"></span></span></span><br><span class="line">                                    parentColumns = arrayOf(<span class="string">"id"</span>),</span><br><span class="line">                                    childColumns = arrayOf(<span class="string">"playlistId"</span>)),</span><br><span class="line">                         ForeignKey(entity = Song::<span class="class"><span class="keyword">class</span>,<span class="type"></span></span></span><br><span class="line">                                    parentColumns = arrayOf(<span class="string">"id"</span>),</span><br><span class="line">                                    childColumns = arrayOf(<span class="string">"songId"</span>))</span><br><span class="line">                              )</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaylistSongJoin</span></span>(</span><br><span class="line">    <span class="keyword">val</span> playlistId: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> songId: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这会生成一个多对多关系模型。借助该模型，您可以使用 DAO 按歌曲查询播放列表和按播放列表查询歌曲：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PlaylistSongJoinDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(playlistSongJoin: <span class="type">PlaylistSongJoin</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"""</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           SELECT * FROM playlist</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           INNER JOIN playlist_song_join</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           ON playlist.id=playlist_song_join.playlistId</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           WHERE playlist_song_join.songId=:songId</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           """</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPlaylistsForSong</span><span class="params">(songId: <span class="type">Int</span>)</span></span>: Array&lt;Playlist&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"""</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           SELECT * FROM song</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           INNER JOIN playlist_song_join</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           ON song.id=playlist_song_join.songId</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           WHERE playlist_song_join.playlistId=:playlistId</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           """</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getSongsForPlaylist</span><span class="params">(playlistId: <span class="type">Int</span>)</span></span>: Array&lt;Song&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在数据库中创建视图"><a class="markdownIt-Anchor" href="#在数据库中创建视图"></a> 在数据库中创建视图</h2>
<blockquote>
<p>2.1.0 及更高版本的 <a href="https://developer.android.com/training/data-storage/room" target="_blank" rel="noopener">Room 持久性库</a>为 <a href="https://www.sqlite.org/lang_createview.html" target="_blank" rel="noopener">SQLite 数据库视图</a>提供了支持，从而允许您将查询封装到类中。Room 将这些查询支持的类称为视图，在 <a href="https://developer.android.com/training/data-storage/room/accessing-data" target="_blank" rel="noopener">DAO</a> 中使用时，它们的行为与简单数据对象的行为相同。</p>
<p><strong>注意</strong>：与<a href="https://developer.android.com/training/data-storage/room/defining-data" target="_blank" rel="noopener">实体</a>类似，您可以针对视图运行 <code>SELECT</code> 语句。不过，您无法针对视图运行 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 语句。</p>
</blockquote>
<h3 id="创建视图"><a class="markdownIt-Anchor" href="#创建视图"></a> 创建视图</h3>
<p>要创建视图，请将 <a href="https://developer.android.com/reference/androidx/room/DatabaseView" target="_blank" rel="noopener"><code>@DatabaseView</code></a> 注释添加到类中。将注释的值设为类应该表示的查询。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DatabaseView(<span class="meta-string">"SELECT user.id, user.name, user.departmentId,"</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"department.name AS departmentName FROM user "</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"INNER JOIN department ON user.departmentId = department.id"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetail</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="keyword">val</span> name: String?,</span><br><span class="line">    <span class="keyword">val</span> departmentId: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="keyword">val</span> departmentName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="将视图与数据库相关联"><a class="markdownIt-Anchor" href="#将视图与数据库相关联"></a> 将视图与数据库相关联</h3>
<p>要将此视图添加为应用数据库的一部分，请在应用的 <code>@Database</code> 注释中添加 <a href="https://developer.android.com/reference/androidx/room/Database#views" target="_blank" rel="noopener"><code>views</code></a> 属性：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database(entities = arrayOf(User::class)</span>,</span><br><span class="line">          views = arrayOf(UserDetail::<span class="class"><span class="keyword">class</span>), <span class="type">version = 1)</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">userDao</span><span class="params">()</span></span>: UserDao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用dao访问数据"><a class="markdownIt-Anchor" href="#使用dao访问数据"></a> 使用DAO访问数据</h2>
<blockquote>
<p>要使用 <a href="https://developer.android.com/training/data-storage/room" target="_blank" rel="noopener">Room 持久性库</a>访问应用的数据，您需要使用数据访问对象 (DAO)。这些 <a href="https://developer.android.com/reference/androidx/room/Dao" target="_blank" rel="noopener"><code>Dao</code></a> 对象构成了 Room 的主要组件，因为每个 DAO 都包含一些方法，这些方法提供对应用数据库的抽象访问权限。</p>
</blockquote>
<blockquote>
<p>DAO 既可以是接口，也可以是抽象类。如果是抽象类，则该 DAO 可以选择有一个以 <a href="https://developer.android.com/reference/androidx/room/RoomDatabase" target="_blank" rel="noopener"><code>RoomDatabase</code></a> 为唯一参数的构造函数。Room 会在编译时创建每个 DAO 实现。</p>
<p><strong>注意</strong>：除非您对构建器调用 <a href="https://developer.android.com/reference/androidx/room/RoomDatabase.Builder#allowMainThreadQueries()" target="_blank" rel="noopener"><code>allowMainThreadQueries()</code></a>，否则 Room 不支持在主线程上访问数据库，因为它可能会长时间锁定界面。异步查询（返回 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 或 <a href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html" target="_blank" rel="noopener"><code>Flowable</code></a> 实例的查询）无需遵守此规则，因为此类查询会根据需要在后台线程上异步运行查询。</p>
</blockquote>
<h3 id="自定义方法"><a class="markdownIt-Anchor" href="#自定义方法"></a> 自定义方法</h3>
<h4 id="insert"><a class="markdownIt-Anchor" href="#insert"></a> Insert</h4>
<p>当您创建 DAO 方法并使用 <a href="https://developer.android.com/reference/androidx/room/Insert" target="_blank" rel="noopener"><code>@Insert</code></a> 对其进行注释时，Room 会生成一个实现，该实现在单个事务中将所有参数插入到数据库中。</p>
<p>以下代码段展示了几个示例查询：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertBothUsers</span><span class="params">(user1: <span class="type">User</span>, user2: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertUsersAndFriends</span><span class="params">(user: <span class="type">User</span>, friends: <span class="type">List</span>&lt;<span class="type">User</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <a href="https://developer.android.com/reference/androidx/room/Insert" target="_blank" rel="noopener"><code>@Insert</code></a> 方法只接收 1 个参数，则可返回 <code>long</code>，这是插入项的新 <code>rowId</code>。如果参数是数组或集合，则应返回 <code>long[]</code> 或 <code>List</code>。</p>
<blockquote>
<p>如需了解详情，请参阅 <a href="https://developer.android.com/reference/androidx/room/Insert" target="_blank" rel="noopener"><code>@Insert</code></a> 注释的参考文档以及 <a href="https://www.sqlite.org/rowidtable.html" target="_blank" rel="noopener">rowid 表格的 SQLite 文档</a>。</p>
</blockquote>
<h4 id="update"><a class="markdownIt-Anchor" href="#update"></a> Update</h4>
<p><a href="https://developer.android.com/reference/androidx/room/Update" target="_blank" rel="noopener"><code>Update</code></a> 便捷方法会修改数据库中以参数形式给出的一组实体。它使用与每个实体的主键匹配的查询。</p>
<p>以下代码段演示了如何定义此方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然通常没有必要，但您可以让此方法返回一个 <code>int</code> 值，表示数据库中更新的行数</p>
</blockquote>
<h4 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> Delete</h4>
<p><a href="https://developer.android.com/reference/androidx/room/Delete" target="_blank" rel="noopener"><code>Delete</code></a> 便捷方法会从数据库中删除一组以参数形式给出的实体。它使用主键查找要删除的实体。</p>
<p>以下代码段演示了如何定义此方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然通常没有必要，但您可以让此方法返回一个 <code>int</code> 值，表示从数据库中删除的行数。</p>
</blockquote>
<h3 id="查询信息"><a class="markdownIt-Anchor" href="#查询信息"></a> 查询信息</h3>
<blockquote>
<p><a href="https://developer.android.com/reference/androidx/room/Query" target="_blank" rel="noopener"><code>@Query</code></a> 是 DAO 类中使用的主要注释。它允许您对数据库执行读/写操作。每个 <a href="https://developer.android.com/reference/androidx/room/Query" target="_blank" rel="noopener"><code>@Query</code></a> 方法都会在编译时进行验证，因此如果查询出现问题，则会发生编译错误，而不是运行时失败。</p>
<p>Room 还会验证查询的返回值，这样的话，当返回的对象中的字段名称与查询响应中的对应列名称不匹配时，Room 会通过以下两种方式之一提醒您：</p>
<ul>
<li>
<p>如果只有部分字段名称匹配，则会发出警告。</p>
</li>
<li>
<p>如果没有任何字段名称匹配，则会发出错误。</p>
</li>
</ul>
</blockquote>
<h4 id="简单查询"><a class="markdownIt-Anchor" href="#简单查询"></a> 简单查询</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadAllUsers</span><span class="params">()</span></span>: Array&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是一个极其简单的查询，可加载所有用户。在编译时，Room 知道它在查询用户表中的所有列。如果查询包含语法错误，或者数据库中没有用户表格，则 Room 会在您的应用编译时显示包含相应消息的错误。</p>
</blockquote>
<h4 id="将参数传递给查询"><a class="markdownIt-Anchor" href="#将参数传递给查询"></a> 将参数传递给查询</h4>
<p>在大多数情况下，您需要将参数传递给查询以执行过滤操作，例如仅显示某个年龄以上的用户。要完成此任务，请在 Room 注释中使用方法参数，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user WHERE age &gt; :minAge"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadAllUsersOlderThan</span><span class="params">(minAge: <span class="type">Int</span>)</span></span>: Array&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在编译时处理此查询时，Room 会将 <code>:minAge</code> 绑定参数与 <code>minAge</code> 方法参数相匹配。Room 通过参数名称进行匹配。如果有不匹配的情况，则应用编译时会出现错误。</p>
</blockquote>
<p>您还可以在查询中传递多个参数或多次引用这些参数，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadAllUsersBetweenAges</span><span class="params">(minAge: <span class="type">Int</span>, maxAge: <span class="type">Int</span>)</span></span>: Array&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user WHERE first_name LIKE :search "</span> +</span></span><br><span class="line"><span class="meta">           <span class="meta-string">"OR last_name LIKE :search"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findUserWithName</span><span class="params">(search: <span class="type">String</span>)</span></span>: List&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回列的子集"><a class="markdownIt-Anchor" href="#返回列的子集"></a> 返回列的子集</h4>
<p>大多数情况下，您只需获取实体的几个字段。例如，您的界面可能仅显示用户的名字和姓氏，而不是用户的每一条详细信息。通过仅提取应用界面中显示的列，您可以节省宝贵的资源，并且您的查询也能更快完成。</p>
<p>借助 Room，您可以从查询中返回任何基于 Java 的对象，前提是结果列集合会映射到返回的对象。例如，您可以创建以下基于 Java 的普通对象 (POJO) 来获取用户的名字和姓氏：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">NameTuple</span></span>(</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"first_name"</span>)</span> <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"last_name"</span>)</span> <span class="keyword">val</span> lastName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>现在，您可以在查询方法中使用此 POJO：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT first_name, last_name FROM user"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadFullName</span><span class="params">()</span></span>: List&lt;NameTuple&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Room 知道该查询会返回 <code>first_name</code> 和 <code>last_name</code> 列的值，并且这些值会映射到 <code>NameTuple</code> 类的字段。因此，Room 可以生成正确的代码。如果查询返回太多的列，或者返回 <code>NameTuple</code> 类中不存在的列，则 Room 会显示一条警告。</p>
<blockquote>
<p><strong>注意</strong>：这些 POJO 也可以使用 <a href="https://developer.android.com/reference/androidx/room/Embedded" target="_blank" rel="noopener"><code>@Embedded</code></a> 注释。</p>
</blockquote>
<h4 id="传递参数的集合"><a class="markdownIt-Anchor" href="#传递参数的集合"></a> 传递参数的集合</h4>
<p>部分查询可能要求您传入数量不定的参数，参数的确切数量要到运行时才知道。例如，您可能希望从部分区域中检索所有用户的相关信息。Room 知道参数何时表示集合，并根据提供的参数数量在运行时自动将其展开。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT first_name, last_name FROM user WHERE region IN (:regions)"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadUsersFromRegions</span><span class="params">(regions: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;NameTuple&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可观察查询"><a class="markdownIt-Anchor" href="#可观察查询"></a> 可观察查询</h4>
<p>执行查询时，您通常会希望应用的界面在数据发生变化时自动更新。为此，请在查询方法说明中使用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 类型的返回值。当数据库更新时，Room 会生成更新 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 所必需的所有代码。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT first_name, last_name FROM user WHERE region IN (:regions)"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadUsersFromRegionsSync</span><span class="params">(regions: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: LiveData&lt;List&lt;User&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：自版本 1.0 起，Room 会根据在查询中访问的表格列表决定是否更新 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 实例。</p>
</blockquote>
<h4 id="使用rxjava进行响应式查询"><a class="markdownIt-Anchor" href="#使用rxjava进行响应式查询"></a> 使用RxJava进行响应式查询</h4>
<p>Room 为 RxJava2 类型的返回值提供了以下支持：</p>
<ul>
<li><code>@Query</code> 方法：Room 支持 <a href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html" target="_blank" rel="noopener"><code>Publisher</code></a>、<a href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html" target="_blank" rel="noopener"><code>Flowable</code></a> 和 <a href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html" target="_blank" rel="noopener"><code>Observable</code></a> 类型的返回值。</li>
<li><code>@Insert</code>、<code>@Update</code> 和 <code>@Delete</code> 方法：Room 2.1.0 及更高版本支持 <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Completable.html" target="_blank" rel="noopener"><code>Completable</code></a>、<a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Single.html" target="_blank" rel="noopener"><code>Single</code></a> 和 <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Maybe.html" target="_blank" rel="noopener"><code>Maybe</code></a> 类型的返回值。</li>
</ul>
<p>要使用此功能，请在应用的 <code>build.gradle</code> 文件中添加最新版本的 <strong>rxjava2</strong> 工件：</p>
<p>app/build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;    </span><br><span class="line">  <span class="keyword">def</span> room_version = <span class="string">"2.1.0"</span>    </span><br><span class="line">  implementation <span class="string">'androidx.room:room-rxjava2:$room_version'</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下代码段展示了几个如何使用这些返回类型的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * from user where id = :id LIMIT 1"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadUserById</span><span class="params">(id: <span class="type">Int</span>)</span></span>: Flowable&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emits the number of users added to the database.</span></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertLargeNumberOfUsers</span><span class="params">(users: <span class="type">List</span>&lt;<span class="type">User</span>&gt;)</span></span>: Maybe&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure that the operation finishes successfully.</span></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertLargeNumberOfUsers</span><span class="params">(varargs users: <span class="type">User</span>)</span></span>: Completable</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Emits the number of users removed from the database. Always emits at</span></span><br><span class="line"><span class="comment">       least one user. */</span></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteAllUsers</span><span class="params">(users: <span class="type">List</span>&lt;<span class="type">User</span>&gt;)</span></span>: Single&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参阅 Google Developers <a href="https://medium.com/google-developers/room-rxjava-acb0cd4f3757" target="_blank" rel="noopener">Room 和 RxJava</a> 一文</p>
</blockquote>
<h4 id="直接光标访问"><a class="markdownIt-Anchor" href="#直接光标访问"></a> 直接光标访问</h4>
<p>如果应用的逻辑需要直接访问返回行，您可以从查询返回 <code>Cursor</code> 对象，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user WHERE age &gt; :minAge LIMIT 5"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadRawUsersOlderThan</span><span class="params">(minAge: <span class="type">Int</span>)</span></span>: Cursor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：强烈建议您不要使用 Cursor API，因为它无法保证行是否存在或者行包含哪些值。只有当您已具有需要光标且无法轻松重构的代码时，才使用此功能。</p>
</blockquote>
<h4 id="查询多个表格"><a class="markdownIt-Anchor" href="#查询多个表格"></a> 查询多个表格</h4>
<p>部分查询可能需要访问多个表格才能计算出结果。借助 Room，您可以编写任何查询，因此您也可以联接表格。此外，如果响应是可观察数据类型（如 <a href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html" target="_blank" rel="noopener"><code>Flowable</code></a> 或 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a>），Room 会观察查询中引用的所有表格，以确定是否存在无效表格。</p>
<p>以下代码段展示了如何执行表格联接来整合两个表格的信息：一个表格包含当前借阅图书的用户，另一个表格包含当前处于已被借阅状态的图书的数据。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"SELECT * FROM book "</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"INNER JOIN loan ON loan.book_id = book.id "</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"INNER JOIN user ON user.id = loan.user_id "</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"WHERE user.name LIKE :userName"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findBooksBorrowedByNameSync</span><span class="params">(userName: <span class="type">String</span>)</span></span>: List&lt;Book&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以从这些查询中返回 POJO。例如，您可以编写一条加载某位用户及其宠物名字的查询，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"SELECT user.name AS userName, pet.name AS petName "</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"FROM user, pet "</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"WHERE user.id = pet.user_id"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadUserAndPetNames</span><span class="params">()</span></span>: LiveData&lt;List&lt;UserPet&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You can also define this class in a separate file.</span></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPet</span></span>(<span class="keyword">val</span> userName: String?, <span class="keyword">val</span> petName: String?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用kotlin协程编写异步方法"><a class="markdownIt-Anchor" href="#使用kotlin协程编写异步方法"></a> 使用Kotlin协程编写异步方法</h4>
<p>将 <code>suspend</code> Kotlin 关键字添加到 DAO 方法，以使用 Kotlin 协程功能使这些方法成为异步方法。这样可确保不会在主线程上执行这些方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Update</span></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Delete</span></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user"</span>)</span></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadAllUsers</span><span class="params">()</span></span>: Array&lt;User&gt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：要将 Room 与 Kotlin 协程一起使用，您需要使用 Room 2.1.0、Kotlin 1.3.0 和 Cordoines 1.0.0 或更高版本。如需了解详情，请参阅<a href="https://developer.android.com/jetpack/androidx/releases/room#declaring_dependencies" target="_blank" rel="noopener">声明依赖项</a>。</p>
</blockquote>
<p>本指南也适用于带有 <a href="https://developer.android.com/reference/androidx/room/Transaction" target="_blank" rel="noopener"><code>@Transaction</code></a> 注释的 DAO 方法。您可以使用此功能通过其他 DAO 方法构建暂停数据库方法。然后，这些方法会在单个数据库事务中运行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersDao</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Transaction</span></span><br><span class="line">        <span class="keyword">open</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">setLoggedInUser</span><span class="params">(loggedInUser: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            deleteUser(loggedInUser)</span><br><span class="line">            insertUser(loggedInUser)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Query(<span class="meta-string">"DELETE FROM users"</span>)</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteUser</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Insert</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertUser</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：应避免在单个数据库事务中执行额外的应用端工作，因为 Room 会将此类事务视为独占事务，并且按顺序每次仅执行一个事务。也就是说，包含不必要操作的事务很容易锁定您的数据库并影响性能。</p>
</blockquote>
<h2 id="预填充数据库"><a class="markdownIt-Anchor" href="#预填充数据库"></a> 预填充数据库</h2>
<h2 id="迁移数据库"><a class="markdownIt-Anchor" href="#迁移数据库"></a> 迁移数据库</h2>
<h2 id="测试和调试数据库"><a class="markdownIt-Anchor" href="#测试和调试数据库"></a> 测试和调试数据库</h2>
<h2 id="引用复杂数据"><a class="markdownIt-Anchor" href="#引用复杂数据"></a> 引用复杂数据</h2>
<h3 id="使用类型转换器"><a class="markdownIt-Anchor" href="#使用类型转换器"></a> 使用类型转换器</h3>
<h3 id="了解room为何不允许对象引用"><a class="markdownIt-Anchor" href="#了解room为何不允许对象引用"></a> 了解Room为何不允许对象引用</h3>
<blockquote>
<p><strong>要点</strong>：Room 不允许实体类之间进行对象引用。因此，您必须明确请求您的应用所需的数据。</p>
<p>映射从数据库到相应对象模型之间的关系是一种常见做法，极其适用于服务器端。即使程序在访问字段时加载字段，服务器仍然可以正常工作。</p>
<p>但在客户端，这种延迟加载是不可行的，因为它通常发生在界面线程上，并且在界面线程上查询磁盘上的信息会导致严重的性能问题。界面线程通常需要大约 16 毫秒来计算和绘制 Activity 的更新后的布局，因此，即使查询只用了 5 毫秒，您的应用仍然可能会用尽剩余的时间来绘制框架，从而导致明显的显示故障。如果有一个并行运行的单独事务，或者设备正在运行其他磁盘密集型任务，则查询可能需要更多时间才能完成。不过，如果您不使用延迟加载，则应用会抓取一些不必要的数据，从而导致内存消耗问题。</p>
<p>对象关系型映射通常将决定权留给开发者，以便他们可以针对自己的应用用例执行最合适的操作。开发者通常会决定在应用和界面之间共享模型。不过，这种解决方案并不能很好地扩展，因为界面会不断发生变化，共享模型会出现开发者难以预测和调试的问题。</p>
<p>例如，假设界面加载了 <code>Book</code> 对象的列表，其中每本图书都有一个 <code>Author</code> 对象。您最初可能设计让查询使用延迟加载，从而让 <code>Book</code> 实例检索作者。对 <code>author</code> 字段的第一次检索会查询数据库。一段时间后，您发现还需要在应用的界面中显示作者姓名。您可以轻松访问此名称，如以下代码段所示：</p>
<p><code>authorNameTextView.text = book.author.name</code></p>
<p>不过，这种看似无害的更改会导致在主线程上查询 <code>Author</code> 表。</p>
<p>如果您事先查询作者信息，则在您不再需要这些数据时，就会很难更改数据加载方式。例如，如果应用的界面不再需要显示 <code>Author</code> 信息，则应用会有效地加载不再显示的数据，从而浪费宝贵的内存空间。如果 <code>Author</code> 类引用其他表（例如 <code>Books</code>），则应用的效率会进一步下降。</p>
<p>要使用 Room 同时引用多个实体，请改为创建包含每个实体的 POJO，然后编写用于联接相应表的查询。这种结构合理的模型结合 Room 强大的查询验证功能，可让您的应用在加载数据时消耗较少的资源，从而改善应用的性能和用户体验。</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/7-%E5%88%86%E9%A1%B5%E5%BA%93/">7-分页库</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JetPack/">JetPack</a></span><div class="content"><blockquote>
<p>分页库可帮助您一次加载和显示一小块数据。按需载入部分数据会减少网络带宽和系统资源的使用量。</p>
</blockquote>
<h2 id="声明依赖项"><a class="markdownIt-Anchor" href="#声明依赖项"></a> 声明依赖项</h2>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> paging_version = <span class="string">"2.1.1"</span></span><br><span class="line"></span><br><span class="line">  implementation <span class="string">"androidx.paging:paging-runtime:$paging_version"</span> <span class="comment">// For Kotlin use paging-runtime-ktx</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// alternatively - without Android dependencies for testing</span></span><br><span class="line">  testImplementation <span class="string">"androidx.paging:paging-common:$paging_version"</span> <span class="comment">// For Kotlin use paging-common-ktx</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - RxJava support</span></span><br><span class="line">  implementation <span class="string">"androidx.paging:paging-rxjava2:$paging_version"</span> <span class="comment">// For Kotlin use paging-rxjava2-ktx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h2>
<h3 id="库架构"><a class="markdownIt-Anchor" href="#库架构"></a> 库架构</h3>
<h4 id="pagelist"><a class="markdownIt-Anchor" href="#pagelist"></a> PageList</h4>
<blockquote>
<p>分页库的关键组件是 PagedList 类，用于加载应用数据块或页面。随着所需数据的增多，系统会将其分页到现有的 PagedList 对象中。如果任何已加载的数据发生更改，会从 LiveData 或基于 RxJava2 的对象向可观察数据存储器发出一个新的 PagedList 实例。随着 PagedList 对象的生成，应用界面会呈现其内容，同时还会考虑界面控件的生命周期。</p>
</blockquote>
<p>示例</p>
<p>以下代码段展示了如何配置应用的视图模型，以便使用 PagedList 对象的 LiveData 存储器加载和显示数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertViewModel</span></span>(concertDao: ConcertDao) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> concertList: LiveData&lt;PagedList&lt;Concert&gt;&gt; =</span><br><span class="line">            concertDao.concertsByDate().toLiveData(pageSize = <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据"><a class="markdownIt-Anchor" href="#数据"></a> 数据</h4>
<blockquote>
<p>每个 PagedList 实例都会从对应的 DataSource 对象加载应用数据的最新快照。数据从您应用的后端或数据库流向 PagedList 对象。</p>
</blockquote>
<p>以下示例使用 Room 持久性库来整理应用数据，但如果要通过其他方式存储数据，也可以提供自己的数据源工厂：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ConcertDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The Int type parameter tells Room to use a PositionalDataSource object.</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM concerts ORDER BY date DESC"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">concertsByDate</span><span class="params">()</span></span>: DataSource.Factory&lt;<span class="built_in">Int</span>, Concert&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="界面"><a class="markdownIt-Anchor" href="#界面"></a> 界面</h4>
<blockquote>
<p>PagedList 类使用 PagedListAdapter 将项加载到 RecyclerView。这些类共同作用，在内容加载时抓取和显示内容，预取不在视线范围内的内容以及针对内容更改添加动画。</p>
</blockquote>
<h3 id="支持不同的数据架构"><a class="markdownIt-Anchor" href="#支持不同的数据架构"></a> 支持不同的数据架构</h3>
<h4 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h4>
<p>要显示来自后端服务器的数据，请使用同步版本的 <a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit API</a>，将信息加载到<a href="https://developer.android.com/topic/libraries/architecture/paging/data#custom-data-source" target="_blank" rel="noopener">您自己的自定义 <code>DataSource</code> 对象</a>中。</p>
<p><strong>注意</strong>：由于不同的应用处理和显示错误界面的方式不同，因此分页库的 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 对象不提供任何错误处理。如果发生错误，请遵循结果回调，并在稍后重试请求。有关此行为的示例，请参阅 <a href="https://github.com/googlesamples/android-architecture-components/tree/master/PagingWithNetworkSample">PagingWithNetwork 示例</a>。</p>
<h4 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h4>
<p>设置您的 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView" target="_blank" rel="noopener"><code>RecyclerView</code></a> 以观察本地存储空间，最好使用 <a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="noopener">Room 持久性库</a>。这样，无论您何时在应用数据库中插入或修改数据，这些更改都会自动反映在显示此数据的 <code>RecyclerView</code> 中。</p>
<h4 id="网络和数据库"><a class="markdownIt-Anchor" href="#网络和数据库"></a> 网络和数据库</h4>
<p>在开始观察数据库之后，您可以使用 <a href="https://developer.android.com/reference/androidx/paging/PagedList.BoundaryCallback" target="_blank" rel="noopener"><code>PagedList.BoundaryCallback</code></a> 监听数据库中的数据何时耗尽。然后，您可以从网络中获取更多项目并将它们插入到数据库中。如果界面正在观察数据库，则您只需执行此操作即可</p>
<h3 id="处理网络错误"><a class="markdownIt-Anchor" href="#处理网络错误"></a> 处理网络错误</h3>
<p>通过分页库，使用网络对要显示的数据进行抓取或分页时，请务必不要始终将网络视为“可用”或“不可用”，因为许多连接会断断续续或不稳定：</p>
<ul>
<li>特定服务器可能无法响应网络请求。</li>
<li>设备可能连接到速度较慢或信号较弱的网络。</li>
</ul>
<p>您的应用应检查每个请求是否失败，并在网络不可用的情况下尽可能正常恢复。例如，如果数据刷新步骤不起作用，您可以提供“重试”按钮供用户选择。如果在数据分页步骤中发生错误，则最好自动重新尝试分页请求。</p>
<h3 id="更新现有应用"><a class="markdownIt-Anchor" href="#更新现有应用"></a> 更新现有应用</h3>
<h4 id="自定义分页解析"><a class="markdownIt-Anchor" href="#自定义分页解析"></a> 自定义分页解析</h4>
<p>如果您使用自定义功能从应用的数据源加载较小的数据子集，则可以将此逻辑替换为 PagedList 类中的逻辑。PagedList 实例提供了与常见数据源的内置连接。这些实例还为应用界面中可能包含的 RecyclerView 对象提供了适配器。</p>
<h4 id="使用列表而不是网页加载的数据"><a class="markdownIt-Anchor" href="#使用列表而不是网页加载的数据"></a> 使用列表而不是网页加载的数据</h4>
<p>如果您使用内存中列表作为界面适配器的后备数据结构，并且列表中的项目数量可能会变得非常大，请考虑使用 <a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 类观察数据更新。</p>
<p>__PagedList 实例可以使用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 或 <code>Observable</code> 向您的应用界面传递数据更新，从而最大限度地缩短加载时间并减少内存用量。__在应用中将 <a href="https://developer.android.com/reference/java/util/List" target="_blank" rel="noopener"><code>List</code></a> 对象替换成 <code>PagedList</code> 对象会得到更理想的结果，因为后者不需要对应用界面结构或数据更新逻辑进行任何更改。</p>
<h4 id="使用cursoradapter将数据光标与列表视图相关联"><a class="markdownIt-Anchor" href="#使用cursoradapter将数据光标与列表视图相关联"></a> 使用CursorAdapter将数据光标与列表视图相关联</h4>
<p>您的应用可能会使用 CursorAdapter 将 Cursor 的数据与 ListView 相关联。</p>
<p>在这种情况下，您通常需要：</p>
<ul>
<li>
<p>从 ListView 迁移到 RecyclerView，以后者作为应用的列表界面容器，</p>
</li>
<li>
<p>将 Cursor 组件替换为 Room 或 PositionalDataSource，具体取决于 Cursor 实例是否会访问 SQLite 数据库。</p>
<p>在某些情况下，例如在使用 Spinner 的实例时，您只需提供适配器本身。然后，库将获取加载到该适配器中的数据，并为您显示这些数据。</p>
<p>在这类情况下，请将适配器的数据类型更改为 LiveData<PagedList>，然后将此列表封装到 ArrayAdapter 对象中，再尝试让库类扩充界面中的这些项目。</p>
</li>
</ul>
<h4 id="使用asynclistutil异步加载内容"><a class="markdownIt-Anchor" href="#使用asynclistutil异步加载内容"></a> 使用AsyncListUtil异步加载内容</h4>
<p>如果您使用 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/AsyncListUtil" target="_blank" rel="noopener"><code>AsyncListUtil</code></a> 对象来异步加载和显示信息组，则通过分页库可以更轻松地加载数据：</p>
<ul>
<li>**您的数据无需固定位置。**通过分页库，您可以使用网络提供的密钥直接从后端加载数据。</li>
<li>**您的数据可能会非常庞大。**通过分页库，您可以将数据加载到网页中，直到没有剩余数据为止。</li>
<li>**您可以更轻松地观察数据。**分页库可以为您呈现应用 ViewModel 存储在可观察数据结构中的数据。</li>
</ul>
<h3 id="数据库示例"><a class="markdownIt-Anchor" href="#数据库示例"></a> 数据库示例</h3>
<h4 id="使用livedata观察分页数据"><a class="markdownIt-Anchor" href="#使用livedata观察分页数据"></a> 使用LiveData观察分页数据</h4>
<p>以下代码段显示了完整代码。随着在数据库中添加、移除或更改 concert 事件，<a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView" target="_blank" rel="noopener"><code>RecyclerView</code></a> 中的内容会自动且高效地更新：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ConcertDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The Int type parameter tells Room to use a PositionalDataSource</span></span><br><span class="line">    <span class="comment">// object, with position-based loading under the hood.</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM concerts ORDER BY date DESC"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">concertsByDate</span><span class="params">()</span></span>: DataSource.Factory&lt;<span class="built_in">Int</span>, Concert&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertViewModel</span></span>(concertDao: ConcertDao) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> concertList: LiveData&lt;PagedList&lt;Concert&gt;&gt; =</span><br><span class="line">            concertDao.concertsByDate().toLiveData(pageSize = <span class="number">50</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> viewModel = ViewModelProviders.of(<span class="keyword">this</span>)</span><br><span class="line">                .<span class="keyword">get</span>&lt;ConcertViewModel&gt;()</span><br><span class="line">        <span class="keyword">val</span> recyclerView = findViewById(R.id.concert_list)</span><br><span class="line">        <span class="keyword">val</span> adapter = ConcertAdapter()</span><br><span class="line">        viewModel.livePagedList.observe(<span class="keyword">this</span>, PagedList(adapter::submitList))</span><br><span class="line">        recyclerView.setAdapter(adapter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertAdapter</span></span>() :</span><br><span class="line">        PagedListAdapter&lt;Concert, ConcertViewHolder&gt;(DIFF_CALLBACK) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ConcertViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> concert: Concert? = getItem(position)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that "concert" is a placeholder if it's null.</span></span><br><span class="line">        holder.bindTo(concert)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> DIFF_CALLBACK = <span class="keyword">object</span> :</span><br><span class="line">                DiffUtil.ItemCallback&lt;Concert&gt;() &#123;</span><br><span class="line">            <span class="comment">// Concert details may have changed if reloaded from the database,</span></span><br><span class="line">            <span class="comment">// but ID is fixed.</span></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areItemsTheSame</span><span class="params">(oldConcert: <span class="type">Concert</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    newConcert: <span class="type">Concert</span>)</span></span> = oldConcert.id == newConcert.id</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areContentsTheSame</span><span class="params">(oldConcert: <span class="type">Concert</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    newConcert: <span class="type">Concert</span>)</span></span> = oldConcert == newConcert</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用rxjava2观察分页数据"><a class="markdownIt-Anchor" href="#使用rxjava2观察分页数据"></a> 使用RxJava2观察分页数据</h4>
<p>如果您倾向于使用 <a href="https://github.com/ReactiveX/RxJava">RxJava2</a> 而不是 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a>，则可以改为创建 <code>Observable</code> 或 <code>Flowable</code> 对象：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertViewModel</span></span>(concertDao: ConcertDao) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> concertList: Observable&lt;PagedList&lt;Concert&gt;&gt; =</span><br><span class="line">            concertDao.concertsByDate().toObservable(pageSize = <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，您可以使用以下代码段中的代码来开始和停止观察数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> adapter: ConcertAdapter()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: ConcertViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> disposable = CompositeDisposable()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> recyclerView = findViewById(R.id.concert_list)</span><br><span class="line">        viewModel = ViewModelProviders.of(<span class="keyword">this</span>)</span><br><span class="line">                .<span class="keyword">get</span>&lt;ConcertViewModel&gt;()</span><br><span class="line">        recyclerView.setAdapter(adapter)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        disposable.add(viewModel.concertList</span><br><span class="line">                .subscribe(adapter::submitList)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        disposable.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于基于 <a href="https://github.com/ReactiveX/RxJava">RxJava2</a> 的解决方案，<code>ConcertDao</code> 和 <code>ConcertAdapter</code> 的代码是相同的，对于基于 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 的解决方案也是如此。</p>
</blockquote>
<h2 id="显示分页列表"><a class="markdownIt-Anchor" href="#显示分页列表"></a> 显示分页列表</h2>
<blockquote>
<p>本指南基于_分页库概览_，介绍了如何在应用界面中向用户显示信息列表，尤其是在此信息发生变化时。</p>
</blockquote>
<h3 id="将界面与视图模型关联"><a class="markdownIt-Anchor" href="#将界面与视图模型关联"></a> 将界面与视图模型关联</h3>
<p>将 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 的实例连接到 <a href="https://developer.android.com/reference/androidx/paging/PagedListAdapter" target="_blank" rel="noopener"><code>PagedListAdapter</code></a>，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> adapter = ConcertAdapter()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: ConcertViewModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    viewModel = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(ConcertViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    viewModel.concerts.observe(<span class="keyword">this</span>, Observer &#123; adapter.submitList(it) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数据源提供 PagedList 的新实例时，Activity 会将这些对象发送到适配器。PagedListAdapter 实现定义了更新的计算方式，并自动处理分页和列表差异。因此，您的 ViewHolder 只需要绑定到提供的特定项即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertAdapter</span></span>() :</span><br><span class="line">        PagedListAdapter&lt;Concert, ConcertViewHolder&gt;(DIFF_CALLBACK) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ConcertViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> concert: Concert? = getItem(position)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that "concert" is a placeholder if it's null.</span></span><br><span class="line">        holder.bindTo(concert)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> DIFF_CALLBACK = ... <span class="comment">// See Implement the diffing callback section.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.android.com/reference/androidx/paging/PagedListAdapter" target="_blank" rel="noopener"><code>PagedListAdapter</code></a> 使用 <a href="https://developer.android.com/reference/androidx/paging/PagedList.Callback" target="_blank" rel="noopener"><code>PagedList.Callback</code></a> 对象处理网页加载事件。当用户滚动时，<code>PagedListAdapter</code> 会调用 <a href="https://developer.android.com/reference/androidx/paging/PagedList#loadaround" target="_blank" rel="noopener"><code>PagedList.loadAround()</code></a> 来向底层 <a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 提供关于应从 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 获取哪些项的提示。</p>
<p><strong>注意</strong>：<a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 具有内容不可变特性。这意味着即使可以将新内容加载到 <code>PagedList</code> 的实例中，但加载的项目本身不会在加载后立即改变。因此，如果 <code>PagedList</code> 中的内容更新，则 <a href="https://developer.android.com/reference/androidx/paging/PagedListAdapter" target="_blank" rel="noopener"><code>PagedListAdapter</code></a> 对象会收到包含更新后信息的<strong>全新 <code>PagedList</code></strong>。</p>
<h3 id="实现差异回调"><a class="markdownIt-Anchor" href="#实现差异回调"></a> 实现差异回调</h3>
<p>以下示例展示了用于比较相关对象字段的 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil.ItemCallback#arecontentsthesame" target="_blank" rel="noopener"><code>areContentsTheSame()</code></a> 的手动实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> DIFF_CALLBACK = <span class="keyword">object</span> : DiffUtil.ItemCallback&lt;Concert&gt;() &#123;</span><br><span class="line">    <span class="comment">// The ID property identifies when items are the same.</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areItemsTheSame</span><span class="params">(oldItem: <span class="type">Concert</span>, newItem: <span class="type">Concert</span>)</span></span> =</span><br><span class="line">            oldItem.id == newItem.id</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you use the "==" operator, make sure that the object implements</span></span><br><span class="line">    <span class="comment">// .equals(). Alternatively, write custom data comparison logic here.</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areContentsTheSame</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            oldItem: <span class="type">Concert</span>, newItem: <span class="type">Concert</span>)</span></span> = oldItem == newItem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于适配器包含比较项的定义，因此适配器会在有新的 <code>PagedList</code> 对象加载时自动检测这些项的更改。这样，适配器就会在您的 <code>RecyclerView</code> 对象内触发有效的项目动画。</p>
</blockquote>
<h3 id="使用其它适配器类型实现差异回调功能"><a class="markdownIt-Anchor" href="#使用其它适配器类型实现差异回调功能"></a> 使用其它适配器类型实现差异回调功能</h3>
<p>如果您选择不从 <a href="https://developer.android.com/reference/androidx/paging/PagedListAdapter" target="_blank" rel="noopener"><code>PagedListAdapter</code></a> 继承（例如，当您使用的库提供自己的适配器时），仍可以直接通过 <a href="https://developer.android.com/reference/androidx/paging/AsyncPagedListDiffer" target="_blank" rel="noopener"><code>AsyncPagedListDiffer</code></a> 对象来使用分页库适配器的差异化功能。</p>
<h3 id="在界面中提供占位符placeholder"><a class="markdownIt-Anchor" href="#在界面中提供占位符placeholder"></a> 在界面中提供占位符（placeholder）</h3>
<p>如果您希望界面在应用完成数据获取前显示列表，可以向用户显示占位符列表项。<a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 对这种情况的处理方式是将列表项数据显示为 <code>null</code>，直到加载了数据为止。</p>
<blockquote>
<p><strong>注意</strong>：默认情况下，分页库支持这种占位符行为。</p>
</blockquote>
<p>占位符具有以下优点：</p>
<ul>
<li><strong>支持滚动条</strong>：<a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 可向 <a href="https://developer.android.com/reference/androidx/paging/PagedListAdapter" target="_blank" rel="noopener"><code>PagedListAdapter</code></a> 提供列表项数量。此信息允许适配器绘制滚动条来传达整个列表大小。有新页面载入时，滚动条不会跳到指定位置，因为列表不会改变大小。</li>
<li><strong>无需加载旋转图标</strong>：由于列表大小已知，因此无需提醒用户正在加载更多项。占位符本身会传达这一信息。</li>
</ul>
<p>不过，在添加对占位符的支持之前，请注意以下前提条件：</p>
<ul>
<li><strong>需要可计数的数据集</strong>：<a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="noopener">Room 持久性库</a> 中的 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 实例可以有效地计算项的数量。但如果您使用的是自定义本地存储解决方案或<a href="https://developer.android.com/topic/libraries/architecture/paging#network-only-data-arch" target="_blank" rel="noopener">网络专用数据架构</a>，确定数据集包含多少项可能会开销极大，甚至根本无法确定。</li>
<li><strong>适配器必须考虑未加载的项</strong>：为准备列表以应对增长而使用的适配器或呈现机制需要处理 Null 列表项。例如，将数据绑定到 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder" target="_blank" rel="noopener"><code>ViewHolder</code></a> 时，您需要提供默认值来表示未加载数据。</li>
<li><strong>需要同样大小的项视图</strong>：如果列表项大小会随着内容而变（例如社交网络更新），则项之间的交叉渐变效果并不理想。在这种情况下，我们强烈建议停用占位符。</li>
</ul>
<h2 id="加载分页数据"><a class="markdownIt-Anchor" href="#加载分页数据"></a> 加载分页数据</h2>
<blockquote>
<p>讨论如何自定义应用的数据加载解决方案以满足应用的架构需求</p>
</blockquote>
<h3 id="构造可观察列表"><a class="markdownIt-Anchor" href="#构造可观察列表"></a> 构造可观察列表</h3>
<blockquote>
<p>通常，您的界面代码会观察 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象（如果您使用 <a href="https://github.com/ReactiveX/RxJava">RxJava2</a>，则会观察 <code>Flowable</code> 或 <code>Observable</code> 对象），该对象位于您应用的 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 中。此可观察对象搭起应用列表数据的呈现与内容之间的关联。</p>
<p>为了创建其中一个可观察的 <a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 对象，请将 <a href="https://developer.android.com/reference/androidx/paging/DataSource.Factory" target="_blank" rel="noopener"><code>DataSource.Factory</code></a> 的实例传递到 <a href="https://developer.android.com/reference/androidx/paging/LivePagedListBuilder" target="_blank" rel="noopener"><code>LivePagedListBuilder</code></a> 或 <a href="https://developer.android.com/reference/androidx/paging/RxPagedListBuilder" target="_blank" rel="noopener"><code>RxPagedListBuilder</code></a> 对象。<a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 对象会加载单个 <code>PagedList</code> 的页面。Factory 类会创建新的 <code>PagedList</code> 实例来响应内容更新，例如数据库表失效和网络刷新。<a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="noopener">Room 持久性库</a>可为您提供 <code>DataSource.Factory</code> 对象，您也可以<a href="https://developer.android.com/topic/libraries/architecture/paging/data#custom-data-source" target="_blank" rel="noopener">构建自己的对象</a>。</p>
</blockquote>
<p>以下代码段展示了如何使用 Room 的 <a href="https://developer.android.com/reference/androidx/paging/DataSource.Factory" target="_blank" rel="noopener"><code>DataSource.Factory</code></a> 构建功能在应用的 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 类中创建新的 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 实例：</p>
<p>ConcertDao</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ConcertDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The Int type parameter tells Room to use a PositionalDataSource</span></span><br><span class="line">    <span class="comment">// object, with position-based loading under the hood.</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM concerts ORDER BY date DESC"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">concertsByDate</span><span class="params">()</span></span>: DataSource.Factory&lt;<span class="built_in">Int</span>, Concert&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcertViewModel</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The Int type argument corresponds to a PositionalDataSource object.</span></span><br><span class="line"><span class="keyword">val</span> myConcertDataSource : DataSource.Factory&lt;<span class="built_in">Int</span>, Concert&gt; =</span><br><span class="line">       concertDao.concertsByDate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> concertList = myConcertDataSource.toLiveData(pageSize = <span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<h3 id="自定义分页配置"><a class="markdownIt-Anchor" href="#自定义分页配置"></a> 自定义分页配置</h3>
<blockquote>
<p>要进一步为高级用例配置 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a>，您还可以定义自己的分页配置。特别是，您可以定义以下特性：</p>
<ul>
<li><strong><a href="https://developer.android.com/reference/androidx/paging/PagedList.Config.Builder#setPageSize(int)" target="_blank" rel="noopener">页面大小</a></strong>：每个页面中的项数。</li>
<li><strong><a href="https://developer.android.com/reference/androidx/paging/PagedList.Config.Builder#setPrefetchDistance(int)" target="_blank" rel="noopener">预取距离</a></strong>：给定应用界面中的最后一个可见项，分页库应尝试提前获取的超出此最后一项的项数。此值应是页面大小的数倍大。</li>
<li><strong><a href="https://developer.android.com/reference/androidx/paging/PagedList.Config.Builder#setEnablePlaceholders(boolean)" target="_blank" rel="noopener">占位符存在</a></strong>：确定界面是否对尚未完成加载的列表项显示占位符。有关使用占位符的优缺点的探讨，请参阅如何<a href="https://developer.android.com/topic/libraries/architecture/paging/ui#provide-placeholders" target="_blank" rel="noopener">在界面中提供占位符</a>。</li>
</ul>
</blockquote>
<p>如果您希望更好地控制分页库何时从应用数据库加载列表，请将自定义 <a href="https://developer.android.com/reference/java/util/concurrent/Executor" target="_blank" rel="noopener"><code>Executor</code></a> 对象传递给 <a href="https://developer.android.com/reference/androidx/paging/LivePagedListBuilder" target="_blank" rel="noopener"><code>LivePagedListBuilder</code></a>，如以下代码段所示：</p>
<p>ConcertViewModel</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myPagingConfig = Config(</span><br><span class="line">        pageSize = <span class="number">50</span>,</span><br><span class="line">        prefetchDistance = <span class="number">150</span>,</span><br><span class="line">        enablePlaceholders = <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The Int type argument corresponds to a PositionalDataSource object.</span></span><br><span class="line"><span class="keyword">val</span> myConcertDataSource : DataSource.Factory&lt;<span class="built_in">Int</span>, Concert&gt; =</span><br><span class="line">        concertDao.concertsByDate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> concertList = myConcertDataSource.toLiveData(</span><br><span class="line">        pagingConfig = myPagingConfig,</span><br><span class="line">        fetchExecutor = myExecutor</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="选择合适的数据源类型"><a class="markdownIt-Anchor" href="#选择合适的数据源类型"></a> 选择合适的数据源类型</h3>
<blockquote>
<p>请务必连接到能最好地处理源数据结构的数据源：</p>
<ul>
<li>
<p>如果您加载的网页嵌入了上一页/下一页的键，请使用 <a href="https://developer.android.com/reference/androidx/paging/PageKeyedDataSource" target="_blank" rel="noopener"><code>PageKeyedDataSource</code></a>。例如，如果您从网络中获取社交媒体帖子，则可能需要将一个 <code>nextPage</code> 令牌从一次加载传递到后续加载。</p>
</li>
<li>
<p>如果您需要使用项目 N 中的数据来获取项目 N+1，请使用 <a href="https://developer.android.com/reference/androidx/paging/ItemKeyedDataSource" target="_blank" rel="noopener"><code>ItemKeyedDataSource</code></a>。例如，如果您要为讨论应用获取会话式评论，则可能需要传递最后一条评论的 ID 以获取下一条评论的内容。</p>
</li>
<li>
<p>如果您需要从数据存储区中选择的任意位置获取数据页，请使用 <a href="https://developer.android.com/reference/androidx/paging/PositionalDataSource" target="_blank" rel="noopener"><code>PositionalDataSource</code></a>。该类支持从您选择的任意位置开始请求一组数据项。例如，该请求可能会返回从位置 1500 开始的 50 个数据项。</p>
</li>
</ul>
</blockquote>
<h3 id="数据无效时发送通知"><a class="markdownIt-Anchor" href="#数据无效时发送通知"></a> 数据无效时发送通知</h3>
<p>当使用分页库时，由<strong>数据层</strong>在表或行已过时通知应用的其他层。为此，请从您为应用选择的 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 类中调用 <a href="https://developer.android.com/reference/androidx/paging/DataSource#invalidate" target="_blank" rel="noopener"><code>invalidate()</code></a>。</p>
<blockquote>
<p><strong>注意</strong>：应用界面可以使用<a href="https://developer.android.com/training/swipe" target="_blank" rel="noopener">下拉刷新</a>模型触发此数据失效功能。</p>
</blockquote>
<h3 id="自定义数据源"><a class="markdownIt-Anchor" href="#自定义数据源"></a> 自定义数据源</h3>
<p>如果您使用自定义本地数据解决方案，或直接从网络加载数据，则可以实现其中一个 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 子类。</p>
<p>以下代码段展示了从指定音乐会开始时间开始的数据源：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertTimeDataSource</span></span>() :</span><br><span class="line">        ItemKeyedDataSource&lt;Date, Concert&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getKey</span><span class="params">(item: <span class="type">Concert</span>)</span></span> = item.startTime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadInitial</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            params: <span class="type">LoadInitialParams</span>&lt;<span class="type">Date</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">            callback: <span class="type">LoadInitialCallback</span>&lt;<span class="type">Concert</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> items = fetchItems(params.requestedInitialKey,</span><br><span class="line">                params.requestedLoadSize)</span><br><span class="line">        callback.onResult(items)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadAfter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            params: <span class="type">LoadParams</span>&lt;<span class="type">Date</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">            callback: <span class="type">LoadCallback</span>&lt;<span class="type">Concert</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> items = fetchItemsAfter(</span><br><span class="line">            date = params.key,</span><br><span class="line">            limit = params.requestedLoadSize)</span><br><span class="line">        callback.onResult(items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，您可以通过创建具体的 <a href="https://developer.android.com/reference/androidx/paging/DataSource.Factory" target="_blank" rel="noopener"><code>DataSource.Factory</code></a> 子类，将此自定义数据加载到 <code>PagedList</code> 对象中。</p>
<p>以下代码段展示了如何生成前面代码段中定义的自定义数据源的新实例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertTimeDataSourceFactory</span> :<span class="type"></span></span></span><br><span class="line">        DataSource.Factory&lt;Date, Concert&gt;() &#123;</span><br><span class="line">    <span class="keyword">val</span> sourceLiveData = MutableLiveData&lt;ConcertTimeDataSource&gt;()</span><br><span class="line">    <span class="keyword">var</span> latestSource: ConcertDataSource?</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: DataSource&lt;Date, Concert&gt; &#123;</span><br><span class="line">        latestSource = ConcertTimeDataSource()</span><br><span class="line">        sourceLiveData.postValue(latestSource)</span><br><span class="line">        <span class="keyword">return</span> latestSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="考虑内容更新的运作方式"><a class="markdownIt-Anchor" href="#考虑内容更新的运作方式"></a> 考虑内容更新的运作方式</h3>
<p>构建可观察的 <a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 对象时，请考虑内容更新的运作方式。如果直接从 <a href="https://developer.android.com/training/data-storage/room" target="_blank" rel="noopener">Room 数据库</a>加载数据，则更新会自动推送至应用界面。</p>
<p>使用分页网络 API 时，您通常需要使用“下拉刷新”这样的用户互动，以指示系统让最近使用的 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 的失效。然后请求该数据源的新实例。</p>
<p>以下代码段演示了此行为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        concertTimeViewModel.refreshState.observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">            <span class="comment">// Shows one possible way of triggering a refresh operation.</span></span><br><span class="line">            swipeRefreshLayout.isRefreshing =</span><br><span class="line">                    it == MyNetworkState.LOADING</span><br><span class="line">        &#125;)</span><br><span class="line">        swipeRefreshLayout.setOnRefreshListener &#123;</span><br><span class="line">            concertTimeViewModel.invalidateDataSource()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertTimeViewModel</span></span>(firstConcertStartTime: Date) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> dataSourceFactory = ConcertTimeDataSourceFactory(firstConcertStartTime)</span><br><span class="line">    <span class="keyword">val</span> concertList: LiveData&lt;PagedList&lt;Concert&gt;&gt; =</span><br><span class="line">            dataSourceFactory.toLiveData(</span><br><span class="line">                pageSize = <span class="number">50</span>,</span><br><span class="line">                fetchExecutor = myExecutor</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invalidateDataSource</span><span class="params">()</span></span> =</span><br><span class="line">            dataSourceFactory.sourceLiveData.value?.invalidate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提供数据映射"><a class="markdownIt-Anchor" href="#提供数据映射"></a> 提供数据映射</h3>
<p>分页库支持基于项目或基于页面转换由 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 加载的项目。</p>
<p>在以下代码段中，音乐会名称和音乐会日期的组合映射到同时包含名称和日期的单个字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> concertDescriptions : LiveData&lt;PagedList&lt;String&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> concerts = database.allConcertsFactory()</span><br><span class="line">                    .map <span class="string">"<span class="subst">$&#123;it.name&#125;</span> - <span class="subst">$&#123;it.date&#125;</span>"</span> &#125;</span><br><span class="line">                    .toLiveData(pageSize = <span class="number">50</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果您希望在项目加载后进行换行、转换或准备，这将非常有用。由于这项工作是在提取执行程序上完成的，因此您可以执行开销可能很大的工作，如从磁盘读取或查询单独的数据库。</strong></p>
<blockquote>
<p><strong>注意</strong>：JOIN 查询作为 <code>map()</code> 的一部分，总是能够更高效地进行重新查询。</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/6-LiveData/">6-LiveData</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JetPack/">JetPack</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/LiveData/">LiveData</a></span><div class="content"><blockquote>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。</p>
</blockquote>
<h2 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> 优势</h2>
<ol>
<li>
<p><strong>确保界面符合数据状态</strong></p>
<p>​	LiveData 遵循观察者模式。当生命周期状态发生变化时，LiveData 会通知 <a href="https://developer.android.com/reference/androidx/lifecycle/Observer" target="_blank" rel="noopener"><code>Observer</code></a> 对象。您可以整合代码以在这些 <code>Observer</code> 对象中更新界面。观察者可以在每次发生更改时更新界面，而不是在每次应用数据发生更改时更新界面。</p>
</li>
<li>
<p><strong>不会发生内存泄露</strong></p>
<p>​	观察者会绑定到 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 对象，并在其关联的生命周期遭到销毁后进行自我清理。</p>
</li>
<li>
<p><strong>不会因 Activity 停止而导致崩溃</strong></p>
<p>​	如果观察者的生命周期处于非活跃状态（如返回栈中的 Activity），则它不会接收任何 LiveData 事件。</p>
</li>
<li>
<p><strong>不再需要手动处理生命周期</strong></p>
<p>​	界面组件只是观察相关数据，不会停止或恢复观察。LiveData 将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。</p>
</li>
<li>
<p><strong>数据始终保持最新状态</strong></p>
<p>​	如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的 Activity 会在返回前台后立即接收最新的数据。</p>
</li>
<li>
<p><strong>适当的配置更改</strong></p>
<p>​	如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。</p>
</li>
<li>
<p><strong>共享资源</strong></p>
<p>​	您可以使用单一实例模式扩展 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象以封装系统服务，以便在应用中共享它们。<code>LiveData</code> 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 <code>LiveData</code> 对象。有关详情，请参阅<a href="https://developer.android.com/topic/libraries/architecture/livedata#extend_livedata" target="_blank" rel="noopener">扩展 LiveData</a>。</p>
</li>
</ol>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2>
<p>请按照以下步骤使用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象：</p>
<ol>
<li>创建 <code>LiveData</code> 实例以存储某种类型的数据。这通常在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 类中完成。</li>
<li>创建可定义 <a href="https://developer.android.com/reference/androidx/lifecycle/Observer#onChanged(T)" target="_blank" rel="noopener"><code>onChanged()</code></a> 方法的 <a href="https://developer.android.com/reference/androidx/lifecycle/Observer" target="_blank" rel="noopener"><code>Observer</code></a> 对象，该方法可以控制当 <code>LiveData</code> 对象存储的数据更改时会发生什么。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中创建 <code>Observer</code> 对象。</li>
<li>使用 [<code>observe()</code>](<a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#observe" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/lifecycle/LiveData#observe</a>(android.arch.lifecycle.LifecycleOwner, android.arch.lifecycle.Observer)) 方法将 <code>Observer</code> 对象附加到 <code>LiveData</code> 对象。<code>observe()</code> 方法会采用 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 对象。这样会使 <code>Observer</code> 对象订阅 <code>LiveData</code> 对象，以使其收到有关更改的通知。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中附加 <code>Observer</code> 对象。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：您可以使用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#observeForever(android.arch.lifecycle.Observer)" target="_blank" rel="noopener"><code>observeForever(Observer)</code></a> 方法来注册未关联 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 对象的观察者。在这种情况下，观察者会被视为始终处于活跃状态，因此它始终会收到关于修改的通知。您可以通过调用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#removeObserver(android.arch.lifecycle.Observer)" target="_blank" rel="noopener"><code>removeObserver(Observer)</code></a> 方法来移除这些观察者。</p>
</blockquote>
<h3 id="创建"><a class="markdownIt-Anchor" href="#创建"></a> 创建</h3>
<p>LiveData 是一种可用于任何数据的封装容器，其中包括可实现 <code>Collections</code> 的对象，如 <code>List</code>。 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象通常存储在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象中，并可通过 getter 方法进行访问，如以下示例中所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a LiveData with a String</span></span><br><span class="line">    <span class="keyword">val</span> currentName: MutableLiveData&lt;String&gt; <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        MutableLiveData&lt;String&gt;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rest of the ViewModel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：请确保将用于更新界面的 <code>LiveData</code> 对象存储在 <code>ViewModel</code> 对象中，而不是将其存储在 Activity 或 Fragment 中，原因如下：</p>
<p>​	避免 Activity 和 Fragment 过于庞大。现在，这些界面控制器负责显示数据，但不负责存储数据状态。将 <code>LiveData</code> 实例与特定的 Activity 或 Fragment 实例分离开，并使 对象在配置更改后继续存在。</p>
</blockquote>
<h3 id="观察"><a class="markdownIt-Anchor" href="#观察"></a> 观察</h3>
<p>在大多数情况下，应用组件的 <code>onCreate()</code> 方法是开始观察 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象的正确着手点，原因如下：</p>
<ul>
<li>确保系统不会从 Activity 或 Fragment 的 <code>onResume()</code> 方法进行冗余调用。</li>
<li>确保 Activity 或 Fragment 变为活跃状态后具有可以立即显示的数据。一旦应用组件处于 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.State#STARTED" target="_blank" rel="noopener"><code>STARTED</code></a> 状态，就会从它正在观察的 <code>LiveData</code> 对象接收最新值。只有在设置了要观察的 <code>LiveData</code> 对象时，才会发生这种情况。</li>
</ul>
<p>通常，LiveData 仅在数据发生更改时才发送更新，并且仅发送给活跃观察者。</p>
<blockquote>
<p>此行为的一种例外情况是，观察者从非活跃状态更改为活跃状态时也会收到更新。</p>
<p>此外，如果观察者第二次从非活跃状态更改为活跃状态，则只有在自上次变为活跃状态以来值发生了更改时，它才会收到更新。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> model: NameViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Other code to setup the activity...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the ViewModel.</span></span><br><span class="line">        model = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(NameViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the observer which updates the UI.</span></span><br><span class="line">        <span class="keyword">val</span> nameObserver = Observer&lt;String&gt; &#123; newName -&gt;</span><br><span class="line">            <span class="comment">// Update the UI, in this case, a TextView.</span></span><br><span class="line">            nameTextView.text = newName</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.</span></span><br><span class="line">        model.currentName.observe(<span class="keyword">this</span>, nameObserver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在传递 <code>nameObserver</code> 参数的情况下调用 [<code>observe()</code>](<a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#observe" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/lifecycle/LiveData#observe</a>(android.arch.lifecycle.LifecycleOwner, android.arch.lifecycle.Observer)) 后，系统会立即调用 <a href="https://developer.android.com/reference/androidx/lifecycle/Observer#onChanged(T)" target="_blank" rel="noopener"><code>onChanged()</code></a>，从而提供 <code>mCurrentName</code> 中存储的最新值。 如果 <code>LiveData</code> 对象尚未在 <code>mCurrentName</code> 中设置值，则不会调用 <code>onChanged()</code>。</p>
</blockquote>
<h3 id="更新"><a class="markdownIt-Anchor" href="#更新"></a> 更新</h3>
<p>​	LiveData 没有公开可用的方法来更新存储的数据。<a href="https://developer.android.com/reference/androidx/lifecycle/MutableLiveData" target="_blank" rel="noopener"><code>MutableLiveData</code></a> 类将公开 <a href="https://developer.android.com/reference/androidx/lifecycle/MutableLiveData#setValue(T)" target="_blank" rel="noopener"><code>setValue(T)</code></a> 和 <a href="https://developer.android.com/reference/androidx/lifecycle/MutableLiveData#postValue(T)" target="_blank" rel="noopener"><code>postValue(T)</code></a> 方法，如果您需要修改存储在 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象中的值，则必须使用这些方法。通常情况下会在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 中使用 <code>MutableLiveData</code>，然后 <code>ViewModel</code> 只会向观察者公开不可变的 <code>LiveData</code> 对象。</p>
<p>​	设置观察者关系后，您可以更新 <code>LiveData</code> 对象的值（如以下示例中所示），这样当用户点按某个按钮时会触发所有观察者：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> anotherName = <span class="string">"John Doe"</span></span><br><span class="line">    model.currentName.setValue(anotherName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在本例中调用 setValue(T) 导致观察者使用值 John Doe 调用其 onChanged() 方法。</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：您必须调用 <a href="https://developer.android.com/reference/androidx/lifecycle/MutableLiveData#setValue(T)" target="_blank" rel="noopener"><code>setValue(T)</code></a> 方法以从主线程更新 <code>LiveData</code> 对象。如果在 worker 线程中执行代码，则您可以改用 <a href="https://developer.android.com/reference/androidx/lifecycle/MutableLiveData#postValue(T)" target="_blank" rel="noopener"><code>postValue(T)</code></a> 方法来更新 <code>LiveData</code> 对象。</p>
<h3 id="将livedata与room一起使用"><a class="markdownIt-Anchor" href="#将livedata与room一起使用"></a> 将LiveData与Room一起使用</h3>
<blockquote>
<p>Room 持久性库支持返回 LiveData 对象的可观察查询。可观察查询属于数据库访问对象 (DAO) 的一部分。</p>
<p>当数据库更新时，Room 会生成更新 LiveData 对象所需的所有代码。在需要时，生成的代码会在后台线程上异步运行查询。此模式有助于使界面中显示的数据与存储在数据库中的数据保持同步。</p>
</blockquote>
<h3 id="将协程与livedata一起使用"><a class="markdownIt-Anchor" href="#将协程与livedata一起使用"></a> 将协程与LiveData一起使用</h3>
<blockquote>
<p><code>LiveData</code> 支持 Kotlin 协程。</p>
</blockquote>
<h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2>
<p>如果观察者的生命周期处于 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.State#STARTED" target="_blank" rel="noopener"><code>STARTED</code></a> 或 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.State#RESUMED" target="_blank" rel="noopener"><code>RESUMED</code></a> 状态，则 LiveData 会认为该观察者处于活跃状态。</p>
<p>以下示例代码说明了如何扩展 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span></span>(symbol: String) : LiveData&lt;BigDecimal&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> stockManager = StockManager(symbol)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> listener = &#123; price: BigDecimal -&gt;</span><br><span class="line">        value = price</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.requestPriceUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.removeUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中的价格监听器实现包括以下重要方法：</p>
<ul>
<li>当 <code>LiveData</code> 对象具有活跃观察者时，会调用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#onActive()" target="_blank" rel="noopener"><code>onActive()</code></a> 方法。这意味着，您需要从此方法开始观察股价更新。</li>
<li>当 <code>LiveData</code> 对象没有任何活跃观察者时，会调用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#onInactive()" target="_blank" rel="noopener"><code>onInactive()</code></a> 方法。由于没有观察者在监听，因此没有理由与 <code>StockManager</code> 服务保持连接。</li>
<li><a href="https://developer.android.com/reference/androidx/lifecycle/MutableLiveData#setValue(T)" target="_blank" rel="noopener"><code>setValue(T)</code></a> 方法将更新 <code>LiveData</code> 实例的值，并将更改通知给任何活跃观察者。</li>
</ul>
<p>可以使用 <code>StockLiveData</code> 类，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState)</span><br><span class="line">    <span class="keyword">val</span> myPriceListener: LiveData&lt;BigDecimal&gt; = ...</span><br><span class="line">    myPriceListener.observe(<span class="keyword">this</span>, Observer&lt;BigDecimal&gt; &#123; price: BigDecimal? -&gt;</span><br><span class="line">        <span class="comment">// Update the UI.</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[<code>observe()</code>](<a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#observe" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/lifecycle/LiveData#observe</a>(android.arch.lifecycle.LifecycleOwner, android.arch.lifecycle.Observer)) 方法将传递 Fragment（它是 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 的实例）作为第一个参数。这样做表示此观察者已绑定到与所有者关联的 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 对象，这意味着：</p>
<ul>
<li>如果 <code>Lifecycle</code> 对象未处于活跃状态，那么即使值发生更改，也不会调用观察者。</li>
<li>销毁 <code>Lifecycle</code> 对象后，会自动移除观察者。</li>
</ul>
<p><code>LiveData</code> 对象具有生命周期感知能力，这一事实意味着您可以在多个 Activity、Fragment 和 Service 之间共享它们。为使示例保持简单，您可以将 <code>LiveData</code> 类实现为单一实例，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span></span>(symbol: String) : LiveData&lt;BigDecimal&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> stockManager: StockManager = StockManager(symbol)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> listener = &#123; price: BigDecimal -&gt;</span><br><span class="line">        value = price</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.requestPriceUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.removeUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sInstance: StockLiveData</span><br><span class="line"></span><br><span class="line">        <span class="meta">@MainThread</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(symbol: <span class="type">String</span>)</span></span>: StockLiveData &#123;</span><br><span class="line">            sInstance = <span class="keyword">if</span> (::sInstance.isInitialized) sInstance <span class="keyword">else</span> StockLiveData(symbol)</span><br><span class="line">            <span class="keyword">return</span> sInstance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且您可以在 Fragment 中使用它，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        StockLiveData.<span class="keyword">get</span>(symbol).observe(<span class="keyword">this</span>, Observer&lt;BigDecimal&gt; &#123; price: BigDecimal? -&gt;</span><br><span class="line">            <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>多个 Fragment 和 Activity 可以观察 <code>MyPriceListener</code> 实例。仅当一个或多个系统服务可见且处于活跃状态时，LiveData 才会连接到该服务。</p>
<h2 id="转换"><a class="markdownIt-Anchor" href="#转换"></a> 转换</h2>
<p>​	如果希望在将 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象分派给观察者之前对存储在其中的值进行更改，或者您可能需要根据另一个实例的值返回不同的 <code>LiveData</code> 实例。<a href="https://developer.android.com/reference/android/arch/lifecycle/package-summary" target="_blank" rel="noopener"><code>Lifecycle</code></a> 软件包会提供 <a href="https://developer.android.com/reference/androidx/lifecycle/Transformations" target="_blank" rel="noopener"><code>Transformations</code></a> 类，该类包括可应对这些情况的辅助程序方法。</p>
<ul>
<li>
<p>[<code>Transformations.map()</code>](<a href="https://developer.android.com/reference/androidx/lifecycle/Transformations#map" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/lifecycle/Transformations#map</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function))</p>
<p>对存储在 <code>LiveData</code> 对象中的值应用函数，并将结果传播到下游。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> userLiveData: LiveData&lt;User&gt; = UserLiveData()</span><br><span class="line"><span class="keyword">val</span> userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123;</span><br><span class="line">    user -&gt; <span class="string">"<span class="subst">$&#123;user.name&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>[<code>Transformations.switchMap()</code>](<a href="https://developer.android.com/reference/androidx/lifecycle/Transformations#switchMap" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/lifecycle/Transformations#switchMap</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function&gt;))</p>
<p>与 <code>map()</code> 类似，对存储在 <code>LiveData</code> 对象中的值应用函数，并将结果解封和分派到下游。传递给 <code>switchMap()</code> 的函数必须返回 <code>LiveData</code> 对象，如以下示例中所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(id: <span class="type">String</span>)</span></span>: LiveData &#123;   ...  &#125;  </span><br><span class="line"><span class="keyword">val</span> userId: LiveData = ...  </span><br><span class="line"><span class="keyword">val</span> user = Transformations.switchMap(userId) &#123; id -&gt; getUser(id) &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​	可以使用转换方法在观察者的生命周期内传送信息。除非观察者正在观察返回的 <code>LiveData</code> 对象，否则不会计算转换。因为__转换是以延迟的方式计算__，所以与生命周期相关的行为会隐式传递下去，而不需要额外的显式调用或依赖项。</p>
<p>​</p>
<p>如果您认为 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象中需要有 <code>Lifecycle</code> 对象，那么进行转换或许是更好的解决方案。例如，假设您有一个界面组件，该组件接受地址并返回该地址的邮政编码。您可以为此组件实现简单的 <code>ViewModel</code>，如以下示例代码所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: PostalCodeRepository) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPostalCode</span><span class="params">(address: <span class="type">String</span>)</span></span>: LiveData&lt;String&gt; &#123;</span><br><span class="line">        <span class="comment">// 不要这么做</span></span><br><span class="line">        <span class="keyword">return</span> repository.getPostCode(address)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	UI组件需要在每次调用getPostalCode()的时候，从之前的LiveData对象中取消注册，并注册到新的实例。此外，如果UI组件被重新创建，它将触发对repository.getPostCode()方法的另一次调用，而不是使用上次调用的结果。</p>
<p>​	您也可以将邮政编码查询实现为地址输入的转换，如以下示例中所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: PostalCodeRepository) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> addressInput = MutableLiveData&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> postalCode: LiveData&lt;String&gt; = Transformations.switchMap(addressInput) &#123;</span><br><span class="line">            address -&gt; repository.getPostCode(address) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setInput</span><span class="params">(address: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        addressInput.value = address</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这种情况下，<code>postalCode</code> 字段定义为 <code>addressInput</code> 的转换。只要您的应用具有与 <code>postalCode</code> 字段关联的活跃观察者，就会在 <code>addressInput</code> 发生更改时重新计算并检索该字段的值。</p>
<p>此机制允许较低级别的应用创建以延迟的方式按需计算的 <code>LiveData</code> 对象。<code>ViewModel</code> 对象可以轻松获取对 <code>LiveData</code> 对象的引用，然后在其基础之上定义转换规则。</p>
</blockquote>
<h3 id="创建新的转换-mediatorlivedata"><a class="markdownIt-Anchor" href="#创建新的转换-mediatorlivedata"></a> 创建新的转换 MediatorLiveData</h3>
<blockquote>
<p>有十几种不同的特定转换在您的应用中可能很有用，但默认情况下不提供它们。要实现您自己的转换，您可以使用 <a href="https://developer.android.com/reference/androidx/lifecycle/MediatorLiveData" target="_blank" rel="noopener"><code>MediatorLiveData</code></a>类，该类可以监听其他 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象并处理它们发出的事件。<code>MediatorLiveData</code> 正确地将其状态传播到源 <code>LiveData</code> 对象。要详细了解此模式，请参阅 <a href="https://developer.android.com/reference/androidx/lifecycle/Transformations" target="_blank" rel="noopener"><code>Transformations</code></a> 类的参考文档。</p>
</blockquote>
<h2 id="合并多个源"><a class="markdownIt-Anchor" href="#合并多个源"></a> 合并多个源</h2>
<p>​	<strong>MediatorLiveData</strong> 是 LiveData 的子类，允许您合并多个 LiveData 源。只要任何原始的 LiveData 源对象发生更改，就会触发 MediatorLiveData 对象的观察者。</p>
<p>​	例如，如果界面中有可以从本地数据库或网络更新的 LiveData 对象，则可以向 MediatorLiveData 对象添加以下源：</p>
<ul>
<li>
<p>与存储在数据库中的数据关联的 LiveData 对象。</p>
</li>
<li>
<p>与从网络访问的数据关联的 LiveData 对象。</p>
</li>
</ul>
<p>​    您的 Activity 只需观察 MediatorLiveData 对象即可从这两个源接收更新。有关详细示例，请参阅应用架构指南的附录：公开网络状态部分。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/5-%E5%A4%84%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">5-处理生命周期</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JetPack/">JetPack</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Lifecycle/">Lifecycle</a></span><div class="content"><blockquote>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/package-summary" target="_blank" rel="noopener"><code>androidx.lifecycle</code></a> 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> lifecycle_version = <span class="string">"2.2.0"</span></span><br><span class="line">    <span class="keyword">def</span> arch_version = <span class="string">"2.1.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewModel</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"</span></span><br><span class="line">    <span class="comment">// LiveData</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version"</span></span><br><span class="line">    <span class="comment">// Lifecycles only (without ViewModel or LiveData)</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Saved state module for ViewModel</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation processor</span></span><br><span class="line">    kapt <span class="string">"androidx.lifecycle:lifecycle-compiler:$lifecycle_version"</span></span><br><span class="line">    <span class="comment">// alternately - if using Java8, use the following instead of lifecycle-compiler</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-common-java8:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - ReactiveStreams support for LiveData</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-reactivestreams-ktx:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers for LiveData</span></span><br><span class="line">    testImplementation <span class="string">"androidx.arch.core:core-testing:$arch_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> callback: (Location) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// connect to system location service</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// disconnect from system location service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> myLocationListener: MyLocationListener</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        myLocationListener = MyLocationListener(<span class="keyword">this</span>) &#123; location -&gt;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        myLocationListener.start()</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        myLocationListener.stop()</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然此示例看起来没问题，但在真实的应用中，最终会有太多管理界面和其他组件的调用，以响应生命周期的当前状态。管理多个组件会在生命周期方法（如 <code>onStart()</code> 和 <code>onStop()</code>）中放置大量的代码，这使得它们难以维护。</p>
<p>此外，无法保证组件会在 Activity 或 Fragment 停止之前启动。在我们需要执行长时间运行的操作（如 <code>onStart()</code> 中的某种配置检查）时尤其如此。这可能会导致出现一种竞争条件，在这种条件下，<code>onStop()</code> 方法会在 <code>onStart()</code> 之前结束，这使得组件留存的时间比所需的时间要长。</p>
</blockquote>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/package-summary" target="_blank" rel="noopener"><code>androidx.lifecycle</code></a> 软件包提供的类和接口可帮助您以弹性和隔离的方式解决这些问题。</p>
<h2 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h2>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。</p>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 使用两种主要枚举跟踪其关联组件的生命周期状态：</p>
<ul>
<li>
<p>事件</p>
<p>从框架和 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。</p>
</li>
<li>
<p>状态</p>
<p>由 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 对象跟踪的组件的当前状态。</p>
</li>
</ul>
<p><img src="/Users/liubo/Desktop/%E7%AC%94%E8%AE%B0/Jetpack/lifecycle-states.svg" alt="lifecycle-states" /></p>
<p><strong>图 1.</strong> 构成 Android Activity 生命周期的状态和事件</p>
<p>类可以通过向其方法添加注解来监控组件的生命周期状态。然后，您可以通过调用 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 类的 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle#addObserver(androidx.lifecycle.LifecycleObserver)" target="_blank" rel="noopener"><code>addObserver()</code></a> 方法并传递观察者的实例来添加观察者，如以下示例中所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> : <span class="type">LifecycleObserver &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">connectListener</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">disconnectListener</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myLifecycleOwner.getLifecycle().addObserver(MyObserver())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的示例中，<code>myLifecycleOwner</code> 对象实现了 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 接口，我们将在接下来的部分中对该接口进行说明。</p>
</blockquote>
<h2 id="lifecycleowner"><a class="markdownIt-Anchor" href="#lifecycleowner"></a> LifecycleOwner</h2>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 是单一方法接口，表示类具有 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a>。它具有一种方法（即 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner#getLifecycle()" target="_blank" rel="noopener"><code>getLifecycle()</code></a>），该方法必须由类实现。如果您尝试管理整个应用进程的生命周期，请参阅 <a href="https://developer.android.com/reference/androidx/lifecycle/ProcessLifecycleOwner" target="_blank" rel="noopener"><code>ProcessLifecycleOwner</code></a>。</p>
<p>实现 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver" target="_blank" rel="noopener"><code>LifecycleObserver</code></a> 的组件可与实现 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 的组件无缝协同工作，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。</p>
<blockquote>
<p>对于位置跟踪示例，我们可以让 <code>MyLocationListener</code> 类实现 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver" target="_blank" rel="noopener"><code>LifecycleObserver</code></a>，然后在 <code>onCreate()</code> 方法中使用 Activity 的 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 对其进行初始化。这样，<code>MyLocationListener</code> 类便可以“自给自足”，这意味着，对生命周期状态的变化做出响应的逻辑会在 <code>MyLocationListener</code>（而不是在 Activity）中进行声明。让各个组件存储自己的逻辑，可使 Activity 和 Fragment 逻辑更易于管理。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> myLocationListener: MyLocationListener</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        myLocationListener = MyLocationListener(<span class="keyword">this</span>, lifecycle) &#123; location -&gt;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;</span><br><span class="line">        Util.checkUserStatus &#123; result -&gt;</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.enable()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个常见的用例是，如果 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 现在未处于良好的状态，则应避免调用某些回调。例如，如果回调在 Activity 状态保存后运行 Fragment 事务，就会引发崩溃，因此我们绝不能调用该回调。</p>
<p>为简化此用例，<a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 类允许其他对象查询当前状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> lifecycle: Lifecycle,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> callback: (Location) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> enabled = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">            <span class="comment">// connect</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">enable</span><span class="params">()</span></span> &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) &#123;</span><br><span class="line">            <span class="comment">// connect if not connected</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// disconnect if connected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于此实现，<code>LocationListener</code> 类可以完全感知生命周期。如果我们需要从另一个 Activity 或 Fragment 使用 <code>LocationListener</code>，只需对其进行初始化。所有设置和拆解操作都由类本身管理。</p>
</blockquote>
<h3 id="实现自定义lifecycleowner"><a class="markdownIt-Anchor" href="#实现自定义lifecycleowner"></a> 实现自定义LifecycleOwner</h3>
<blockquote>
<p>Support Library 26.1.0 及更高版本中的 Fragment 和 Activity 已实现 LifecycleOwner 接口。</p>
</blockquote>
<p>如果您有一个自定义类并希望使其成为 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a>，您可以使用 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleRegistry" target="_blank" rel="noopener">LifecycleRegistry</a> 类，但需要将事件转发到该类，如以下代码示例中所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">Activity</span></span>(), LifecycleOwner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> lifecycleRegistry: LifecycleRegistry</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        lifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.CREATED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle &#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生命周期感知型组件的最佳做法"><a class="markdownIt-Anchor" href="#生命周期感知型组件的最佳做法"></a> 生命周期感知型组件的最佳做法</h2>
<ul>
<li>使界面控制器（Activity 和 Fragment）尽可能保持精简。它们不应试图获取自己的数据，而应使用 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 执行此操作，并观察 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象以将更改体现到视图中。</li>
<li>设法编写数据驱动型界面，对于此类界面，界面控制器的责任是随着数据更改而更新视图，或者将用户操作通知给 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a>。</li>
<li>将数据逻辑放在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 类中。 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 应充当界面控制器与应用其余部分之间的连接器。不过要注意，<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 不负责获取数据（例如，从网络获取）。<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 应调用相应的组件来获取数据，然后将结果提供给界面控制器。</li>
<li>使用 <a href="https://developer.android.com/topic/libraries/data-binding" target="_blank" rel="noopener">Data Binding</a> 在视图与界面控制器之间维持干净的接口。这样一来，您可以使视图更具声明性，并尽量减少需要在 Activity 和 Fragment 中编写的更新代码。如果您更愿意使用 Java 编程语言执行此操作，请使用诸如 <a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">Butter Knife</a> 之类的库，以避免样板代码并实现更好的抽象化。</li>
<li>如果界面很复杂，不妨考虑创建 <a href="http://www.gwtproject.org/articles/mvp-architecture.html#presenter" target="_blank" rel="noopener">presenter</a> 类来处理界面的修改。这可能是一项艰巨的任务，但这样做可使界面组件更易于测试。</li>
<li>避免在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 中引用 <code>View</code> 或 <code>Activity</code> 上下文。 如果 <code>ViewModel</code> 存在的时间比 Activity 更长（在配置更改的情况下），Activity 将泄露并且不会由垃圾回收器妥善处置。</li>
<li>使用 <a href="https://developer.android.com/topic/libraries/architecture/coroutines" target="_blank" rel="noopener">Kotlin 协程</a>管理长时间运行的任务和其他可以异步运行的操作。</li>
</ul>
<h2 id="生命周期感知型组件的用例"><a class="markdownIt-Anchor" href="#生命周期感知型组件的用例"></a> 生命周期感知型组件的用例</h2>
<blockquote>
<p>生命周期感知型组件可使您在各种情况下更轻松地管理生命周期。下面列举几个例子：</p>
<ul>
<li>在粗粒度和细粒度位置更新之间切换。使用生命周期感知型组件可在位置应用可见时启用细粒度位置更新，并在应用位于后台时切换到粗粒度更新。借助生命周期感知型组件 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a>，应用可以在用户使用位置发生变化时自动更新界面。</li>
<li>停止和开始视频缓冲。使用生命周期感知型组件可尽快开始视频缓冲，但会推迟播放，直到应用完全启动。此外，应用销毁后，您还可以使用生命周期感知型组件终止缓冲。</li>
<li>开始和停止网络连接。借助生命周期感知型组件，可在应用位于前台时启用网络数据的实时更新（流式传输），并在应用进入后台时自动暂停。</li>
<li>暂停和恢复动画可绘制资源。借助生命周期感知型组件，可在应用位于后台时暂停动画可绘制资源，并在应用位于前台后恢复可绘制资源。</li>
</ul>
</blockquote>
<h2 id="处理on_stop事件"><a class="markdownIt-Anchor" href="#处理on_stop事件"></a> 处理ON_STOP事件</h2>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/4-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%BA%93/">4-数据绑定库</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><div class="content"><h3 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h3>
<blockquote>
<p>数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。</p>
</blockquote>
<h4 id="1-开始使用"><a class="markdownIt-Anchor" href="#1-开始使用"></a> 1. 开始使用</h4>
<p>了解如何准备开发环境以使用数据绑定库，包括在 Android Studio 中支持数据绑定代码。</p>
<h4 id="2-布局和绑定表达式"><a class="markdownIt-Anchor" href="#2-布局和绑定表达式"></a> 2. 布局和绑定表达式</h4>
<p>借助表达式语言，您可以编写将变量关联到布局中的视图的表达式。数据绑定库会自动生成将布局中的视图与您的数据对象绑定所需的类。该库提供了可在布局中使用的导入、变量和包含等功能。</p>
<p>该库的这些功能可与您的现有布局无缝地共存。例如，可以在表达式中使用的绑定变量在 <strong>data</strong> 元素（界面布局根元素的同级）内定义。这两个元素都封装在__layout__ 标记中，如以下示例所示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"viewmodel"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"com.myapp.data.ViewModel"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintLayout...</span> /&gt;</span> <span class="comment">&lt;!-- UI layout's root element --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-使用可观察的数据对象"><a class="markdownIt-Anchor" href="#3-使用可观察的数据对象"></a> 3. 使用可观察的数据对象</h4>
<p>数据绑定库提供了可让您轻松地观察数据更改情况的类和方法。您不必操心在底层数据源发生更改时刷新界面。您可以将变量或其属性设为可观察。借助该库，您可以将对象、字段或集合设为可观察。</p>
<h4 id="4-生成的绑定类"><a class="markdownIt-Anchor" href="#4-生成的绑定类"></a> 4. 生成的绑定类</h4>
<p>数据绑定库可以生成用于访问布局变量和视图的绑定类。此页面展示了如何使用和自定义所生成的绑定类。</p>
<h4 id="5-绑定适配器"><a class="markdownIt-Anchor" href="#5-绑定适配器"></a> 5. 绑定适配器</h4>
<p>每一个布局表达式都有一个对应的绑定适配器，要求必须进行框架调用来设置相应的属性或监听器。</p>
<p>例如，绑定适配器负责调用 setText() 方法来设置文本属性，或者调用 setOnClickListener() 方法向点击事件添加监听器。最常拥的绑定适配器（例如针对本页面的示例中使用的 android:text 属性）可供您在 android.databinding.adapters 软件包中使用。如需常用绑定适配器列表，请参阅适配器。您也可以按照以下示例所示创建自定义适配器：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"app:goneUnless"</span>)</span></span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">goneUnless</span><span class="params">(view: <span class="type">View</span>, visible: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">     view.visibility = <span class="keyword">if</span> (visible) View.VISIBLE <span class="keyword">else</span> View.GONE</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<h4 id="将布局视图绑定到架构组件"><a class="markdownIt-Anchor" href="#将布局视图绑定到架构组件"></a> 将布局视图绑定到架构组件</h4>
<p>Android 支持库包含架构组件，您可以使用这些组件设计稳健、可测试且易维护的应用。您可以将架构组件与数据绑定库一起使用，以进一步简化界面开发。</p>
<h4 id="双向数据绑定"><a class="markdownIt-Anchor" href="#双向数据绑定"></a> 双向数据绑定</h4>
<p>数据绑定库支持双向数据绑定。此类绑定使用的表示法支持以下操作：</p>
<ul>
<li>接收对属性的数据更改</li>
<li>监听用户对此属性的更新</li>
</ul>
<h3 id="使用入门"><a class="markdownIt-Anchor" href="#使用入门"></a> 使用入门</h3>
<p>在app的build.gradle文件中添加dataBinding元素</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ···</span><br><span class="line">  dataBinding &#123;</span><br><span class="line">    enabled = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="布局和绑定表达式"><a class="markdownIt-Anchor" href="#布局和绑定表达式"></a> 布局和绑定表达式</h3>
<p><strong>数据绑定布局文件略有不同，以根标记 <code>layout</code> 开头，后跟 <code>data</code> 元素和 <code>view</code> 根元素。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="数据对象"><a class="markdownIt-Anchor" href="#数据对象"></a> 数据对象</h4>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String)</span><br></pre></td></tr></table></figure>
<h4 id="绑定数据"><a class="markdownIt-Anchor" href="#绑定数据"></a> 绑定数据</h4>
<p>系统会为每个布局文件生成一个绑定类。默认情况下，类名称基于布局文件的名称，它会转换为 Pascal 大小写形式（<strong>大驼峰命名方式</strong>）并__在末尾添加 Binding 后缀__。以上布局文件名为 <code>activity_main.xml</code>，因此生成的对应类为 <code>ActivityMainBinding</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> binding: ActivityMainBinding = DataBindingUtil.setContentView(</span><br><span class="line">            <span class="keyword">this</span>, R.layout.activity_main)</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	val binding: ActivityMainBinding = ActivityMainBinding.inflate(getLayoutInflater())</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line"></span><br><span class="line">    binding.user = User(<span class="string">"Test"</span>, <span class="string">"User"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您要在 Fragment、ListView 或 RecyclerView 适配器中使用数据绑定项，您可能更愿意使用绑定类或 DataBindingUtil 类的 inflate() 方法，如以下代码示例所示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">val</span> listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<h4 id="表达式语言"><a class="markdownIt-Anchor" href="#表达式语言"></a> 表达式语言</h4>
<p>表达式语言与托管代码中的表达式非常相似。您可以在表达式语言中使用以下运算符和关键字：</p>
<ul>
<li>算术运算符 <code>+ - / * %</code></li>
<li>字符串连接运算符 <code>+</code></li>
<li>逻辑运算符 <code>&amp;&amp; ||</code></li>
<li>二元运算符 <code>&amp; | ^</code></li>
<li>一元运算符 <code>+ - ! ~</code></li>
<li>移位运算符 <code>&gt;&gt; &gt;&gt;&gt; &lt;&lt;</code></li>
<li>比较运算符 <code>== &gt; &lt; &gt;= &lt;=</code>（请注意，<code>&lt;</code> 需要转义为 <code>&lt;</code>）</li>
<li><code>instanceof</code></li>
<li>分组运算符 <code>()</code></li>
<li>字面量运算符 - 字符、字符串、数字、<code>null</code></li>
<li>类型转换</li>
<li>方法调用</li>
<li>字段访问</li>
<li>数组访问 <code>[]</code></li>
<li>三元运算符 <code>?:</code></li>
</ul>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:text&#x3D;&quot;@&#123;String.valueOf(index + 1)&#125;&quot;</span><br><span class="line">  android:visibility&#x3D;&quot;@&#123;age &gt; 13 ? View.GONE : View.VISIBLE&#125;&quot;</span><br><span class="line">  android:transitionName&#x3D;&#39;@&#123;&quot;image_&quot; + id&#125;&#39;</span><br></pre></td></tr></table></figure>
<h4 id="缺少的运算"><a class="markdownIt-Anchor" href="#缺少的运算"></a> 缺少的运算</h4>
<p>您可以在托管代码中使用的表达式语法中缺少以下运算：</p>
<ul>
<li><code>this</code></li>
<li><code>super</code></li>
<li><code>new</code></li>
<li>显式泛型调用</li>
</ul>
<h4 id="null-合并运算符"><a class="markdownIt-Anchor" href="#null-合并运算符"></a> Null 合并运算符 (??)</h4>
<p>如果左边运算数不是 null，则 Null 合并运算符 (??) 选择左边运算数，如果左边运算数为 ，则选择右边运算数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:text&#x3D;&quot;@&#123;user.displayName ?? user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>这在功能上等效于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:text&#x3D;&quot;@&#123;user.displayName !&#x3D; null ? user.displayName : user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="属性引用"><a class="markdownIt-Anchor" href="#属性引用"></a> 属性引用</h4>
<p>表达式可以使用以下格式在类中引用属性，这对于__字段、getter 和 ObservableField 对象__都一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:text&#x3D;&quot;@&#123;user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="避免出现-null-指针异常"><a class="markdownIt-Anchor" href="#避免出现-null-指针异常"></a> 避免出现 Null 指针异常</h4>
<p>__生成的数据绑定代码会自动检查有没有 null 值并避免出现 Null 指针异常。__例如，在表达式 @{<a href="http://user.name" target="_blank" rel="noopener">user.name</a>} 中，如果 user 为 Null，则为 <a href="http://user.name" target="_blank" rel="noopener">user.name</a> 分配默认值 null。如果您引用 user.age，其中 age 的类型为 int，则数据绑定使用默认值 0。</p>
<h4 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h4>
<p>为方便起见，可使用 <code>[]</code> 运算符访问常见集合，例如数组、列表、稀疏列表和映射。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">        &lt;import type&#x3D;&quot;android.util.SparseArray&quot;&#x2F;&gt;</span><br><span class="line">        &lt;import type&#x3D;&quot;java.util.Map&quot;&#x2F;&gt;</span><br><span class="line">        &lt;import type&#x3D;&quot;java.util.List&quot;&#x2F;&gt;</span><br><span class="line">        &lt;variable name&#x3D;&quot;list&quot; type&#x3D;&quot;List&lt;String&gt;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;variable name&#x3D;&quot;sparse&quot; type&#x3D;&quot;SparseArray&lt;String&gt;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;variable name&#x3D;&quot;map&quot; type&#x3D;&quot;Map&lt;String, String&gt;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;variable name&#x3D;&quot;index&quot; type&#x3D;&quot;int&quot;&#x2F;&gt;</span><br><span class="line">        &lt;variable name&#x3D;&quot;key&quot; type&#x3D;&quot;String&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;data&gt;</span><br><span class="line">    …</span><br><span class="line">    android:text&#x3D;&quot;@&#123;list[index]&#125;&quot;</span><br><span class="line">    …</span><br><span class="line">    android:text&#x3D;&quot;@&#123;sparse[index]&#125;&quot;</span><br><span class="line">    …</span><br><span class="line">    android:text&#x3D;&quot;@&#123;map[key]&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>注意：要使 XML 不含语法错误，您必须转义 &lt; 字符。例如：不要写成 <strong>List<String></strong> 形式，而是必须写成__<code>List&amp;lt;String&gt;</code>__。</p>
<p>还可以使用 <code>object.key</code> 表示法在映射中引用值。例如，以上示例中的 <code>@{map[key]}</code> 可替换为 <code>@{map.key}</code>。</p>
<h4 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h4>
<p>使用单引号括住属性值，这样就可以在表达式中使用双引号，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:text&#x3D;&#39;@&#123;map[&quot;firstName&quot;]&#125;&#39;</span><br><span class="line">&lt;!-- 或者 --&gt;</span><br><span class="line">android:text&#x3D;&quot;@&#123;map[&#96;firstName&#96;]&#125;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h4>
<p>可以使用以下语法访问表达式中的资源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:padding&#x3D;&quot;@&#123;large? @dimen&#x2F;largePadding : @dimen&#x2F;smallPadding&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>格式字符串和复数形式可通过提供参数进行求值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:text&#x3D;&quot;@&#123;@string&#x2F;nameFormat(firstName, lastName)&#125;&quot;</span><br><span class="line">android:text&#x3D;&quot;@&#123;@plurals&#x2F;banana(bananaCount)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>当一个复数带有多个参数时，应传递所有参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Have an orange</span><br><span class="line">  Have %d oranges</span><br><span class="line"></span><br><span class="line">android:text&#x3D;&quot;@&#123;@plurals&#x2F;orange(orangeCount, orangeCount)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>某些资源需要显式类型求值，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th>—</th>
<th>表达式引用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">String[]</td>
<td>@array</td>
<td>@stringArray</td>
</tr>
<tr>
<td style="text-align:left">int[]</td>
<td>@array</td>
<td>@intArray</td>
</tr>
<tr>
<td style="text-align:left">TypedArray</td>
<td>@array</td>
<td>@typedArray</td>
</tr>
<tr>
<td style="text-align:left">Animator</td>
<td>@animator</td>
<td>@animator</td>
</tr>
<tr>
<td style="text-align:left">StateListAnimator</td>
<td>@animator</td>
<td>@stateListAnimator</td>
</tr>
<tr>
<td style="text-align:left">color int</td>
<td>@color</td>
<td>@color</td>
</tr>
<tr>
<td style="text-align:left">ColorStateList</td>
<td>@color</td>
<td>@colorStateList</td>
</tr>
</tbody>
</table>
<h4 id="事件处理"><a class="markdownIt-Anchor" href="#事件处理"></a> 事件处理</h4>
<blockquote>
<p>通过数据绑定，您可以编写从视图分派的表达式处理事件（例如，<code>onClick()</code> 方法）。事件特性名称由监听器方法的名称确定，但有一些例外情况</p>
</blockquote>
<table>
<thead>
<tr>
<th>类</th>
<th>监听器 setter</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>SearchView</td>
<td>setOnSearchClickListener(View.OnClickListener)</td>
<td>android:onSearchClick</td>
</tr>
<tr>
<td>ZoomControls</td>
<td>setOnZoomInClickListener(View.OnClickListener)</td>
<td>android:onZoomIn</td>
</tr>
<tr>
<td>ZoomControls</td>
<td>setOnZoomOutClickListener(View.OnClickListener)</td>
<td>android:onZoomOut</td>
</tr>
<tr>
<td>ZoomControls</td>
<td>setOnClickListener(View.OnClickListener)</td>
<td>android:onClick</td>
</tr>
</tbody>
</table>
<h5 id="方法引用"><a class="markdownIt-Anchor" href="#方法引用"></a> 方法引用</h5>
<p>事件可以直接绑定到处理脚本方法，类似于为 Activity 中的方法指定android:onClick 的方式。</p>
<blockquote>
<p>与 View onClick 特性相比，一个主要优点是表达式在编译时进行处理，因此，如果该方法不存在或其签名不正确，则会收到编译时错误。</p>
</blockquote>
<p>方法引用和监听器绑定之间的主要区别在于:</p>
<blockquote>
<p>实际监听器实现是在绑定数据时创建的，而不是在事件触发时创建的。</p>
<p>如果您希望在事件发生时对表达式求值，则应使用监听器绑定。</p>
</blockquote>
<p>示例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandlers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClickFriend</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">    &lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">       &lt;data&gt;</span><br><span class="line">           &lt;variable name&#x3D;&quot;handlers&quot; type&#x3D;&quot;com.example.MyHandlers&quot;&#x2F;&gt;</span><br><span class="line">           &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;data&gt;</span><br><span class="line">       &lt;LinearLayout</span><br><span class="line">           android:orientation&#x3D;&quot;vertical&quot;</span><br><span class="line">           android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">           android:layout_height&#x3D;&quot;match_parent&quot;&gt;</span><br><span class="line">           &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">               android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">               android:text&#x3D;&quot;@&#123;user.firstName&#125;&quot;</span><br><span class="line">               android:onClick&#x3D;&quot;@&#123;handlers::onClickFriend&#125;&quot;&#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;LinearLayout&gt;</span><br><span class="line">    &lt;&#x2F;layout&gt;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>表达式中的方法签名必须与监听器对象中的方法签名完全一致。</strong></p>
<h5 id="监听器绑定"><a class="markdownIt-Anchor" href="#监听器绑定"></a> 监听器绑定</h5>
<blockquote>
<p>监听器绑定是在事件发生时运行的绑定表达式。它们类似于方法引用，但允许您运行任意数据绑定表达式。此功能适用于 Gradle 2.0 版及更高版本的 Android Gradle 插件。</p>
<p>在方法引用中，方法的参数必须与事件监听器的参数匹配。</p>
<p>在监听器绑定中，只有您的返回值必须与监听器的预期返回值相匹配（预期返回值无效除外）。</p>
</blockquote>
<p>例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSaveClick</span><span class="params">(task: <span class="type">Task</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">    &lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">        &lt;data&gt;</span><br><span class="line">            &lt;variable name&#x3D;&quot;task&quot; type&#x3D;&quot;com.android.example.Task&quot; &#x2F;&gt;</span><br><span class="line">            &lt;variable name&#x3D;&quot;presenter&quot; type&#x3D;&quot;com.android.example.Presenter&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;data&gt;</span><br><span class="line">        &lt;LinearLayout </span><br><span class="line">						android:layout_width&#x3D;&quot;match_parent&quot; </span><br><span class="line">						android:layout_height&#x3D;&quot;match_parent&quot;&gt;</span><br><span class="line">            &lt;Button </span><br><span class="line">								android:layout_width&#x3D;&quot;wrap_content&quot; </span><br><span class="line">								android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            		android:onClick&#x3D;&quot;@&#123;() -&gt; presenter.onSaveClick(task)&#125;&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;LinearLayout&gt;</span><br><span class="line">    &lt;&#x2F;layout&gt;</span><br></pre></td></tr></table></figure>
<p>监听器绑定提供两个监听器参数选项：您可以忽略方法的所有参数，也可以命名所有参数。如果您想命名参数，则可以在表达式中使用这些参数。</p>
<p>例如，上面的表达式可以写成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:onClick&#x3D;&quot;@&#123;(view) -&gt; presenter.onSaveClick(task)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>如果想在表达式中使用参数，则采用如下形式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSaveClick</span><span class="params">(view: <span class="type">View</span>, task: <span class="type">Task</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:onClick&#x3D;&quot;@&#123;(theView) -&gt; presenter.onSaveClick(theView, task)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>可以在 lambda 表达式中使用多个参数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onCompletedChanged</span><span class="params">(task: <span class="type">Task</span>, completed: <span class="type">Boolean</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;CheckBox </span><br><span class="line">		android:layout_width&#x3D;&quot;wrap_content&quot; </span><br><span class="line">		android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:onCheckedChanged&#x3D;&quot;@&#123;(cb, isChecked) -&gt; presenter.completeChanged(task, isChecked)&#125;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>如果您监听的事件返回类型不是 void 的值，则您的表达式也必须返回相同类型的值。</p>
<p>例如，如果要监听长按事件，表达式应返回一个布尔值</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onLongClick</span><span class="params">(view: <span class="type">View</span>, task: <span class="type">Task</span>)</span></span>: <span class="built_in">Boolean</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:onLongClick&#x3D;&quot;@&#123;(theView) -&gt; presenter.onLongClick(theView, task)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>如果由于 <code>null</code> 对象而无法对表达式求值，则数据绑定将返回该类型的默认值。例如，引用类型返回 <code>null</code>，<code>int</code> 返回 <code>0</code>，<code>boolean</code> 返回 <code>false</code>，等等。</p>
<p>如果您需要将表达式与谓词（例如，三元运算符）结合使用，则可以使用 <code>void</code> 作为符号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:onClick&#x3D;&quot;@&#123;(v) -&gt; v.isVisible() ? doSomething() : void&#125;&quot;</span><br></pre></td></tr></table></figure>
<h5 id="避免使用复杂的监听器"><a class="markdownIt-Anchor" href="#避免使用复杂的监听器"></a> 避免使用复杂的监听器</h5>
<p>监听器表达式功能非常强大，可以使您的代码非常易于阅读。另一方面，包含复杂表达式的监听器会使您的布局难以阅读和维护。</p>
<p>这些表达式应该像将可用数据从界面传递到回调方法一样简单。您应该在从监听器表达式调用的回调方法中实现任何业务逻辑。</p>
<h4 id="导入-变量和包含"><a class="markdownIt-Anchor" href="#导入-变量和包含"></a> 导入、变量和包含</h4>
<h5 id="导入"><a class="markdownIt-Anchor" href="#导入"></a> 导入</h5>
<blockquote>
<p>通过导入功能，您可以轻松地在布局文件中引用类。</p>
</blockquote>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">      &lt;import type&#x3D;&quot;android.view.View&quot;&#x2F;&gt;</span><br><span class="line">		&lt;!-- 类型别名：适用于类名出现冲突的情况--&gt;</span><br><span class="line">  		&lt;import type&#x3D;&quot;com.example.real.estate.View&quot;</span><br><span class="line">          alias&#x3D;&quot;Vista&quot;&#x2F;&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;&#x2F;data&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">       android:text&#x3D;&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">       android:visibility&#x3D;&quot;@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>在表达式中引用静态字段和方法时，也可以使用导入的类型。以下代码会导入 <code>MyStringUtils</code> 类，并引用其 <code>capitalize</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">      &lt;import type&#x3D;&quot;com.example.MyStringUtils&quot;&#x2F;&gt;</span><br><span class="line">      &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;data&gt;</span><br><span class="line">  …</span><br><span class="line">  &lt;TextView</span><br><span class="line">     android:text&#x3D;&quot;@&#123;MyStringUtils.capitalize(user.lastName)&#125;&quot;</span><br><span class="line">     android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h5>
<blockquote>
<p>通过变量功能，您可以描述可在绑定表达式中使用的属性。</p>
</blockquote>
<p>您可以在 <code>data</code> 元素中使用多个 <code>variable</code> 元素。每个 <code>variable</code> 元素都描述了一个可以在布局上设置、并将在布局文件中的绑定表达式中使用的属性。</p>
<p>以下示例声明了 <code>user</code>、<code>image</code> 和 <code>note</code> 变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">      &lt;import type&#x3D;&quot;android.graphics.drawable.Drawable&quot;&#x2F;&gt;</span><br><span class="line">      &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">      &lt;variable name&#x3D;&quot;image&quot; type&#x3D;&quot;Drawable&quot;&#x2F;&gt;</span><br><span class="line">      &lt;variable name&#x3D;&quot;note&quot; type&#x3D;&quot;String&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;data&gt;</span><br></pre></td></tr></table></figure>
<p>变量类型在编译时进行检查，因此，如果变量实现 Observable 或者是可观察集合，则应反映在类型中。如果该变量是不实现 Observable 接口的基类或接口，则变量是“不可观察的”。</p>
<p>如果不同配置（例如横向或纵向）有不同的布局文件，则变量会合并在一起。这些布局文件之间__不得存在有冲突的变量定义__。</p>
<blockquote>
<p>在生成的绑定类中，每个描述的变量都有一个对应的 setter 和 getter。在调用 setter 之前，这些变量一直采用默认的托管代码值，例如引用类型采用 <code>null</code>，<code>int</code> 采用 <code>0</code>，<code>boolean</code> 采用 <code>false</code>，等等。</p>
<p>系统会根据需要生成名为 <code>context</code> 的特殊变量，用于绑定表达式。<code>context</code> 的值是根视图的 <code>getContext()</code> 方法中的 <code>Context</code> 对象。<code>context</code> 变量会被具有该名称的显式变量声明替换。</p>
</blockquote>
<h5 id="包含"><a class="markdownIt-Anchor" href="#包含"></a> 包含</h5>
<blockquote>
<p>通过包含功能，您可以在整个应用中重复使用复杂的布局。</p>
</blockquote>
<p>通过使用应用命名空间和特性中的变量名称，变量可以从包含的布局传递到被包含布局的绑定。</p>
<p>以下示例展示了来自 <code>name.xml</code> 和 <code>contact.xml</code> 布局文件的被包含 <code>user</code> 变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">  &lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">          xmlns:bind&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;&gt;</span><br><span class="line">     &lt;data&gt;</span><br><span class="line">         &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">     &lt;&#x2F;data&gt;</span><br><span class="line">     &lt;LinearLayout</span><br><span class="line">         android:orientation&#x3D;&quot;vertical&quot;</span><br><span class="line">         android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">         android:layout_height&#x3D;&quot;match_parent&quot;&gt;</span><br><span class="line">         &lt;include layout&#x3D;&quot;@layout&#x2F;name&quot;</span><br><span class="line">             bind:user&#x3D;&quot;@&#123;user&#125;&quot;&#x2F;&gt;</span><br><span class="line">         &lt;include layout&#x3D;&quot;@layout&#x2F;contact&quot;</span><br><span class="line">             bind:user&#x3D;&quot;@&#123;user&#125;&quot;&#x2F;&gt;</span><br><span class="line">     &lt;&#x2F;LinearLayout&gt;</span><br><span class="line">  &lt;&#x2F;layout&gt;</span><br></pre></td></tr></table></figure>
<p>__数据绑定不支持 include 作为 merge 元素的直接子元素。__例如，以下布局不受支持：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">  &lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">          xmlns:bind&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;&gt;</span><br><span class="line">     &lt;data&gt;</span><br><span class="line">         &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">     &lt;&#x2F;data&gt;</span><br><span class="line">     &lt;merge&gt;&lt;!-- Doesn&#39;t work --&gt;</span><br><span class="line">         &lt;include layout&#x3D;&quot;@layout&#x2F;name&quot;</span><br><span class="line">             bind:user&#x3D;&quot;@&#123;user&#125;&quot;&#x2F;&gt;</span><br><span class="line">         &lt;include layout&#x3D;&quot;@layout&#x2F;contact&quot;</span><br><span class="line">             bind:user&#x3D;&quot;@&#123;user&#125;&quot;&#x2F;&gt;</span><br><span class="line">     &lt;&#x2F;merge&gt;</span><br><span class="line">  &lt;&#x2F;layout&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用可观察的数据对象"><a class="markdownIt-Anchor" href="#使用可观察的数据对象"></a> 使用可观察的数据对象</h3>
<blockquote>
<p>可观察性是指一个对象将其数据变化通知给其他对象的能力。通过数据绑定库，您可以让对象、字段或集合变为可观察。</p>
</blockquote>
<p>任何普通对象都可用于数据绑定，但修改对象不会自动使界面更新。通过数据绑定，数据对象可在其数据发生更改时通知其他对象，即监听器。可观察类有三种不同类型：<strong>对象</strong>、<strong>字段__和__集合</strong>。</p>
<blockquote>
<p>当其中一个可观察数据对象绑定到界面并且该数据对象的属性发生更改时，界面会自动更新。</p>
</blockquote>
<h4 id="字段"><a class="markdownIt-Anchor" href="#字段"></a> 字段</h4>
<p>在创建实现 Observable 接口的类时要完成一些操作，但如果您的类只有少数几个属性，则这样操作的意义不大。在这种情况下，您可以使用通用 Observable 类和以下特定于基元的类，将字段设为可观察字段：</p>
<ul>
<li>ObservableBoolean</li>
<li>ObservableByte</li>
<li>ObservableChar</li>
<li>ObservableShort</li>
<li>ObservableInt</li>
<li>ObservableLong</li>
<li>ObservableFloat</li>
<li>ObservableDouble</li>
<li>ObservableParcelable</li>
</ul>
<p>可观测字段是自成一体的可观测对象。原始版本在访问操作时避免了装箱和解装箱。要使用这种机制，在Java编程语言中创建一个公共的最终属性，或者在Kotlin中创建一个只读属性，如下例所示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> firstName = ObservableField&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> lastName = ObservableField&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> age = ObservableInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要访问字段值，请使用 set() 和 get() 访问器方法，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">user.firstName = <span class="string">"Google"</span></span><br><span class="line"><span class="keyword">val</span> age = user.age</span><br></pre></td></tr></table></figure>
<p>注意：Android Studio 3.1 及更高版本允许用 <strong>LiveData</strong> 对象替换可观察字段，从而为您的应用提供额外的好处。有关详情，请参阅使用 LiveData 将数据变化通知给界面。</p>
<h4 id="集合-2"><a class="markdownIt-Anchor" href="#集合-2"></a> 集合</h4>
<p>某些应用使用动态结构来保存数据。可观察集合允许使用键访问这些结构。当键为引用类型（如 <code>String</code>）时，<a href="https://developer.android.com/reference/androidx/databinding/ObservableArrayMap" target="_blank" rel="noopener"><code>ObservableArrayMap</code></a> 类非常有用，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ObservableArrayMap&lt;String, Any&gt;().apply &#123;</span><br><span class="line">    put(<span class="string">"firstName"</span>, <span class="string">"Google"</span>)</span><br><span class="line">    put(<span class="string">"lastName"</span>, <span class="string">"Inc."</span>)</span><br><span class="line">    put(<span class="string">"age"</span>, <span class="number">17</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在布局文件中，也可以使用以字符串为键的Map，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type&#x3D;&quot;android.databinding.ObservableMap&quot;&#x2F;&gt;</span><br><span class="line">    &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;ObservableMap&lt;String, Object&gt;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;data&gt;</span><br><span class="line">…</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:text&#x3D;&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:text&#x3D;&quot;@&#123;String.valueOf(1 + (Integer)user.age)&#125;&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>当键是整数的时候，ObservableArrayList就很方便：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ObservableArrayList&lt;Any&gt;().apply &#123;</span><br><span class="line">    add(<span class="string">"Google"</span>)</span><br><span class="line">    add(<span class="string">"Inc."</span>)</span><br><span class="line">    add(<span class="number">17</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在布局文件中，允许List使用角标进行索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type&#x3D;&quot;android.databinding.ObservableList&quot;&#x2F;&gt;</span><br><span class="line">    &lt;import type&#x3D;&quot;com.example.my.app.Fields&quot;&#x2F;&gt;</span><br><span class="line">    &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;ObservableList&lt;Object&gt;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;data&gt;</span><br><span class="line">…</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:text&#x3D;&#39;@&#123;user[Fields.LAST_NAME]&#125;&#39;</span><br><span class="line">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:text&#x3D;&#39;@&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;&#39;</span><br><span class="line">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h4>
<blockquote>
<p>实现 <a href="https://developer.android.com/reference/androidx/databinding/Observable" target="_blank" rel="noopener"><code>Observable</code></a> 接口的类允许注册监听器，以便它们接收有关可观察对象的属性更改的通知。</p>
</blockquote>
<p>Observable 接口具有添加和移除监听器的机制，但何时发送通知则必须由您决定。</p>
<p>为便于开发，数据绑定库提供了用于实现监听器注册机制的 BaseObservable 类。实现 BaseObservable 的数据类负责在属性更改时发出通知。具体操作过程是向 getter 分配 Bindable 注释，然后在 setter 中调用 notifyPropertyChanged() 方法，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> : <span class="type">BaseObservable</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Bindable</span></span><br><span class="line">    <span class="keyword">var</span> firstName: String = <span class="string">""</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            notifyPropertyChanged(BR.firstName)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Bindable</span></span><br><span class="line">    <span class="keyword">var</span> lastName: String = <span class="string">""</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            notifyPropertyChanged(BR.lastName)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数据绑定在模块包中生成一个名为 BR 的类，该类包含用于数据绑定的资源的 ID。在编译期间，Bindable 注释会在 BR 类文件中生成一个条目。如果数据类的基类无法更改，则 Observable 接口可以使用 PropertyChangeRegistry 对象实现，以便有效地注册和通知监听器。</p>
</blockquote>
<h3 id="生成的绑定类"><a class="markdownIt-Anchor" href="#生成的绑定类"></a> 生成的绑定类</h3>
<blockquote>
<p>生成的绑定类将布局变量与布局中的视图关联起来。绑定类的名称和包可以自定义。所有生成的绑定类都是从 ViewDataBinding 类继承而来的。</p>
</blockquote>
<h4 id="创建绑定对象"><a class="markdownIt-Anchor" href="#创建绑定对象"></a> 创建绑定对象</h4>
<p>在对布局进行扩充后，应尽快创建绑定对象，以确保视图层次结构在通过表达式与布局内的视图绑定之前不会被修改。</p>
<p>将对象绑定到布局的最常用方法是在绑定类上使用静态方法。使用绑定类的 <code>inflate()</code> 方法来扩充视图层次结构并将对象绑定到该层次结构，如以下示例所示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> binding: MyLayoutBinding = MyLayoutBinding.inflate(layoutInflater)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inflate() 方法还有另外一个版本，这个版本不仅使用 LayoutInflater 对象，还使用 ViewGroup 对象，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> binding: MyLayoutBinding = MyLayoutBinding.inflate(getLayoutInflater(), viewGroup, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>如果布局是使用其他机制扩充的，可单独绑定，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> viewRoot = LayoutInflater.from(<span class="keyword">this</span>).inflate(layoutId, parent, attachToParent)</span><br><span class="line"><span class="keyword">val</span> binding: ViewDataBinding? = DataBindingUtil.bind(viewRoot)</span><br></pre></td></tr></table></figure>
<p><strong>如果您要在 Fragment、ListView 或 RecyclerView 适配器中使用数据绑定项，您可能更愿意使用绑定类的 inflate() 方法或 DataBindingUtil 类</strong>，如以下代码示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">val</span> listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<h4 id="带id的视图"><a class="markdownIt-Anchor" href="#带id的视图"></a> 带ID的视图</h4>
<p>数据绑定库会针对布局中具有 ID 的每个视图在绑定类中创建不可变字段。例如，数据绑定库会根据以下布局创建 <code>TextView</code> 类型的 <code>firstName</code> 和 <code>lastName</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">       &lt;data&gt;</span><br><span class="line">           &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;data&gt;</span><br><span class="line">       &lt;LinearLayout</span><br><span class="line">           android:orientation&#x3D;&quot;vertical&quot;</span><br><span class="line">           android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">           android:layout_height&#x3D;&quot;match_parent&quot;&gt;</span><br><span class="line">           &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">               android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">               android:text&#x3D;&quot;@&#123;user.firstName&#125;&quot;</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;firstName&quot;&#x2F;&gt;</span><br><span class="line">           &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">               android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">               android:text&#x3D;&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">      android:id&#x3D;&quot;@+id&#x2F;lastName&quot;&#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;LinearLayout&gt;</span><br><span class="line">    &lt;&#x2F;layout&gt;</span><br></pre></td></tr></table></figure>
<p>该库一次性从视图层次结构中提取包含 ID 的视图。相较于针对布局中的每个视图调用 <code>findViewById()</code> 方法，这种机制速度更快。</p>
<h4 id="变量-2"><a class="markdownIt-Anchor" href="#变量-2"></a> 变量</h4>
<p>数据绑定库为布局中声明的每个变量生成访问器方法。例如，以下布局在绑定类中针对 <code>user</code>、<code>image</code> 和 <code>note</code> 变量生成了 setter 和 getter 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">     &lt;import type&#x3D;&quot;android.graphics.drawable.Drawable&quot;&#x2F;&gt;</span><br><span class="line">     &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">     &lt;variable name&#x3D;&quot;image&quot; type&#x3D;&quot;Drawable&quot;&#x2F;&gt;</span><br><span class="line">     &lt;variable name&#x3D;&quot;note&quot; type&#x3D;&quot;String&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;data&gt;</span><br></pre></td></tr></table></figure>
<h4 id="viewstubs"><a class="markdownIt-Anchor" href="#viewstubs"></a> ViewStubs</h4>
<blockquote>
<p>与普通视图不同，<code>ViewStub</code> 对象初始是一个不可见视图。当它们显示出来或者获得明确指示进行扩充时，它们会通过扩充另一个布局在布局中完成自我取代。</p>
<p>由于 <code>ViewStub</code> 实际上会从视图层次结构中消失，因此绑定对象中的视图也必须消失，才能通过垃圾回收进行回收。由于视图是最终结果，因此 <a href="https://developer.android.com/reference/androidx/databinding/ViewStubProxy" target="_blank" rel="noopener"><code>ViewStubProxy</code></a> 对象将取代生成的绑定类中的 <code>ViewStub</code>，让您能够访问 <code>ViewStub</code>（如果存在），同时还能访问 <code>ViewStub</code> 进行扩充后的扩充版视图层次结构。</p>
<p>在扩充其他布局时，必须为新布局建立绑定。因此，<code>ViewStubProxy</code> 必须监听 <code>ViewStub</code> <code>OnInflateListener</code> 并在必要时建立绑定。由于在给定时间只能有一个监听器，因此 <code>ViewStubProxy</code> 允许您设置 <code>OnInflateListener</code>，它将在建立绑定后调用这个监听器。</p>
</blockquote>
<h4 id="即时绑定"><a class="markdownIt-Anchor" href="#即时绑定"></a> 即时绑定</h4>
<blockquote>
<p>当可变或可观察对象发生更改时，绑定会按照计划在下一帧之前发生更改。但有时必须立即执行绑定。要强制执行，请使用 <a href="https://developer.android.com/reference/androidx/databinding/ViewDataBinding#executePendingBindings()" target="_blank" rel="noopener"><code>executePendingBindings()</code></a> 方法。</p>
</blockquote>
<h4 id="高级绑定"><a class="markdownIt-Anchor" href="#高级绑定"></a> 高级绑定</h4>
<h5 id="动态变量"><a class="markdownIt-Anchor" href="#动态变量"></a> 动态变量</h5>
<p>有时，系统并不知道特定的绑定类。例如，针对任意布局运行的 <code>RecyclerView.Adapter</code> 不知道特定绑定类。在调用 <code>onBindViewHolder()</code> 方法时，仍必须指定绑定值。</p>
<p>在以下示例中，<code>RecyclerView</code> 绑定到的所有布局都有 <code>item</code> 变量。<code>BindingHolder</code> 对象具有一个 <code>getBinding()</code> 方法，这个方法返回 <a href="https://developer.android.com/reference/androidx/databinding/ViewDataBinding" target="_blank" rel="noopener"><code>ViewDataBinding</code></a> 基类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">BindingHolder</span>, position: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    item: T = items.<span class="keyword">get</span>(position)</span><br><span class="line">    holder.binding.setVariable(BR.item, item);</span><br><span class="line">    holder.binding.executePendingBindings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：数据绑定库在模块包中生成一个名为 <code>BR</code> 的类，其中包含用于数据绑定的资源的 ID。在上例中，该库自动生成 <code>BR.item</code> 变量。</p>
</blockquote>
<h4 id="后台线程"><a class="markdownIt-Anchor" href="#后台线程"></a> 后台线程</h4>
<blockquote>
<p>可以在后台线程中更改数据模型，但前提是这个模型不是集合。数据绑定会在求值过程中对每个变量/字段进行本地化，以避免出现并发问题。</p>
</blockquote>
<h4 id="自定义绑定类名称"><a class="markdownIt-Anchor" href="#自定义绑定类名称"></a> 自定义绑定类名称</h4>
<p>默认情况下，绑定类是根据布局文件的名称生成的，以大写字母开头，移除下划线 ( _ )，将后一个字母大写，最后添加后缀 <strong>Binding</strong>。该类位于模块包下的 <code>databinding</code> 包中。例如，布局文件 <code>contact_item.xml</code> 会生成 <code>ContactItemBinding</code> 类。如果模块包是 <code>com.example.my.app</code>，则绑定类放在 <code>com.example.my.app.databinding</code> 包中。</p>
<p>通过调整 <code>data</code> 元素的 <code>class</code> 特性，绑定类可重命名或放置在不同的包中。例如，以下布局在当前模块的 <code>databinding</code> 包中生成 <code>ContactItem</code> 绑定类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">data</span> <span class="class"><span class="keyword">class</span>="<span class="title">ContactItem</span>"&gt;</span></span><br><span class="line">        …</span><br><span class="line">    &lt;/<span class="keyword">data</span>&gt;</span><br></pre></td></tr></table></figure>
<p>您可以在类名前添加句点和前缀，从而在其他文件包中生成绑定类。以下示例在模块包中生成绑定类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">data</span> <span class="class"><span class="keyword">class</span>=".<span class="title">ContactItem</span>"&gt;</span></span><br><span class="line">        …</span><br><span class="line">&lt;/<span class="keyword">data</span>&gt;</span><br></pre></td></tr></table></figure>
<p>您还可以使用完整软件包名称来生成绑定类。以下示例在 <code>com.example</code> 包中创建 <code>ContactItem</code> 绑定类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">data</span> <span class="class"><span class="keyword">class</span>="<span class="title">com</span>.<span class="title">example</span>.<span class="title">ContactItem</span>"&gt;</span></span><br><span class="line">        …</span><br><span class="line">&lt;/<span class="keyword">data</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="绑定适配器"><a class="markdownIt-Anchor" href="#绑定适配器"></a> 绑定适配器</h3>
<blockquote>
<p>绑定适配器负责发出相应的框架调用来设置值。例如，设置属性值就像调用 <code>setText()</code> 方法一样。再比如，设置事件监听器就像调用 <code>setOnClickListener()</code> 方法。</p>
<p>数据绑定库允许您通过使用适配器指定为设置值而调用的方法、提供您自己的绑定逻辑，以及指定返回对象的类型。</p>
</blockquote>
<h4 id="设置属性值"><a class="markdownIt-Anchor" href="#设置属性值"></a> 设置属性值</h4>
<blockquote>
<p>只要绑定值发生更改，生成的绑定类就必须使用绑定表达式在视图上调用 setter 方法。您可以允许数据绑定库自动确定方法、显式声明方法或提供选择方法的自定义逻辑。</p>
</blockquote>
<h5 id="自动选择方法"><a class="markdownIt-Anchor" href="#自动选择方法"></a> 自动选择方法</h5>
<h5 id="指定自定义方法名称"><a class="markdownIt-Anchor" href="#指定自定义方法名称"></a> 指定自定义方法名称</h5>
<p>某些特性拥有名称不符的 setter。在这些情况下，某个特性可能会使用 <a href="https://developer.android.com/reference/androidx/databinding/BindingMethods" target="_blank" rel="noopener"><code>BindingMethods</code></a> 注释与 setter 相关联。</p>
<p>注释与类一起使用，可以包含多个 <a href="https://developer.android.com/reference/androidx/databinding/BindingMethod" target="_blank" rel="noopener"><code>BindingMethod</code></a> 注释，每个注释对应一个重命名的方法。绑定方法是可添加到应用中任何类的注释。</p>
<p>在以下示例中，<code>android:tint</code> 特性与 <code>setImageTintList(ColorStateList)</code> 方法相关联，而不与 <code>setTint()</code> 方法相关联：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingMethods(value = [</span></span><br><span class="line"><span class="meta">    BindingMethod(</span></span><br><span class="line"><span class="meta">        type = android.widget.ImageView::class,</span></span><br><span class="line"><span class="meta">        attribute = <span class="meta-string">"android:tint"</span>,</span></span><br><span class="line"><span class="meta">        method = <span class="meta-string">"setImageTintList"</span>)</span>])</span><br></pre></td></tr></table></figure>
<h5 id="提供自定义逻辑"><a class="markdownIt-Anchor" href="#提供自定义逻辑"></a> 提供自定义逻辑</h5>
<p>__某些特性需要自定义绑定逻辑。__例如，<code>android:paddingLeft</code> 特性没有关联的 setter，而是提供了 <code>setPadding(left, top, right, bottom)</code> 方法。使用 <a href="https://developer.android.com/reference/androidx/databinding/BindingAdapter" target="_blank" rel="noopener"><code>BindingAdapter</code></a> 注释的静态绑定适配器方法支持自定义特性 setter 的调用方式。</p>
<p>Android 框架类的特性已经创建了 <code>BindingAdapter</code> 注释。例如，以下示例展示了 <code>paddingLeft</code> 特性的绑定适配器：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"android:paddingLeft"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setPaddingLeft</span><span class="params">(view: <span class="type">View</span>, padding: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    view.setPadding(padding,</span><br><span class="line">                view.getPaddingTop(),</span><br><span class="line">                view.getPaddingRight(),</span><br><span class="line">                view.getPaddingBottom())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数用于确定与特性关联的视图类型；第二个参数用于确定在给定特性的绑定表达式中接受的类型。</p>
</blockquote>
<p>绑定适配器对其他类型的自定义很有用。例如，可以通过工作器线程调用自定义加载程序来加载图片。</p>
<p><strong>出现冲突时，您定义的绑定适配器会替换由 Android 框架提供的默认适配器。</strong></p>
<p>您还可以使用接收多个特性的适配器，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"imageUrl"</span>, <span class="meta-string">"error"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loadImage</span><span class="params">(view: <span class="type">ImageView</span>, url: <span class="type">String</span>, error: <span class="type">Drawable</span>)</span></span> &#123;</span><br><span class="line">    Picasso.<span class="keyword">get</span>().load(url).error(error).into(view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在布局中使用适配器，如以下示例所示。请注意，<code>@drawable/venueError</code> 引用应用中的资源。使用 <code>@{}</code> 将资源括起来可使其成为有效的绑定表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ImageView </span><br><span class="line">	app:imageUrl&#x3D;&quot;@&#123;venue.imageUrl&#125;&quot; </span><br><span class="line">	app:error&#x3D;&quot;@&#123;@drawable&#x2F;venueError&#125;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：数据绑定库在匹配时会忽略自定义命名空间。</p>
<p>如果 <code>ImageView</code> 对象同时使用了 <code>imageUrl</code> 和 <code>error</code>，并且 <code>imageUrl</code> 是字符串，<code>error</code> 是 <code>Drawable</code>，则会调用适配器。</p>
<p>如果您希望在设置了任意特性时调用适配器，则可以将适配器的可选 <a href="https://developer.android.com/reference/androidx/databinding/BindingAdapter#requireAll()" target="_blank" rel="noopener"><code>requireAll</code></a> 标记设置为 <code>false</code>，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(value = [<span class="meta-string">"imageUrl"</span>, <span class="meta-string">"placeholder"</span>], requireAll = false)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setImageUrl</span><span class="params">(imageView: <span class="type">ImageView</span>, url: <span class="type">String</span>?, placeHolder: <span class="type">Drawable</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">        imageView.setImageDrawable(placeholder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MyImageLoader.loadInto(imageView, url, placeholder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：出现冲突时，绑定适配器会替换默认的数据绑定适配器。</p>
<p>绑定适配器方法可以选择性在处理程序中使用旧值。同时采用旧值和新值的方法应该先为特性声明所有旧值，然后再声明新值，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"android:paddingLeft"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setPaddingLeft</span><span class="params">(view: <span class="type">View</span>, oldPadding: <span class="type">Int</span>, newPadding: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldPadding != newPadding) &#123;</span><br><span class="line">        view.setPadding(padding,</span><br><span class="line">                    view.getPaddingTop(),</span><br><span class="line">                    view.getPaddingRight(),</span><br><span class="line">                    view.getPaddingBottom())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件处理程序只能与具有一种抽象方法的接口或抽象类一起使用，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"android:onLayoutChange"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnLayoutChangeListener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        view: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        oldValue: <span class="type">View</span>.<span class="type">OnLayoutChangeListener</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        newValue: <span class="type">View</span>.<span class="type">OnLayoutChangeListener</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.removeOnLayoutChangeListener(oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.addOnLayoutChangeListener(newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按如下所示在布局中使用此事件处理脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View </span><br><span class="line">		android:onLayoutChange&#x3D;&quot;@&#123;() -&gt; handler.layoutChanged()&#125;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>__当监听器有多个方法时，必须将它拆分为多个监听器。__例如，<code>View.OnAttachStateChangeListener</code> 有两个方法：<code>onViewAttachedToWindow(View)</code> 和 <code>onViewDetachedFromWindow(View)</code>。该库提供了两个接口，用于区分它们的特性和处理脚本：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Translation from provided interfaces in Java:</span></span><br><span class="line"><span class="meta">@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnViewDetachedFromWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnViewAttachedToWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为更改一个监听器也会影响另一个监听器，所以需要适用于其中一个特性或同时适用于这两个特性的适配器。您可以在注释中将 <a href="https://developer.android.com/reference/androidx/databinding/BindingAdapter#requireAll()" target="_blank" rel="noopener"><code>requireAll</code></a> 设置为 <code>false</code>，以指定并非必须为每个特性都分配绑定表达式，如以下示例所示：</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"android:onViewDetachedFromWindow"</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"android:onViewAttachedToWindow"</span>,</span></span><br><span class="line"><span class="meta">        requireAll = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setListener</span><span class="params">(view: <span class="type">View</span>, detach: <span class="type">OnViewDetachedFromWindow</span>?, attach: <span class="type">OnViewAttachedToWindow</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        <span class="keyword">val</span> newListener: View.OnAttachStateChangeListener?</span><br><span class="line">        newListener = <span class="keyword">if</span> (detach == <span class="literal">null</span> &amp;&amp; attach == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">object</span> : View.OnAttachStateChangeListener &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">                    attach.onViewAttachedToWindow(v)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">                    detach.onViewDetachedFromWindow(v)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> oldListener: View.OnAttachStateChangeListener? =</span><br><span class="line">                ListenerUtil.trackListener(view, newListener, R.id.onAttachStateChangeListener)</span><br><span class="line">        <span class="keyword">if</span> (oldListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(oldListener)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(newListener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上示例比一般情况稍微复杂一些，因为 <code>View</code> 类使用 <code>addOnAttachStateChangeListener()</code> 和 <code>removeOnAttachStateChangeListener()</code> 方法，而非 <code>OnAttachStateChangeListener</code> 的 setter 方法。<code>android.databinding.adapters.ListenerUtil</code> 类有助于跟踪以前的监听器，以便在绑定适配器中将它们移除。</p>
<p>通过用 <code>@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</code> 注释接口 <code>OnViewDetachedFromWindow</code> 和 <code>OnViewAttachedToWindow</code>，数据绑定代码生成器知道只应在运行 Android 3.1（API 级别 12）及更高级别（<code>addOnAttachStateChangeListener()</code> 方法支持的相同版本）时生成监听器。</p>
</blockquote>
<h4 id="对象转换"><a class="markdownIt-Anchor" href="#对象转换"></a> 对象转换</h4>
<h5 id="自动对象转换"><a class="markdownIt-Anchor" href="#自动对象转换"></a> 自动对象转换</h5>
<p><strong>当绑定表达式返回 <code>Object</code> 时，库会选择用于设置属性值的方法。</strong><code>Object</code> 会转换为所选方法的参数类型。对于使用 <a href="https://developer.android.com/reference/androidx/databinding/ObservableMap" target="_blank" rel="noopener"><code>ObservableMap</code></a> 类存储数据的应用，这种行为非常便捷，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">       android:text&#x3D;&#39;@&#123;userMap[&quot;lastName&quot;]&#125;&#39;</span><br><span class="line">       android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;wrap_content&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：您还可以使用 <code>object.key</code> 表示法引用映射中的值。例如，以上示例中的 <code>@{userMap[&quot;lastName&quot;]}</code> 可替换为 <code>@{userMap.lastName}</code>。</p>
<blockquote>
<p>表达式中的 <code>userMap</code> 对象会返回一个值，该值会自动转换为用于设置 <code>android:text</code> 属性值的 <code>setText(CharSequence)</code> 方法中的参数类型。如果参数类型不明确，则必须在表达式中强制转换返回类型。</p>
</blockquote>
<h5 id="自定义转换"><a class="markdownIt-Anchor" href="#自定义转换"></a> 自定义转换</h5>
<p>在某些情况下，需要在特定类型之间进行自定义转换。</p>
<p>例如，视图的 <code>android:background</code> 特性需要 <code>Drawable</code>，但指定的 <code>color</code> 值是整数。以下示例展示了某个特性需要 <code>Drawable</code>，但结果提供了一个整数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">       android:background&#x3D;&quot;@&#123;isError ? @color&#x2F;red : @color&#x2F;white&#125;&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>每当需要 <code>Drawable</code> 且返回整数时，<code>int</code> 都应转换为 <code>ColorDrawable</code>。您可以使用带有 <a href="https://developer.android.com/reference/androidx/databinding/BindingConversion" target="_blank" rel="noopener"><code>BindingConversion</code></a> 注释的静态方法完成这个转换，如下所示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingConversion</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">convertColorToDrawable</span><span class="params">(color: <span class="type">Int</span>)</span></span> = ColorDrawable(color)</span><br></pre></td></tr></table></figure>
<p>但是，__绑定表达式中提供的值类型必须保持一致。__您不能在同一个表达式中使用不同的类型，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">       android:background&#x3D;&quot;@&#123;isError ? @drawable&#x2F;error : @color&#x2F;white&#125;&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="将布局视图绑定到架构组件-2"><a class="markdownIt-Anchor" href="#将布局视图绑定到架构组件-2"></a> 将布局视图绑定到架构组件</h3>
<h4 id="使用livedata将数据变化通知给页面"><a class="markdownIt-Anchor" href="#使用livedata将数据变化通知给页面"></a> 使用LiveData将数据变化通知给页面</h4>
<blockquote>
<p>与实现 <a href="https://developer.android.com/reference/androidx/databinding/Observable" target="_blank" rel="noopener"><code>Observable</code></a> 的对象（例如<a href="https://developer.android.com/topic/libraries/data-binding/observability#observable_fields" target="_blank" rel="noopener">可观察字段</a>）不同，<code>LiveData</code> 对象了解订阅数据更改的观察器的生命周期。</p>
</blockquote>
<p>要将 <code>LiveData</code> 对象与绑定类一起使用，<strong>需要指定生命周期所有者来定义 对象的范围。</strong></p>
<p>以下示例在绑定类实例化后将 Activity 指定为生命周期所有者：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Inflate view and obtain an instance of the binding class.</span></span><br><span class="line">        <span class="keyword">val</span> binding: UserBinding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Specify the current activity as the lifecycle owner.</span></span><br><span class="line">        binding.setLifecycleOwner(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以根据使用 ViewModel 管理界面相关数据中所述，使用 ViewModel 组件来将数据绑定到布局。在 ViewModel 组件中，您可以使用 LiveData 对象转换数据或合并多个数据源。</p>
<p>以下示例展示了如何在 ViewModel 中转换数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScheduleViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> userName: LiveData</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> result = Repository.userName</span><br><span class="line">        userName = Transformations.map(result) &#123; result -&gt; result.value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用viewmodel管理界面相关数据"><a class="markdownIt-Anchor" href="#使用viewmodel管理界面相关数据"></a> 使用ViewModel管理界面相关数据</h4>
<p>要将 <code>ViewModel</code> 组件与数据绑定库一起使用，必须实例化从 类继承而来的组件，获取绑定类的实例，并将您的 组件分配给绑定类中的属性。</p>
<p>以下示例展示了如何将组件与库结合使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Obtain the ViewModel component.</span></span><br><span class="line">        UserModel userModel = ViewModelProviders.of(getActivity())</span><br><span class="line">                                                  .<span class="keyword">get</span>(UserModel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Inflate view and obtain an instance of the binding class.</span></span><br><span class="line">        <span class="keyword">val</span> binding: UserBinding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assign the component to a property in the binding class.</span></span><br><span class="line">        binding.viewmodel = userModel</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在布局中，使用绑定表达式将 <code>ViewModel</code> 组件的属性和方法分配给对应的视图，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;CheckBox</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;rememberMeCheckBox&quot;</span><br><span class="line">        android:checked&#x3D;&quot;@&#123;viewmodel.rememberMe&#125;&quot;</span><br><span class="line">        android:onCheckedChanged&#x3D;&quot;@&#123;() -&gt; viewmodel.rememberMeChanged()&#125;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用observable-viewmodel以更好地控制绑定适配器"><a class="markdownIt-Anchor" href="#使用observable-viewmodel以更好地控制绑定适配器"></a> 使用Observable ViewModel以更好地控制绑定适配器</h4>
<blockquote>
<p>使用实现 <code>Observable</code> 的 <code>ViewModel</code> 组件可让您更好地控制应用中的绑定适配器。例如，这种模式可让您更多地控制数据更改时的通知，您还可以指定自定义方法来设置双向数据绑定中的属性值。</p>
</blockquote>
<p>要实现可观察的 <code>ViewModel</code> 组件，您必须创建一个从 类继承而来并实现 <a href="https://developer.android.com/reference/androidx/databinding/Observable" target="_blank" rel="noopener"><code>Observable</code></a> 接口的类。您可以使用 <a href="https://developer.android.com/reference/androidx/databinding/Observable#addOnPropertyChangedCallback(android.databinding.Observable.OnPropertyChangedCallback)" target="_blank" rel="noopener"><code>addOnPropertyChangedCallback()</code></a> 和 <a href="https://developer.android.com/reference/androidx/databinding/Observable#removeOnPropertyChangedCallback(android.databinding.Observable.OnPropertyChangedCallback)" target="_blank" rel="noopener"><code>removeOnPropertyChangedCallback()</code></a> 方法提供观察器订阅或取消订阅通知时的自定义逻辑。您还可以在 <a href="https://developer.android.com/reference/androidx/databinding/BaseObservable#notifyPropertyChanged(int)" target="_blank" rel="noopener"><code>notifyPropertyChanged()</code></a> 方法中提供属性更改时运行的自定义逻辑。以下代码示例展示了如何实现一个可观察的 <code>ViewModel</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A ViewModel that is also an Observable,</span></span><br><span class="line"><span class="comment"> * to be used with the Data Binding Library.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableViewModel</span> : <span class="type">ViewModel</span></span>(), Observable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> callbacks: PropertyChangeRegistry = PropertyChangeRegistry()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addOnPropertyChangedCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            callback: <span class="type">Observable</span>.<span class="type">OnPropertyChangedCallback</span>)</span></span> &#123;</span><br><span class="line">        callbacks.add(callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeOnPropertyChangedCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            callback: <span class="type">Observable</span>.<span class="type">OnPropertyChangedCallback</span>)</span></span> &#123;</span><br><span class="line">        callbacks.remove(callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies observers that all properties of this instance have changed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">notifyChange</span><span class="params">()</span></span> &#123;</span><br><span class="line">        callbacks.notifyCallbacks(<span class="keyword">this</span>, <span class="number">0</span>, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies observers that a specific property has changed. The getter for the</span></span><br><span class="line"><span class="comment">     * property that changes should be marked with the <span class="doctag">@Bindable</span> annotation to</span></span><br><span class="line"><span class="comment">     * generate a field in the BR class to be used as the fieldId parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldId The generated BR id for the Bindable field.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">notifyPropertyChanged</span><span class="params">(fieldId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        callbacks.notifyCallbacks(<span class="keyword">this</span>, fieldId, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向数据绑定-2"><a class="markdownIt-Anchor" href="#双向数据绑定-2"></a> 双向数据绑定</h3>
<p>使用单向数据绑定，您可以为特性设置值，并设置对该特性更改作出反应的监听器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/rememberMeCheckBox"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:checked</span>=<span class="string">"@&#123;viewmodel.rememberMe&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onCheckedChanged</span>=<span class="string">"@&#123;viewmodel.rememberMeChanged&#125;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p>双向数据绑定为此过程提供了一个快捷方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/rememberMeCheckBox"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:checked</span>=<span class="string">"@=&#123;viewmodel.rememberMe&#125;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><code>@={}</code></strong> 表示法接收属性的数据更改并同时监听用户更新，其中重要的是包含“=”符号。</p>
<p>为了应对后备数据的更改，您可以将您的布局变量设置为 <code>Observable</code>（通常为 <a href="https://developer.android.com/reference/androidx/databinding/BaseObservable" target="_blank" rel="noopener"><code>BaseObservable</code></a>）的实现，并使用 <a href="https://developer.android.com/reference/androidx/databinding/Bindable" target="_blank" rel="noopener"><code>@Bindable</code></a> 注释，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginViewModel</span> : <span class="type">BaseObservable &#123;</span></span></span><br><span class="line">    <span class="comment">// val data = ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRememberMe</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>.rememberMe</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setRememberMe</span><span class="params">(value: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Avoids infinite loops.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">data</span>.rememberMe != value) &#123;</span><br><span class="line">            <span class="keyword">data</span>.rememberMe = value</span><br><span class="line"></span><br><span class="line">            <span class="comment">// React to the change.</span></span><br><span class="line">            saveData()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Notify observers of a new value.</span></span><br><span class="line">            notifyPropertyChanged(BR.remember_me)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用自定义特性的双向数据绑定"><a class="markdownIt-Anchor" href="#使用自定义特性的双向数据绑定"></a> 使用自定义特性的双向数据绑定</h4>
<p>如果您希望结合使用双向数据绑定和自定义特性，则需要使用 <a href="https://developer.android.com/reference/androidx/databinding/InverseBindingAdapter" target="_blank" rel="noopener"><code>@InverseBindingAdapter</code></a> 和 <a href="https://developer.android.com/reference/androidx/databinding/InverseBindingMethod" target="_blank" rel="noopener"><code>@InverseBindingMethod</code></a> 注释。</p>
<p>例如，如果要在名为 <code>MyView</code> 的自定义视图中对 <code>&quot;time&quot;</code> 特性启用双向数据绑定，请完成以下步骤：</p>
<ol>
<li>
<p>使用 <code>@BindingAdapter</code>，对用来设置初始值并在值更改时进行更新的方法进行注释：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"time"</span>)</span></span><br><span class="line"><span class="meta">@JvmStatic</span> <span class="function"><span class="keyword">fun</span> <span class="title">setTime</span><span class="params">(view: <span class="type">MyView</span>, newValue: <span class="type">Time</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Important to break potential infinite loops.</span></span><br><span class="line">    <span class="keyword">if</span> (view.time != newValue) &#123;</span><br><span class="line">        view.time = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>@InverseBindingAdapter</code> 对从视图中读取值的方法进行注释：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InverseBindingAdapter(<span class="meta-string">"time"</span>)</span></span><br><span class="line"><span class="meta">@JvmStatic</span> <span class="function"><span class="keyword">fun</span> <span class="title">getTime</span><span class="params">(view: <span class="type">MyView</span>)</span></span> : Time &#123;</span><br><span class="line">    <span class="keyword">return</span> view.getTime()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时，数据绑定知道在数据发生更改时要执行的操作（调用使用 <a href="https://developer.android.com/reference/androidx/databinding/BindingAdapter" target="_blank" rel="noopener"><code>@BindingAdapter</code></a> 注释的方法）以及当 view 视特性发生更改时要调用的内容（调用 <a href="https://developer.android.com/reference/androidx/databinding/InverseBindingListener" target="_blank" rel="noopener"><code>InverseBindingListener</code></a>）。但是，它不知道特性何时或如何更改。</p>
</blockquote>
<p>为此，您需要在视图上设置监听器。这可以是与您的自定义视图相关联的自定义监听器，也可以是通用事件，例如失去焦点或文本更改。将 <code>@BindingAdapter</code> 注释添加到设置监听器（用来监听属性更改）的方法中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"app:timeAttrChanged"</span>)</span></span><br><span class="line"><span class="meta">@JvmStatic</span> <span class="function"><span class="keyword">fun</span> <span class="title">setListeners</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        view: <span class="type">MyView</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        attrChange: <span class="type">InverseBindingListener</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Set a listener for click, focus, touch, etc.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该监听器包含一个 <code>InverseBindingListener</code> 参数。您可以使用 <code>InverseBindingListener</code> 告知数据绑定系统，特性已更改。然后，该系统可以开始调用使用 <code>@InverseBindingAdapter</code> 注释的方法，依此类推。</p>
</blockquote>
<p><strong>注意</strong>：每个双向绑定都会生成“合成事件特性”。该特性与基本特性具有相同的名称，但包含后缀 <code>&quot;AttrChanged&quot;</code>。合成事件特性允许库创建使用 <code>@BindingAdapter</code> 注释的方法，以将事件监听器与相应的 <code>View</code> 实例相关联。</p>
</li>
</ol>
<h4 id="转换器"><a class="markdownIt-Anchor" href="#转换器"></a> 转换器</h4>
<p>如果绑定到 <a href="https://developer.android.com/reference/android/view/View" target="_blank" rel="noopener"><code>View</code></a> 对象的变量需要设置格式、转换或更改后才能显示，则可以使用 <code>Converter</code> 对象。</p>
<p>以显示日期的 <code>EditText</code> 对象为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/birth_date"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@=&#123;Converter.dateToString(viewmodel.birthDate)&#125;"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>viewmodel.birthDate</code> 属性包含 <code>Long</code> 类型的值，因此需要使用转换器设置格式。</p>
</blockquote>
<p>由于使用了双向表达式，因此还需要使用反向转换器，以告知库如何将用户提供的字符串转换回后备数据类型（在本例中为 <code>Long</code>）。此过程是通过向其中一个转换器添加 <a href="https://developer.android.com/reference/androidx/databinding/InverseMethod" target="_blank" rel="noopener"><code>@InverseMethod</code></a> 注释并让此注释引用反向转换器来完成的。以下代码段显示了此配置的一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Converter &#123;</span><br><span class="line">    <span class="meta">@InverseMethod(<span class="meta-string">"stringToDate"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dateToString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        view: <span class="type">EditText</span>, oldValue: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        value: <span class="type">Long</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: String &#123;</span><br><span class="line">        <span class="comment">// Converts long to String.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stringToDate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        view: <span class="type">EditText</span>, oldValue: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        value: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">        <span class="comment">// Converts String to long.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用双向数据绑定的无限循环"><a class="markdownIt-Anchor" href="#使用双向数据绑定的无限循环"></a> 使用双向数据绑定的无限循环</h4>
<blockquote>
<p>使用双向数据绑定时，请注意不要引入无限循环。当用户更改特性时，系统会调用使用 <code>@InverseBindingAdapter</code> 注释的方法，并且该值将分配给后备属性。继而调用使用 <code>@BindingAdapter</code> 注释的方法，从而触发对使用 <code>@InverseBindingAdapter</code> 注释的方法的另一个调用，依此类推。</p>
</blockquote>
<p>因此，<strong>通过比较使用 <code>@BindingAdapter</code> 注释的方法中的新值和旧值，可以打破可能出现的无限循环</strong></p>
<h4 id="双向特性"><a class="markdownIt-Anchor" href="#双向特性"></a> 双向特性</h4>
<p>当您使用下表中的特性时，该平台提供对双向数据绑定的内置支持。有关平台如何提供此类支持的详细信息，请参阅相应绑定适配器的实现：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类</th>
<th style="text-align:left">特性</th>
<th style="text-align:left">绑定适配器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/widget/AdapterView" target="_blank" rel="noopener"><code>AdapterView</code></a></td>
<td style="text-align:left"><code>android:selectedItemPosition</code> <code>android:selection</code></td>
<td style="text-align:left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/AdapterViewBindingAdapter.java" target="_blank" rel="noopener"><code>AdapterViewBindingAdapter</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/widget/CalendarView" target="_blank" rel="noopener"><code>CalendarView</code></a></td>
<td style="text-align:left"><code>android:date</code></td>
<td style="text-align:left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/CalendarViewBindingAdapter.java" target="_blank" rel="noopener"><code>CalendarViewBindingAdapter</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/widget/CompoundButton" target="_blank" rel="noopener"><code>CompoundButton</code></a></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/R.attr#checked" target="_blank" rel="noopener"><code>android:checked</code></a></td>
<td style="text-align:left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/CompoundButtonBindingAdapter.java" target="_blank" rel="noopener"><code>CompoundButtonBindingAdapter</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/widget/DatePicker" target="_blank" rel="noopener"><code>DatePicker</code></a></td>
<td style="text-align:left"><code>android:year</code> <code>android:month</code> <code>android:day</code></td>
<td style="text-align:left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/DatePickerBindingAdapter.java" target="_blank" rel="noopener"><code>DatePickerBindingAdapter</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/widget/NumberPicker" target="_blank" rel="noopener"><code>NumberPicker</code></a></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/R.attr#value" target="_blank" rel="noopener"><code>android:value</code></a></td>
<td style="text-align:left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/NumberPickerBindingAdapter.java" target="_blank" rel="noopener"><code>NumberPickerBindingAdapter</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/widget/RadioButton" target="_blank" rel="noopener"><code>RadioButton</code></a></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/R.attr#checkedButton" target="_blank" rel="noopener"><code>android:checkedButton</code></a></td>
<td style="text-align:left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/RadioGroupBindingAdapter.java" target="_blank" rel="noopener"><code>RadioGroupBindingAdapter</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/widget/RatingBar" target="_blank" rel="noopener"><code>RatingBar</code></a></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/R.attr#rating" target="_blank" rel="noopener"><code>android:rating</code></a></td>
<td style="text-align:left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/RatingBarBindingAdapter.java" target="_blank" rel="noopener"><code>RatingBarBindingAdapter</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/widget/SeekBar" target="_blank" rel="noopener"><code>SeekBar</code></a></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/R.attr#progress" target="_blank" rel="noopener"><code>android:progress</code></a></td>
<td style="text-align:left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/SeekBarBindingAdapter.java" target="_blank" rel="noopener"><code>SeekBarBindingAdapter</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/widget/TabHost" target="_blank" rel="noopener"><code>TabHost</code></a></td>
<td style="text-align:left"><code>android:currentTab</code></td>
<td style="text-align:left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/TabHostBindingAdapter.java" target="_blank" rel="noopener"><code>TabHostBindingAdapter</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/widget/TextView" target="_blank" rel="noopener"><code>TextView</code></a></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/R.attr#text" target="_blank" rel="noopener"><code>android:text</code></a></td>
<td style="text-align:left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/TextViewBindingAdapter.java" target="_blank" rel="noopener"><code>TextViewBindingAdapter</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/widget/TimePicker" target="_blank" rel="noopener"><code>TimePicker</code></a></td>
<td style="text-align:left"><code>android:hour</code> <code>android:minute</code></td>
<td style="text-align:left">[<code>TimePickerBindingAdapter</code>](</td>
</tr>
</tbody>
</table>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/3-%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9A/">3-视图绑定</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JetPack/">JetPack</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9A/">视图绑定</a></span><div class="content"><blockquote>
<p>在模块中启用视图绑定之后，系统会为该模块中的每个 XML 布局文件生成一个绑定类。绑定类的实例包含对在相应布局中具有 ID 的所有视图的直接引用（替代findViewById）。</p>
</blockquote>
<h1 id="1-启用"><a class="markdownIt-Anchor" href="#1-启用"></a> 1. 启用</h1>
<pre><code>## 1.1 可按模块启用。
</code></pre>
<p>要在某个模块中启用视图绑定，请将 <code>viewBinding</code> 元素添加到其 <code>build.gradle</code> 文件中</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">        ...</span><br><span class="line">        viewBinding &#123;</span><br><span class="line">            enabled = <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-在生成绑定类时忽略某个布局文件"><a class="markdownIt-Anchor" href="#12-在生成绑定类时忽略某个布局文件"></a> 1.2 在生成绑定类时忽略某个布局文件</h2>
<p>请将 <code>tools:viewBindingIgnore=&quot;true&quot;</code> 属性添加到相应布局文件的根视图中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:viewBindingIgnore</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>[TOC]</p>
<h1 id="2-用法"><a class="markdownIt-Anchor" href="#2-用法"></a> 2. 用法</h1>
<blockquote>
<p>为某个模块启用视图绑定功能后，系统会为该模块中包含的每个 XML 布局文件各生成一个绑定类。每个绑定类均包含对根视图以及具有 ID 的所有视图的引用。系统会通过以下方式生成绑定类的名称：<strong>将 XML 文件的名称转换为驼峰式大小写，并在末尾添加“Binding”一词</strong>。</p>
</blockquote>
<p>比如__result_profile.xml__</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">"@+id/name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">android:cropToPadding</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">"@+id/button"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"@drawable/rounded_button"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>生成的绑定类名为__ResultProfileBinding__</p>
<p>__ResultProfileBinding.inflate()__返回绑定类的实例</p>
<p>调用__setContentView()__，从而将该绑定类的根视图作为参数进行传递，以使它成为屏幕上的活动视图。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ResultProfileBinding</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//设置活动视图</span></span><br><span class="line">      binding = ResultProfileBinding.inflate(layoutInflater)</span><br><span class="line">      setContentView(binding.root)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>__Fragment绑定视图__示例:</p>
<p>布局文件layout/fragment_blank.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".InflateFragment"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/textViewFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/hello_blank_fragment"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>示例1（可选构造函数）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * View Binding example with a fragment that uses the alternate constructor for inflation and</span></span><br><span class="line"><span class="comment"> * [onViewCreated] for binding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindFragment</span> : <span class="type">Fragment</span></span>(R.layout.fragment_blank) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scoped to the lifecycle of the fragment's view (between onCreateView and onDestroyView)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> fragmentBlankBinding: FragmentBlankBinding? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> binding = FragmentBlankBinding.bind(view)</span><br><span class="line">        fragmentBlankBinding = binding</span><br><span class="line">        binding.textViewFragment.text = getString(string.hello_from_vb_bindfragment)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Consider not storing the binding instance in a field, if not needed.</span></span><br><span class="line">        fragmentBlankBinding = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例2（主构造函数）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * View Binding example with a fragment that uses the traditional constructor and [onCreateView] for</span></span><br><span class="line"><span class="comment"> * inflation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InflateFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scoped to the lifecycle of the fragment's view (between onCreateView and onDestroyView)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> fragmentBlankBinding: FragmentBlankBinding? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// Inflate the layout for this fragment</span></span><br><span class="line">        <span class="keyword">val</span> binding = FragmentBlankBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        fragmentBlankBinding = binding</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//binding.textViewFragment.text = getString(R.string.hello_from_vb_inflatefragment)</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Consider not storing the binding instance in a field, if not needed.</span></span><br><span class="line">        fragmentBlankBinding = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-与-findviewbyid-的区别"><a class="markdownIt-Anchor" href="#3-与-findviewbyid-的区别"></a> 3. 与 findViewById 的区别</h1>
<p>视图绑定具有一些很显著的优点：</p>
<ul>
<li><strong>Null 安全</strong>：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用 <code>@Nullable</code> 标记。</li>
<li><strong>类型安全</strong>：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。</li>
</ul>
<p>这些差异意味着布局和代码之间的不兼容性可能会导致编译版本在编译时（而非运行时）失败。</p>
<h1 id="4-与数据绑定库的区别"><a class="markdownIt-Anchor" href="#4-与数据绑定库的区别"></a> 4. 与数据绑定库的区别</h1>
<p>视图绑定和数据绑定库均会生成可用于直接引用视图的绑定类。不过，这两者之间存在明显差异：</p>
<ul>
<li>数据绑定库仅处理使用 <layout> 代码创建的数据绑定布局。</li>
<li>视图绑定不支持布局变量或布局表达式，因此它不能用于在 XML 中将布局与数据绑定。</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/2-%E5%90%91%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E7%BB%84%E4%BB%B6/">2-向项目添加组件</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JetPack/">JetPack</a></span><div class="content"><p>[TOC]</p>
<p>打开项目的 build.gradle 文件（而不是应用或模块的该文件）并添加 google() 代码库，如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="声明依赖项"><a class="markdownIt-Anchor" href="#声明依赖项"></a> 声明依赖项</h1>
<h2 id="futures可在-androidxconcurrent-中找到"><a class="markdownIt-Anchor" href="#futures可在-androidxconcurrent-中找到"></a> Futures（可在 androidx.concurrent 中找到）</h2>
<p>要添加 Futures 的依赖项，您必须将 Google Maven 代码库添加到项目中。请阅读 Google 的 Maven 代码库了解详情。</p>
<p>在顶级build.gradle文件中</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            google()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If you're using a version of Gradle lower than 4.1, you must instead use:</span></span><br><span class="line">            <span class="comment">// maven &#123;</span></span><br><span class="line">            <span class="comment">//     url 'https://maven.google.com'</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// An alternative URL is 'https://dl.google.com/dl/android/maven2/'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在应用或模块的 build.gradle 文件中添加所需工件的依赖项：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">"androidx.concurrent:concurrent-futures:1.0.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin</span></span><br><span class="line">    implementation <span class="string">"androidx.concurrent:concurrent-futures-ktx:1.1.0-alpha01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生命周期组件包括-viewmodel"><a class="markdownIt-Anchor" href="#生命周期组件包括-viewmodel"></a> 生命周期组件（包括 ViewModel）</h2>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> lifecycle_version = <span class="string">"2.2.0"</span></span><br><span class="line">    <span class="keyword">def</span> arch_version = <span class="string">"2.1.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewModel</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"</span></span><br><span class="line">    <span class="comment">// LiveData</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version"</span></span><br><span class="line">    <span class="comment">// Lifecycles only (without ViewModel or LiveData)</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Saved state module for ViewModel</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation processor</span></span><br><span class="line">    kapt <span class="string">"androidx.lifecycle:lifecycle-compiler:$lifecycle_version"</span></span><br><span class="line">    <span class="comment">// alternately - if using Java8, use the following instead of lifecycle-compiler</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-common-java8:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - ReactiveStreams support for LiveData</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-reactivestreams-ktx:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers for LiveData</span></span><br><span class="line">    testImplementation <span class="string">"androidx.arch.core:core-testing:$arch_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="导航包括-safeargs"><a class="markdownIt-Anchor" href="#导航包括-safeargs"></a> 导航（包括 SafeArgs）</h2>
<h3 id="导航"><a class="markdownIt-Anchor" href="#导航"></a> 导航</h3>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> nav_version = <span class="string">"2.3.0-alpha01"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java language implementation</span></span><br><span class="line">  implementation <span class="string">"androidx.navigation:navigation-fragment:$nav_version"</span></span><br><span class="line">  implementation <span class="string">"androidx.navigation:navigation-ui:$nav_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Kotlin</span></span><br><span class="line">  implementation <span class="string">"androidx.navigation:navigation-fragment-ktx:$nav_version"</span></span><br><span class="line">  implementation <span class="string">"androidx.navigation:navigation-ui-ktx:$nav_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dynamic Feature Module Support</span></span><br><span class="line">  implementation <span class="string">"androidx.navigation:navigation-dynamic-features-fragment:$nav_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Testing Navigation</span></span><br><span class="line">  androidTestImplementation <span class="string">"androidx.navigation:navigation-testing:$nav_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="safe-args"><a class="markdownIt-Anchor" href="#safe-args"></a> Safe Args</h3>
<p>在顶级 build.gradle 文件中包含以下 classpath</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="keyword">def</span> nav_version = <span class="string">"2.3.0-alpha01"</span></span><br><span class="line">        classpath <span class="string">"androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//For Java</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"androidx.navigation.safeargs"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//For kotlin</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"androidx.navigation.safeargs.kotlin"</span></span><br></pre></td></tr></table></figure>
<h2 id="paging"><a class="markdownIt-Anchor" href="#paging"></a> Paging</h2>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> paging_version = <span class="string">"2.1.1"</span></span><br><span class="line">			</span><br><span class="line">  <span class="comment">// For Kotlin use paging-runtime-ktx</span></span><br><span class="line">  implementation <span class="string">"androidx.paging:paging-runtime:$paging_version"</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">// alternatively - without Android dependencies for testing</span></span><br><span class="line">  <span class="comment">// For Kotlin use paging-common-ktx</span></span><br><span class="line">  testImplementation <span class="string">"androidx.paging:paging-common:$paging_version"</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - RxJava support</span></span><br><span class="line">  <span class="comment">// For Kotlin use paging-rxjava2-ktx</span></span><br><span class="line">  implementation <span class="string">"androidx.paging:paging-rxjava2:$paging_version"</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="room"><a class="markdownIt-Anchor" href="#room"></a> Room</h2>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> room_version = <span class="string">"2.2.3"</span></span><br><span class="line"></span><br><span class="line">  implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">  <span class="comment">// For Kotlin use kapt instead of annotationProcessor</span></span><br><span class="line">  annotationProcessor <span class="string">"androidx.room:room-compiler:$room_version"</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Kotlin Extensions and Coroutines support for Room</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-ktx:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - RxJava support for Room</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-guava:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test helpers</span></span><br><span class="line">  testImplementation <span class="string">"androidx.room:room-testing:$room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注：</p>
<blockquote>
<p>Room 具有以下注释处理器选项：</p>
<p>room.schemaLocation：配置并启用将数据库架构导出到给定目录中的 JSON 文件的功能。如需了解详情，请参阅 Room 迁移。<br />
room.incremental：启用 Gradle 增量注释处理器。<br />
room.expandProjection：配置 Room 以重新编写查询，使其顶部星形投影在展开后仅包含 DAO 方法返回类型中定义的列。</p>
</blockquote>
<p>示例如下</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [</span><br><span class="line">                    <span class="string">"room.schemaLocation"</span>:<span class="string">"$projectDir/schemas"</span>.toString(),</span><br><span class="line">                    <span class="string">"room.incremental"</span>:<span class="string">"true"</span>,</span><br><span class="line">                    <span class="string">"room.expandProjection"</span>:<span class="string">"true"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="workmanager"><a class="markdownIt-Anchor" href="#workmanager"></a> WorkManager</h2>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> work_version = <span class="string">"2.3.1"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (Java only)</span></span><br><span class="line">    implementation <span class="string">"androidx.work:work-runtime:$work_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin + coroutines</span></span><br><span class="line">    implementation <span class="string">"androidx.work:work-runtime-ktx:$work_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava2 support</span></span><br><span class="line">    implementation <span class="string">"androidx.work:work-rxjava2:$work_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - GCMNetworkManager support</span></span><br><span class="line">    implementation <span class="string">"androidx.work:work-gcm:$work_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers</span></span><br><span class="line">    androidTestImplementation <span class="string">"androidx.work:work-testing:$work_version"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/28/1-%E6%A6%82%E8%A7%88/">1-概览</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/JetPack/">JetPack</a></span><div class="content"><p>Android 架构组件是一组库，可帮助您设计稳健、可测试且易维护的应用。您可以从管理界面组件生命周期和处理数据持久性的类着手。</p>
<ul>
<li>通过<a href="https://developer.android.com/jetpack/docs/guide" target="_blank" rel="noopener">应用架构指南</a>，学习有关汇编稳健应用的基础知识。</li>
<li>管理应用的生命周期。新的<a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">生命周期感知型组件</a>可帮助您管理 Activity 和 Fragment 的生命周期。在配置更改后继续有效、避免内存泄漏，以及轻松加载数据到界面中。</li>
<li>使用 <a href="https://developer.android.com/topic/libraries/architecture/livedata" target="_blank" rel="noopener">LiveData</a> 构建数据对象，在基础数据库改变时通知视图。</li>
<li><a href="https://developer.android.com/topic/libraries/architecture/viewmodel" target="_blank" rel="noopener">ViewModel</a> 存储界面相关的数据，这些数据不会在应用轮转时销毁。</li>
<li><a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="noopener">Room</a> 是一个 SQLite 对象映射库。它可用来避免样板代码，并轻松地将 SQLite 表数据转换为 Java 对象。Room 提供 SQLite 语句的编译时检查，并且可以返回 RxJava、Flowable 和 LiveData 可观察对象。</li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s1.ax1x.com/2020/05/29/tmKQYV.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By liubo</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script>'use strict';'serviceWorker'in navigator&&navigator.serviceWorker.register('service-worker.js').then(function(a){a.onupdatefound=function(){var b=a.installing;b.onstatechange=function(){switch(b.state){case'installed':navigator.serviceWorker.controller?console.log('New or updated content is available.'):console.log('Content is now available offline!');break;case'redundant':console.error('The installing service worker became redundant.');}}}}).catch(function(a){console.error('Error during service worker registration:',a)});
</script></body></html>