<!DOCTYPE html><html lang="[&quot;zh-tw&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="6-LiveData"><meta name="keywords" content=""><meta name="author" content="liuclub"><meta name="copyright" content="liuclub"><title>6-LiveData | 凌晨三点的逗你玩</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#优势"><span class="toc-number">1.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用"><span class="toc-number">2.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建"><span class="toc-number">2.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#观察"><span class="toc-number">2.2.</span> <span class="toc-text">观察</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新"><span class="toc-number">2.3.</span> <span class="toc-text">更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将LiveData与Room一起使用"><span class="toc-number">2.4.</span> <span class="toc-text">将LiveData与Room一起使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将协程与LiveData一起使用"><span class="toc-number">2.5.</span> <span class="toc-text">将协程与LiveData一起使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展"><span class="toc-number">3.</span> <span class="toc-text">扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转换"><span class="toc-number">4.</span> <span class="toc-text">转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建新的转换-MediatorLiveData"><span class="toc-number">4.1.</span> <span class="toc-text">创建新的转换 MediatorLiveData</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#合并多个源"><span class="toc-number">5.</span> <span class="toc-text">合并多个源</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">liuclub</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">凌晨三点的逗你玩</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">6-LiveData</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JetPack/">JetPack</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[TOC]</p>
<blockquote>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。</p>
</blockquote>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol>
<li><p><strong>确保界面符合数据状态</strong></p>
<p>​    LiveData 遵循观察者模式。当生命周期状态发生变化时，LiveData 会通知 <a href="https://developer.android.com/reference/androidx/lifecycle/Observer" target="_blank" rel="noopener"><code>Observer</code></a> 对象。您可以整合代码以在这些 <code>Observer</code> 对象中更新界面。观察者可以在每次发生更改时更新界面，而不是在每次应用数据发生更改时更新界面。</p>
</li>
<li><p><strong>不会发生内存泄露</strong></p>
<p>​    观察者会绑定到 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 对象，并在其关联的生命周期遭到销毁后进行自我清理。</p>
</li>
<li><p><strong>不会因 Activity 停止而导致崩溃</strong></p>
<p>​    如果观察者的生命周期处于非活跃状态（如返回栈中的 Activity），则它不会接收任何 LiveData 事件。</p>
</li>
<li><p><strong>不再需要手动处理生命周期</strong></p>
<p>​    界面组件只是观察相关数据，不会停止或恢复观察。LiveData 将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。</p>
</li>
<li><p><strong>数据始终保持最新状态</strong></p>
<p>​    如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的 Activity 会在返回前台后立即接收最新的数据。</p>
</li>
<li><p><strong>适当的配置更改</strong></p>
<p>​    如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。</p>
</li>
<li><p><strong>共享资源</strong></p>
<p>​    您可以使用单一实例模式扩展 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象以封装系统服务，以便在应用中共享它们。<code>LiveData</code> 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 <code>LiveData</code> 对象。有关详情，请参阅<a href="https://developer.android.com/topic/libraries/architecture/livedata#extend_livedata" target="_blank" rel="noopener">扩展 LiveData</a>。</p>
</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>请按照以下步骤使用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象：</p>
<ol>
<li>创建 <code>LiveData</code> 实例以存储某种类型的数据。这通常在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 类中完成。</li>
<li>创建可定义 <a href="https://developer.android.com/reference/androidx/lifecycle/Observer#onChanged(T)" target="_blank" rel="noopener"><code>onChanged()</code></a> 方法的 <a href="https://developer.android.com/reference/androidx/lifecycle/Observer" target="_blank" rel="noopener"><code>Observer</code></a> 对象，该方法可以控制当 <code>LiveData</code> 对象存储的数据更改时会发生什么。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中创建 <code>Observer</code> 对象。</li>
<li>使用 [<code>observe()</code>](<a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#observe" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/lifecycle/LiveData#observe</a>(android.arch.lifecycle.LifecycleOwner, android.arch.lifecycle.Observer)) 方法将 <code>Observer</code> 对象附加到 <code>LiveData</code> 对象。<code>observe()</code> 方法会采用 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 对象。这样会使 <code>Observer</code> 对象订阅 <code>LiveData</code> 对象，以使其收到有关更改的通知。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中附加 <code>Observer</code> 对象。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：您可以使用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#observeForever(android.arch.lifecycle.Observer)" target="_blank" rel="noopener"><code>observeForever(Observer)</code></a> 方法来注册未关联 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 对象的观察者。在这种情况下，观察者会被视为始终处于活跃状态，因此它始终会收到关于修改的通知。您可以通过调用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#removeObserver(android.arch.lifecycle.Observer)" target="_blank" rel="noopener"><code>removeObserver(Observer)</code></a> 方法来移除这些观察者。</p>
</blockquote>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>LiveData 是一种可用于任何数据的封装容器，其中包括可实现 <code>Collections</code> 的对象，如 <code>List</code>。 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象通常存储在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象中，并可通过 getter 方法进行访问，如以下示例中所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a LiveData with a String</span></span><br><span class="line">    <span class="keyword">val</span> currentName: MutableLiveData&lt;String&gt; <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        MutableLiveData&lt;String&gt;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rest of the ViewModel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>注意</strong>：请确保将用于更新界面的 <code>LiveData</code> 对象存储在 <code>ViewModel</code> 对象中，而不是将其存储在 Activity 或 Fragment 中，原因如下：</p>
<p>​    避免 Activity 和 Fragment 过于庞大。现在，这些界面控制器负责显示数据，但不负责存储数据状态。将 <code>LiveData</code> 实例与特定的 Activity 或 Fragment 实例分离开，并使 对象在配置更改后继续存在。</p>
</blockquote>
<h3 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h3><p>在大多数情况下，应用组件的 <code>onCreate()</code> 方法是开始观察 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象的正确着手点，原因如下：</p>
<ul>
<li>确保系统不会从 Activity 或 Fragment 的 <code>onResume()</code> 方法进行冗余调用。</li>
<li>确保 Activity 或 Fragment 变为活跃状态后具有可以立即显示的数据。一旦应用组件处于 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.State#STARTED" target="_blank" rel="noopener"><code>STARTED</code></a> 状态，就会从它正在观察的 <code>LiveData</code> 对象接收最新值。只有在设置了要观察的 <code>LiveData</code> 对象时，才会发生这种情况。</li>
</ul>
<p>通常，LiveData 仅在数据发生更改时才发送更新，并且仅发送给活跃观察者。</p>
<blockquote>
<p>此行为的一种例外情况是，观察者从非活跃状态更改为活跃状态时也会收到更新。</p>
<p>此外，如果观察者第二次从非活跃状态更改为活跃状态，则只有在自上次变为活跃状态以来值发生了更改时，它才会收到更新。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> model: NameViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Other code to setup the activity...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the ViewModel.</span></span><br><span class="line">        model = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(NameViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the observer which updates the UI.</span></span><br><span class="line">        <span class="keyword">val</span> nameObserver = Observer&lt;String&gt; &#123; newName -&gt;</span><br><span class="line">            <span class="comment">// Update the UI, in this case, a TextView.</span></span><br><span class="line">            nameTextView.text = newName</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.</span></span><br><span class="line">        model.currentName.observe(<span class="keyword">this</span>, nameObserver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在传递 <code>nameObserver</code> 参数的情况下调用 [<code>observe()</code>](<a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#observe" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/lifecycle/LiveData#observe</a>(android.arch.lifecycle.LifecycleOwner, android.arch.lifecycle.Observer)) 后，系统会立即调用 <a href="https://developer.android.com/reference/androidx/lifecycle/Observer#onChanged(T)" target="_blank" rel="noopener"><code>onChanged()</code></a>，从而提供 <code>mCurrentName</code> 中存储的最新值。 如果 <code>LiveData</code> 对象尚未在 <code>mCurrentName</code> 中设置值，则不会调用 <code>onChanged()</code>。</p>
</blockquote>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>​    LiveData 没有公开可用的方法来更新存储的数据。<a href="https://developer.android.com/reference/androidx/lifecycle/MutableLiveData" target="_blank" rel="noopener"><code>MutableLiveData</code></a> 类将公开 <a href="https://developer.android.com/reference/androidx/lifecycle/MutableLiveData#setValue(T)" target="_blank" rel="noopener"><code>setValue(T)</code></a> 和 <a href="https://developer.android.com/reference/androidx/lifecycle/MutableLiveData#postValue(T)" target="_blank" rel="noopener"><code>postValue(T)</code></a> 方法，如果您需要修改存储在 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象中的值，则必须使用这些方法。通常情况下会在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 中使用 <code>MutableLiveData</code>，然后 <code>ViewModel</code> 只会向观察者公开不可变的 <code>LiveData</code> 对象。</p>
<p>​    设置观察者关系后，您可以更新 <code>LiveData</code> 对象的值（如以下示例中所示），这样当用户点按某个按钮时会触发所有观察者：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> anotherName = <span class="string">"John Doe"</span></span><br><span class="line">    model.currentName.setValue(anotherName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在本例中调用 setValue(T) 导致观察者使用值 John Doe 调用其 onChanged() 方法。</span></span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：您必须调用 <a href="https://developer.android.com/reference/androidx/lifecycle/MutableLiveData#setValue(T)" target="_blank" rel="noopener"><code>setValue(T)</code></a> 方法以从主线程更新 <code>LiveData</code> 对象。如果在 worker 线程中执行代码，则您可以改用 <a href="https://developer.android.com/reference/androidx/lifecycle/MutableLiveData#postValue(T)" target="_blank" rel="noopener"><code>postValue(T)</code></a> 方法来更新 <code>LiveData</code> 对象。</p>
<h3 id="将LiveData与Room一起使用"><a href="#将LiveData与Room一起使用" class="headerlink" title="将LiveData与Room一起使用"></a>将LiveData与Room一起使用</h3><blockquote>
<p>Room 持久性库支持返回 LiveData 对象的可观察查询。可观察查询属于数据库访问对象 (DAO) 的一部分。</p>
<p>当数据库更新时，Room 会生成更新 LiveData 对象所需的所有代码。在需要时，生成的代码会在后台线程上异步运行查询。此模式有助于使界面中显示的数据与存储在数据库中的数据保持同步。</p>
</blockquote>
<h3 id="将协程与LiveData一起使用"><a href="#将协程与LiveData一起使用" class="headerlink" title="将协程与LiveData一起使用"></a>将协程与LiveData一起使用</h3><blockquote>
<p><code>LiveData</code> 支持 Kotlin 协程。</p>
</blockquote>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>如果观察者的生命周期处于 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.State#STARTED" target="_blank" rel="noopener"><code>STARTED</code></a> 或 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.State#RESUMED" target="_blank" rel="noopener"><code>RESUMED</code></a> 状态，则 LiveData 会认为该观察者处于活跃状态。</p>
<p>以下示例代码说明了如何扩展 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span></span>(symbol: String) : LiveData&lt;BigDecimal&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> stockManager = StockManager(symbol)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> listener = &#123; price: BigDecimal -&gt;</span><br><span class="line">        value = price</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.requestPriceUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.removeUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例中的价格监听器实现包括以下重要方法：</p>
<ul>
<li>当 <code>LiveData</code> 对象具有活跃观察者时，会调用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#onActive()" target="_blank" rel="noopener"><code>onActive()</code></a> 方法。这意味着，您需要从此方法开始观察股价更新。</li>
<li>当 <code>LiveData</code> 对象没有任何活跃观察者时，会调用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#onInactive()" target="_blank" rel="noopener"><code>onInactive()</code></a> 方法。由于没有观察者在监听，因此没有理由与 <code>StockManager</code> 服务保持连接。</li>
<li><a href="https://developer.android.com/reference/androidx/lifecycle/MutableLiveData#setValue(T)" target="_blank" rel="noopener"><code>setValue(T)</code></a> 方法将更新 <code>LiveData</code> 实例的值，并将更改通知给任何活跃观察者。</li>
</ul>
<p>可以使用 <code>StockLiveData</code> 类，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState)</span><br><span class="line">    <span class="keyword">val</span> myPriceListener: LiveData&lt;BigDecimal&gt; = ...</span><br><span class="line">    myPriceListener.observe(<span class="keyword">this</span>, Observer&lt;BigDecimal&gt; &#123; price: BigDecimal? -&gt;</span><br><span class="line">        <span class="comment">// Update the UI.</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>[<code>observe()</code>](<a href="https://developer.android.com/reference/androidx/lifecycle/LiveData#observe" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/lifecycle/LiveData#observe</a>(android.arch.lifecycle.LifecycleOwner, android.arch.lifecycle.Observer)) 方法将传递 Fragment（它是 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 的实例）作为第一个参数。这样做表示此观察者已绑定到与所有者关联的 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 对象，这意味着：</p>
<ul>
<li>如果 <code>Lifecycle</code> 对象未处于活跃状态，那么即使值发生更改，也不会调用观察者。</li>
<li>销毁 <code>Lifecycle</code> 对象后，会自动移除观察者。</li>
</ul>
<p><code>LiveData</code> 对象具有生命周期感知能力，这一事实意味着您可以在多个 Activity、Fragment 和 Service 之间共享它们。为使示例保持简单，您可以将 <code>LiveData</code> 类实现为单一实例，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span></span>(symbol: String) : LiveData&lt;BigDecimal&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> stockManager: StockManager = StockManager(symbol)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> listener = &#123; price: BigDecimal -&gt;</span><br><span class="line">        value = price</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.requestPriceUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.removeUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sInstance: StockLiveData</span><br><span class="line"></span><br><span class="line">        <span class="meta">@MainThread</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(symbol: <span class="type">String</span>)</span></span>: StockLiveData &#123;</span><br><span class="line">            sInstance = <span class="keyword">if</span> (::sInstance.isInitialized) sInstance <span class="keyword">else</span> StockLiveData(symbol)</span><br><span class="line">            <span class="keyword">return</span> sInstance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>并且您可以在 Fragment 中使用它，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        StockLiveData.<span class="keyword">get</span>(symbol).observe(<span class="keyword">this</span>, Observer&lt;BigDecimal&gt; &#123; price: BigDecimal? -&gt;</span><br><span class="line">            <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>多个 Fragment 和 Activity 可以观察 <code>MyPriceListener</code> 实例。仅当一个或多个系统服务可见且处于活跃状态时，LiveData 才会连接到该服务。</p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>​    如果希望在将 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象分派给观察者之前对存储在其中的值进行更改，或者您可能需要根据另一个实例的值返回不同的 <code>LiveData</code> 实例。<a href="https://developer.android.com/reference/android/arch/lifecycle/package-summary" target="_blank" rel="noopener"><code>Lifecycle</code></a> 软件包会提供 <a href="https://developer.android.com/reference/androidx/lifecycle/Transformations" target="_blank" rel="noopener"><code>Transformations</code></a> 类，该类包括可应对这些情况的辅助程序方法。</p>
<ul>
<li><p>[<code>Transformations.map()</code>](<a href="https://developer.android.com/reference/androidx/lifecycle/Transformations#map" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/lifecycle/Transformations#map</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function))</p>
<p>对存储在 <code>LiveData</code> 对象中的值应用函数，并将结果传播到下游。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> userLiveData: LiveData&lt;User&gt; = UserLiveData()</span><br><span class="line"><span class="keyword">val</span> userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123;</span><br><span class="line">    user -&gt; <span class="string">"<span class="subst">$&#123;user.name&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>[<code>Transformations.switchMap()</code>](<a href="https://developer.android.com/reference/androidx/lifecycle/Transformations#switchMap" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/lifecycle/Transformations#switchMap</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function&gt;))</p>
<p>与 <code>map()</code> 类似，对存储在 <code>LiveData</code> 对象中的值应用函数，并将结果解封和分派到下游。传递给 <code>switchMap()</code> 的函数必须返回 <code>LiveData</code> 对象，如以下示例中所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(id: <span class="type">String</span>)</span></span>: LiveData &#123;   ...  &#125;  </span><br><span class="line"><span class="keyword">val</span> userId: LiveData = ...  </span><br><span class="line"><span class="keyword">val</span> user = Transformations.switchMap(userId) &#123; id -&gt; getUser(id) &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>​    可以使用转换方法在观察者的生命周期内传送信息。除非观察者正在观察返回的 <code>LiveData</code> 对象，否则不会计算转换。因为<strong>转换是以延迟的方式计算</strong>，所以与生命周期相关的行为会隐式传递下去，而不需要额外的显式调用或依赖项。</p>
<p>​    </p>
<p>如果您认为 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 对象中需要有 <code>Lifecycle</code> 对象，那么进行转换或许是更好的解决方案。例如，假设您有一个界面组件，该组件接受地址并返回该地址的邮政编码。您可以为此组件实现简单的 <code>ViewModel</code>，如以下示例代码所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: PostalCodeRepository) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPostalCode</span><span class="params">(address: <span class="type">String</span>)</span></span>: LiveData&lt;String&gt; &#123;</span><br><span class="line">        <span class="comment">// 不要这么做</span></span><br><span class="line">        <span class="keyword">return</span> repository.getPostCode(address)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    UI组件需要在每次调用getPostalCode()的时候，从之前的LiveData对象中取消注册，并注册到新的实例。此外，如果UI组件被重新创建，它将触发对repository.getPostCode()方法的另一次调用，而不是使用上次调用的结果。</p>
<p>​    您也可以将邮政编码查询实现为地址输入的转换，如以下示例中所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: PostalCodeRepository) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> addressInput = MutableLiveData&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> postalCode: LiveData&lt;String&gt; = Transformations.switchMap(addressInput) &#123;</span><br><span class="line">            address -&gt; repository.getPostCode(address) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setInput</span><span class="params">(address: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        addressInput.value = address</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这种情况下，<code>postalCode</code> 字段定义为 <code>addressInput</code> 的转换。只要您的应用具有与 <code>postalCode</code> 字段关联的活跃观察者，就会在 <code>addressInput</code> 发生更改时重新计算并检索该字段的值。</p>
<p>此机制允许较低级别的应用创建以延迟的方式按需计算的 <code>LiveData</code> 对象。<code>ViewModel</code> 对象可以轻松获取对 <code>LiveData</code> 对象的引用，然后在其基础之上定义转换规则。</p>
</blockquote>
<h3 id="创建新的转换-MediatorLiveData"><a href="#创建新的转换-MediatorLiveData" class="headerlink" title="创建新的转换 MediatorLiveData"></a>创建新的转换 MediatorLiveData</h3><blockquote>
<p>有十几种不同的特定转换在您的应用中可能很有用，但默认情况下不提供它们。要实现您自己的转换，您可以使用 <a href="https://developer.android.com/reference/androidx/lifecycle/MediatorLiveData" target="_blank" rel="noopener"><code>MediatorLiveData</code></a>类，该类可以监听其他 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象并处理它们发出的事件。<code>MediatorLiveData</code> 正确地将其状态传播到源 <code>LiveData</code> 对象。要详细了解此模式，请参阅 <a href="https://developer.android.com/reference/androidx/lifecycle/Transformations" target="_blank" rel="noopener"><code>Transformations</code></a> 类的参考文档。</p>
</blockquote>
<h2 id="合并多个源"><a href="#合并多个源" class="headerlink" title="合并多个源"></a>合并多个源</h2><p>​    <strong>MediatorLiveData</strong> 是 LiveData 的子类，允许您合并多个 LiveData 源。只要任何原始的 LiveData 源对象发生更改，就会触发 MediatorLiveData 对象的观察者。</p>
<p>​    例如，如果界面中有可以从本地数据库或网络更新的 LiveData 对象，则可以向 MediatorLiveData 对象添加以下源：</p>
<ul>
<li><p>与存储在数据库中的数据关联的 LiveData 对象。</p>
</li>
<li><p>与从网络访问的数据关联的 LiveData 对象。</p>
</li>
</ul>
<p>​    您的 Activity 只需观察 MediatorLiveData 对象即可从这两个源接收更新。有关详细示例，请参阅应用架构指南的附录：公开网络状态部分。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">liuclub</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://github.com/liuclub/liuclub.github.io.git/2020/05/28/6-LiveData/">https://github.com/liuclub/liuclub.github.io.git/2020/05/28/6-LiveData/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/28/7-%E5%88%86%E9%A1%B5%E5%BA%93/"><i class="fa fa-chevron-left">  </i><span>7-分页库</span></a></div><div class="next-post pull-right"><a href="/2020/05/28/5-%E5%A4%84%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"><span>5-处理生命周期</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By liuclub</div><!--.framework-info--><!--  span= _p('footer.driven') + ' - '--><!--  a(href='http://hexo.io')--><!--    span Hexo--><!--  span.footer-separator |--><!--  span= _p('footer.theme') + ' - '--><!--  a(href='https://github.com/Molunerfinn/hexo-theme-melody')--><!--    span Melody--><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>