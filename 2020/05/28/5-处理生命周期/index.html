<!DOCTYPE html><html lang="[&quot;zh-Hans&quot;,&quot;default&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="5-处理生命周期"><meta name="keywords" content="Lifecycle"><meta name="author" content="liubo"><meta name="copyright" content="liubo"><title>5-处理生命周期 | 凌晨三点的逗你玩</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?<script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?35bde86d2b874a119f02ef9c266bb3dc"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script>";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期"><span class="toc-number">1.</span> <span class="toc-text"> 生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lifecycleowner"><span class="toc-number">2.</span> <span class="toc-text"> LifecycleOwner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现自定义lifecycleowner"><span class="toc-number">2.1.</span> <span class="toc-text"> 实现自定义LifecycleOwner</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期感知型组件的最佳做法"><span class="toc-number">3.</span> <span class="toc-text"> 生命周期感知型组件的最佳做法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期感知型组件的用例"><span class="toc-number">4.</span> <span class="toc-text"> 生命周期感知型组件的用例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理on_stop事件"><span class="toc-number">5.</span> <span class="toc-text"> 处理ON_STOP事件</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s1.ax1x.com/2020/05/29/tmMe1O.jpg"></div><div class="author-info__name text-center">liubo</div><div class="author-info__description text-center">人最大的问题就是习惯自我辩解，但我们远比自己想象中更许巍、下作和幽暗。</div><div class="follow-button"><a href="https://github.com/liuclub">Follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">14</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s1.ax1x.com/2020/05/29/tmKQYV.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">凌晨三点的逗你玩</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">种类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">5-处理生命周期</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JetPack/">JetPack</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 7 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/package-summary" target="_blank" rel="noopener"><code>androidx.lifecycle</code></a> 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> lifecycle_version = <span class="string">"2.2.0"</span></span><br><span class="line">    <span class="keyword">def</span> arch_version = <span class="string">"2.1.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewModel</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"</span></span><br><span class="line">    <span class="comment">// LiveData</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version"</span></span><br><span class="line">    <span class="comment">// Lifecycles only (without ViewModel or LiveData)</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Saved state module for ViewModel</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation processor</span></span><br><span class="line">    kapt <span class="string">"androidx.lifecycle:lifecycle-compiler:$lifecycle_version"</span></span><br><span class="line">    <span class="comment">// alternately - if using Java8, use the following instead of lifecycle-compiler</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-common-java8:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - ReactiveStreams support for LiveData</span></span><br><span class="line">    implementation <span class="string">"androidx.lifecycle:lifecycle-reactivestreams-ktx:$lifecycle_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers for LiveData</span></span><br><span class="line">    testImplementation <span class="string">"androidx.arch.core:core-testing:$arch_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> callback: (Location) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// connect to system location service</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// disconnect from system location service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> myLocationListener: MyLocationListener</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        myLocationListener = MyLocationListener(<span class="keyword">this</span>) &#123; location -&gt;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        myLocationListener.start()</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        myLocationListener.stop()</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然此示例看起来没问题，但在真实的应用中，最终会有太多管理界面和其他组件的调用，以响应生命周期的当前状态。管理多个组件会在生命周期方法（如 <code>onStart()</code> 和 <code>onStop()</code>）中放置大量的代码，这使得它们难以维护。</p>
<p>此外，无法保证组件会在 Activity 或 Fragment 停止之前启动。在我们需要执行长时间运行的操作（如 <code>onStart()</code> 中的某种配置检查）时尤其如此。这可能会导致出现一种竞争条件，在这种条件下，<code>onStop()</code> 方法会在 <code>onStart()</code> 之前结束，这使得组件留存的时间比所需的时间要长。</p>
</blockquote>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/package-summary" target="_blank" rel="noopener"><code>androidx.lifecycle</code></a> 软件包提供的类和接口可帮助您以弹性和隔离的方式解决这些问题。</p>
<h2 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h2>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。</p>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 使用两种主要枚举跟踪其关联组件的生命周期状态：</p>
<ul>
<li>
<p>事件</p>
<p>从框架和 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。</p>
</li>
<li>
<p>状态</p>
<p>由 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 对象跟踪的组件的当前状态。</p>
</li>
</ul>
<p><img src="/Users/liubo/Desktop/%E7%AC%94%E8%AE%B0/Jetpack/lifecycle-states.svg" alt="lifecycle-states" /></p>
<p><strong>图 1.</strong> 构成 Android Activity 生命周期的状态和事件</p>
<p>类可以通过向其方法添加注解来监控组件的生命周期状态。然后，您可以通过调用 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 类的 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle#addObserver(androidx.lifecycle.LifecycleObserver)" target="_blank" rel="noopener"><code>addObserver()</code></a> 方法并传递观察者的实例来添加观察者，如以下示例中所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> : <span class="type">LifecycleObserver &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">connectListener</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">disconnectListener</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myLifecycleOwner.getLifecycle().addObserver(MyObserver())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的示例中，<code>myLifecycleOwner</code> 对象实现了 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 接口，我们将在接下来的部分中对该接口进行说明。</p>
</blockquote>
<h2 id="lifecycleowner"><a class="markdownIt-Anchor" href="#lifecycleowner"></a> LifecycleOwner</h2>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 是单一方法接口，表示类具有 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a>。它具有一种方法（即 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner#getLifecycle()" target="_blank" rel="noopener"><code>getLifecycle()</code></a>），该方法必须由类实现。如果您尝试管理整个应用进程的生命周期，请参阅 <a href="https://developer.android.com/reference/androidx/lifecycle/ProcessLifecycleOwner" target="_blank" rel="noopener"><code>ProcessLifecycleOwner</code></a>。</p>
<p>实现 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver" target="_blank" rel="noopener"><code>LifecycleObserver</code></a> 的组件可与实现 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a> 的组件无缝协同工作，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。</p>
<blockquote>
<p>对于位置跟踪示例，我们可以让 <code>MyLocationListener</code> 类实现 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver" target="_blank" rel="noopener"><code>LifecycleObserver</code></a>，然后在 <code>onCreate()</code> 方法中使用 Activity 的 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 对其进行初始化。这样，<code>MyLocationListener</code> 类便可以“自给自足”，这意味着，对生命周期状态的变化做出响应的逻辑会在 <code>MyLocationListener</code>（而不是在 Activity）中进行声明。让各个组件存储自己的逻辑，可使 Activity 和 Fragment 逻辑更易于管理。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> myLocationListener: MyLocationListener</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        myLocationListener = MyLocationListener(<span class="keyword">this</span>, lifecycle) &#123; location -&gt;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;</span><br><span class="line">        Util.checkUserStatus &#123; result -&gt;</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.enable()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个常见的用例是，如果 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 现在未处于良好的状态，则应避免调用某些回调。例如，如果回调在 Activity 状态保存后运行 Fragment 事务，就会引发崩溃，因此我们绝不能调用该回调。</p>
<p>为简化此用例，<a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener"><code>Lifecycle</code></a> 类允许其他对象查询当前状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> lifecycle: Lifecycle,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> callback: (Location) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> enabled = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">            <span class="comment">// connect</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">enable</span><span class="params">()</span></span> &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) &#123;</span><br><span class="line">            <span class="comment">// connect if not connected</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// disconnect if connected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于此实现，<code>LocationListener</code> 类可以完全感知生命周期。如果我们需要从另一个 Activity 或 Fragment 使用 <code>LocationListener</code>，只需对其进行初始化。所有设置和拆解操作都由类本身管理。</p>
</blockquote>
<h3 id="实现自定义lifecycleowner"><a class="markdownIt-Anchor" href="#实现自定义lifecycleowner"></a> 实现自定义LifecycleOwner</h3>
<blockquote>
<p>Support Library 26.1.0 及更高版本中的 Fragment 和 Activity 已实现 LifecycleOwner 接口。</p>
</blockquote>
<p>如果您有一个自定义类并希望使其成为 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener"><code>LifecycleOwner</code></a>，您可以使用 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleRegistry" target="_blank" rel="noopener">LifecycleRegistry</a> 类，但需要将事件转发到该类，如以下代码示例中所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">Activity</span></span>(), LifecycleOwner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> lifecycleRegistry: LifecycleRegistry</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        lifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.CREATED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle &#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生命周期感知型组件的最佳做法"><a class="markdownIt-Anchor" href="#生命周期感知型组件的最佳做法"></a> 生命周期感知型组件的最佳做法</h2>
<ul>
<li>使界面控制器（Activity 和 Fragment）尽可能保持精简。它们不应试图获取自己的数据，而应使用 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 执行此操作，并观察 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象以将更改体现到视图中。</li>
<li>设法编写数据驱动型界面，对于此类界面，界面控制器的责任是随着数据更改而更新视图，或者将用户操作通知给 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a>。</li>
<li>将数据逻辑放在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 类中。 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 应充当界面控制器与应用其余部分之间的连接器。不过要注意，<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 不负责获取数据（例如，从网络获取）。<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 应调用相应的组件来获取数据，然后将结果提供给界面控制器。</li>
<li>使用 <a href="https://developer.android.com/topic/libraries/data-binding" target="_blank" rel="noopener">Data Binding</a> 在视图与界面控制器之间维持干净的接口。这样一来，您可以使视图更具声明性，并尽量减少需要在 Activity 和 Fragment 中编写的更新代码。如果您更愿意使用 Java 编程语言执行此操作，请使用诸如 <a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">Butter Knife</a> 之类的库，以避免样板代码并实现更好的抽象化。</li>
<li>如果界面很复杂，不妨考虑创建 <a href="http://www.gwtproject.org/articles/mvp-architecture.html#presenter" target="_blank" rel="noopener">presenter</a> 类来处理界面的修改。这可能是一项艰巨的任务，但这样做可使界面组件更易于测试。</li>
<li>避免在 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 中引用 <code>View</code> 或 <code>Activity</code> 上下文。 如果 <code>ViewModel</code> 存在的时间比 Activity 更长（在配置更改的情况下），Activity 将泄露并且不会由垃圾回收器妥善处置。</li>
<li>使用 <a href="https://developer.android.com/topic/libraries/architecture/coroutines" target="_blank" rel="noopener">Kotlin 协程</a>管理长时间运行的任务和其他可以异步运行的操作。</li>
</ul>
<h2 id="生命周期感知型组件的用例"><a class="markdownIt-Anchor" href="#生命周期感知型组件的用例"></a> 生命周期感知型组件的用例</h2>
<blockquote>
<p>生命周期感知型组件可使您在各种情况下更轻松地管理生命周期。下面列举几个例子：</p>
<ul>
<li>在粗粒度和细粒度位置更新之间切换。使用生命周期感知型组件可在位置应用可见时启用细粒度位置更新，并在应用位于后台时切换到粗粒度更新。借助生命周期感知型组件 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a>，应用可以在用户使用位置发生变化时自动更新界面。</li>
<li>停止和开始视频缓冲。使用生命周期感知型组件可尽快开始视频缓冲，但会推迟播放，直到应用完全启动。此外，应用销毁后，您还可以使用生命周期感知型组件终止缓冲。</li>
<li>开始和停止网络连接。借助生命周期感知型组件，可在应用位于前台时启用网络数据的实时更新（流式传输），并在应用进入后台时自动暂停。</li>
<li>暂停和恢复动画可绘制资源。借助生命周期感知型组件，可在应用位于后台时暂停动画可绘制资源，并在应用位于前台后恢复可绘制资源。</li>
</ul>
</blockquote>
<h2 id="处理on_stop事件"><a class="markdownIt-Anchor" href="#处理on_stop事件"></a> 处理ON_STOP事件</h2>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">liubo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/liuclub/liuclub.github.io.git/2020/05/28/5-%E5%A4%84%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">https://github.com/liuclub/liuclub.github.io.git/2020/05/28/5-%E5%A4%84%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/liuclub/liuclub.github.io.git">凌晨三点的逗你玩</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Lifecycle/">Lifecycle</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://s1.ax1x.com/2020/05/29/tmKo6g.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://s1.ax1x.com/2020/05/29/tmK5p8.png"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/28/6-LiveData/"><i class="fa fa-chevron-left">  </i><span>6-LiveData</span></a></div><div class="next-post pull-right"><a href="/2020/05/28/4-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%BA%93/"><span>4-数据绑定库</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s1.ax1x.com/2020/05/29/tmKQYV.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By liubo</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>