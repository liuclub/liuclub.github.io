<!DOCTYPE html><html lang="[&quot;zh-tw&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="8-Room持久性库"><meta name="keywords" content=""><meta name="author" content="liubo"><meta name="copyright" content="liubo"><title>8-Room持久性库 | 凌晨三点的逗你玩</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概览"><span class="toc-number">1.</span> <span class="toc-text">概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#示例"><span class="toc-number">1.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明依赖项"><span class="toc-number">1.2.</span> <span class="toc-text">声明依赖项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置编译器选项"><span class="toc-number">1.3.</span> <span class="toc-text">配置编译器选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用实体定义数据"><span class="toc-number">2.</span> <span class="toc-text">使用实体定义数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用主键"><span class="toc-number">2.1.</span> <span class="toc-text">使用主键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#忽略字段"><span class="toc-number">2.2.</span> <span class="toc-text">忽略字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提供表搜索支持"><span class="toc-number">2.3.</span> <span class="toc-text">提供表搜索支持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#支持全文搜索-FTS：Full-text-Search"><span class="toc-number">2.3.1.</span> <span class="toc-text">支持全文搜索(FTS：Full-text Search)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将特定列编入索引"><span class="toc-number">2.3.2.</span> <span class="toc-text">将特定列编入索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加基于AutoValue的对象"><span class="toc-number">2.4.</span> <span class="toc-text">添加基于AutoValue的对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义对象之间的关系"><span class="toc-number">3.</span> <span class="toc-text">定义对象之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义一对多关系"><span class="toc-number">3.1.</span> <span class="toc-text">定义一对多关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建嵌套对象"><span class="toc-number">3.2.</span> <span class="toc-text">创建嵌套对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义多对多关系"><span class="toc-number">3.3.</span> <span class="toc-text">定义多对多关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在数据库中创建视图"><span class="toc-number">4.</span> <span class="toc-text">在数据库中创建视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建视图"><span class="toc-number">4.1.</span> <span class="toc-text">创建视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将视图与数据库相关联"><span class="toc-number">4.2.</span> <span class="toc-text">将视图与数据库相关联</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用DAO访问数据"><span class="toc-number">5.</span> <span class="toc-text">使用DAO访问数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义方法"><span class="toc-number">5.1.</span> <span class="toc-text">自定义方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Insert"><span class="toc-number">5.1.1.</span> <span class="toc-text">Insert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Update"><span class="toc-number">5.1.2.</span> <span class="toc-text">Update</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Delete"><span class="toc-number">5.1.3.</span> <span class="toc-text">Delete</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查询信息"><span class="toc-number">5.2.</span> <span class="toc-text">查询信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简单查询"><span class="toc-number">5.2.1.</span> <span class="toc-text">简单查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将参数传递给查询"><span class="toc-number">5.2.2.</span> <span class="toc-text">将参数传递给查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#返回列的子集"><span class="toc-number">5.2.3.</span> <span class="toc-text">返回列的子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#传递参数的集合"><span class="toc-number">5.2.4.</span> <span class="toc-text">传递参数的集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可观察查询"><span class="toc-number">5.2.5.</span> <span class="toc-text">可观察查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用RxJava进行响应式查询"><span class="toc-number">5.2.6.</span> <span class="toc-text">使用RxJava进行响应式查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#直接光标访问"><span class="toc-number">5.2.7.</span> <span class="toc-text">直接光标访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查询多个表格"><span class="toc-number">5.2.8.</span> <span class="toc-text">查询多个表格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Kotlin协程编写异步方法"><span class="toc-number">5.2.9.</span> <span class="toc-text">使用Kotlin协程编写异步方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预填充数据库"><span class="toc-number">6.</span> <span class="toc-text">预填充数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迁移数据库"><span class="toc-number">7.</span> <span class="toc-text">迁移数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试和调试数据库"><span class="toc-number">8.</span> <span class="toc-text">测试和调试数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用复杂数据"><span class="toc-number">9.</span> <span class="toc-text">引用复杂数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用类型转换器"><span class="toc-number">9.1.</span> <span class="toc-text">使用类型转换器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#了解Room为何不允许对象引用"><span class="toc-number">9.2.</span> <span class="toc-text">了解Room为何不允许对象引用</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">liubo</div><div class="author-info__description text-center">人最大的问题就是习惯自我辩解，但我们远比自己想象中更许巍、下作和幽暗。</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">凌晨三点的逗你玩</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">8-Room持久性库</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JetPack/">JetPack</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[TOC]</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>  Room 在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。</p>
<p>Room 包含 3 个主要组件：</p>
<ul>
<li><p><a href="https://developer.android.com/reference/androidx/room/Database" target="_blank" rel="noopener"><strong>数据库</strong></a>：包含数据库持有者，并作为应用已保留的持久关系型数据的底层连接的主要接入点。</p>
<p>使用 <a href="https://developer.android.com/reference/androidx/room/Database" target="_blank" rel="noopener"><code>@Database</code></a> 注释的类应满足以下条件：</p>
<ul>
<li>是扩展 <a href="https://developer.android.com/reference/androidx/room/RoomDatabase" target="_blank" rel="noopener"><code>RoomDatabase</code></a> 的抽象类。</li>
<li>在注释中添加与数据库关联的实体列表。</li>
<li>包含具有 0 个参数且返回使用 <a href="https://developer.android.com/reference/androidx/room/Dao" target="_blank" rel="noopener"><code>@Dao</code></a> 注释的类的抽象方法。</li>
</ul>
<p>在运行时，您可以通过调用 [<code>Room.databaseBuilder()</code>](<a href="https://developer.android.com/reference/androidx/room/Room#databaseBuilder" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/room/Room#databaseBuilder</a>(android.content.Context, java.lang.Class, java.lang.String)) 或 [<code>Room.inMemoryDatabaseBuilder()</code>](<a href="https://developer.android.com/reference/androidx/room/Room#inMemoryDatabaseBuilder" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/room/Room#inMemoryDatabaseBuilder</a>(android.content.Context, java.lang.Class)) 获取 <a href="https://developer.android.com/reference/androidx/room/Database" target="_blank" rel="noopener"><code>Database</code></a> 的实例。</p>
</li>
</ul>
<ul>
<li><p><a href="https://developer.android.com/training/data-storage/room/defining-data" target="_blank" rel="noopener"><strong>Entity</strong></a>：表示数据库中的表。</p>
</li>
<li><p><a href="https://developer.android.com/training/data-storage/room/accessing-data" target="_blank" rel="noopener"><strong>DAO</strong></a>：包含用于访问数据库的方法。</p>
</li>
</ul>
<p>Room架构图如下所示：</p>
<p><img src="/Users/liubo/Desktop/%E7%AC%94%E8%AE%B0/Jetpack/room_architecture.png" alt="room_architecture"></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote>
<p>以下代码段包含具有一个实体和一个 DAO 的示例数据库配置。</p>
</blockquote>
<p>User</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> uid: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"first_name"</span>)</span> <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"last_name"</span>)</span> <span class="keyword">val</span> lastName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>UserDao</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAll</span><span class="params">()</span></span>: List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user WHERE uid IN (:userIds)"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadAllByIds</span><span class="params">(userIds: <span class="type">IntArray</span>)</span></span>: List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user WHERE first_name LIKE :first AND "</span> +</span></span><br><span class="line"><span class="meta">           <span class="meta-string">"last_name LIKE :last LIMIT 1"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findByName</span><span class="params">(first: <span class="type">String</span>, last: <span class="type">String</span>)</span></span>: User</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertAll</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AppDatabase</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = arrayOf(User::class)</span>, version = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">userDao</span><span class="params">()</span></span>: UserDao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取数据库实例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> db = Room.databaseBuilder(</span><br><span class="line">            applicationContext,</span><br><span class="line">            AppDatabase::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">"database-name"</span></span></span><br><span class="line">        ).build()</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果您的应用在单个进程中运行，则在实例化 <code>AppDatabase</code> 对象时应遵循单例设计模式。每个 <a href="https://developer.android.com/reference/androidx/room/RoomDatabase" target="_blank" rel="noopener"><code>RoomDatabase</code></a> 实例的成本相当高，而您几乎不需要在单个进程中访问多个实例。</p>
<p>  如果您的应用在多个进程中运行，请在数据库构建器调用中包含 <code>enableMultiInstanceInvalidation()</code>。这样，如果您在每个进程中都有一个 <code>AppDatabase</code> 实例，就可以在一个进程中使共享数据库文件失效，并且这种失效会自动传播到其他进程中的 <code>AppDatabase</code> 实例。</p>
<h3 id="声明依赖项"><a href="#声明依赖项" class="headerlink" title="声明依赖项"></a>声明依赖项</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> room_version = <span class="string">"2.2.3"</span></span><br><span class="line"></span><br><span class="line">  implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">  annotationProcessor <span class="string">"androidx.room:room-compiler:$room_version"</span> <span class="comment">// For Kotlin use kapt instead of annotationProcessor</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Kotlin Extensions and Coroutines support for Room</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-ktx:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - RxJava support for Room</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-guava:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test helpers</span></span><br><span class="line">  testImplementation <span class="string">"androidx.room:room-testing:$room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="配置编译器选项"><a href="#配置编译器选项" class="headerlink" title="配置编译器选项"></a>配置编译器选项</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> room_version = <span class="string">"2.2.3"</span></span><br><span class="line"></span><br><span class="line">  implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">  annotationProcessor <span class="string">"androidx.room:room-compiler:$room_version"</span> <span class="comment">// For Kotlin use kapt instead of annotationProcessor</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Kotlin Extensions and Coroutines support for Room</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-ktx:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - RxJava support for Room</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">  implementation <span class="string">"androidx.room:room-guava:$room_version"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test helpers</span></span><br><span class="line">  testImplementation <span class="string">"androidx.room:room-testing:$room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以下代码段举例说明了如何配置这些选项：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [</span><br><span class="line">                    <span class="string">"room.schemaLocation"</span>:<span class="string">"$projectDir/schemas"</span>.toString(),</span><br><span class="line">                    <span class="string">"room.incremental"</span>:<span class="string">"true"</span>,</span><br><span class="line">                    <span class="string">"room.expandProjection"</span>:<span class="string">"true"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用实体定义数据"><a href="#使用实体定义数据" class="headerlink" title="使用实体定义数据"></a>使用实体定义数据</h2><p>以下代码段展示了如何定义实体：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">var</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">var</span> firstName: String?,</span><br><span class="line">    <span class="keyword">var</span> lastName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>要保留某个字段，Room 必须拥有该字段的访问权限。您可以将某个字段设为公开字段，也可以为其提供 getter 和 setter。如果您使用 getter 和 setter 方法，则请注意，这些方法需遵循 Room 中的 JavaBeans 规范。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：实体可以具有空的构造函数（如果相应的 <a href="https://developer.android.com/training/data-storage/room/accessing-data" target="_blank" rel="noopener">DAO</a> 类可以访问保留的每个字段），也可以具有其参数包含的类型和名称与该实体中字段的类型和名称一致的构造函数。Room 还可以使用完整或部分构造函数，例如仅接收部分字段的构造函数。</p>
</blockquote>
<h3 id="使用主键"><a href="#使用主键" class="headerlink" title="使用主键"></a>使用主键</h3><p>  每个实体必须将至少 1 个字段定义为主键。即使只有 1 个字段，您仍然需要为该字段添加 <a href="https://developer.android.com/reference/androidx/room/PrimaryKey" target="_blank" rel="noopener"><code>@PrimaryKey</code></a> 注释。此外，如果您想让 Room 为实体分配自动 ID，则可以设置 <code>@PrimaryKey</code> 的 <a href="https://developer.android.com/reference/androidx/room/PrimaryKey#autoGenerate()" target="_blank" rel="noopener"><code>autoGenerate</code></a> 属性。如果实体具有复合主键，您可以使用 <a href="https://developer.android.com/reference/androidx/room/Entity" target="_blank" rel="noopener"><code>@Entity</code></a> 注释的 <a href="https://developer.android.com/reference/androidx/room/Entity#primaryKeys()" target="_blank" rel="noopener"><code>primaryKeys</code></a> 属性，如</p>
<p>以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(primaryKeys = arrayOf(<span class="meta-string">"firstName"</span>, <span class="meta-string">"lastName"</span>)</span>)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="keyword">val</span> lastName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>  默认情况下，Room 将类名称用作数据库表名称。如果您希望表具有不同的名称，请设置 <a href="https://developer.android.com/reference/androidx/room/Entity" target="_blank" rel="noopener"><code>@Entity</code></a> 注释的 <a href="https://developer.android.com/reference/androidx/room/Entity#tableName()" target="_blank" rel="noopener"><code>tableName</code></a> 属性，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">"users"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：SQLite 中的表名称不区分大小写。</p>
</blockquote>
<p>与 <a href="https://developer.android.com/reference/androidx/room/Entity#tableName()" target="_blank" rel="noopener"><code>tableName</code></a> 属性类似，Room 将字段名称用作数据库中的列名称。如果您希望列具有不同的名称，请将 <a href="https://developer.android.com/reference/androidx/room/ColumnInfo" target="_blank" rel="noopener"><code>@ColumnInfo</code></a> 注释添加到字段，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">"users"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"first_name"</span>)</span> <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"last_name"</span>)</span> <span class="keyword">val</span> lastName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="忽略字段"><a href="#忽略字段" class="headerlink" title="忽略字段"></a>忽略字段</h3><p>  默认情况下，Room 会为在实体中定义的每个字段创建一个列。如果某个实体中有您不想保留的字段，则可以使用 <a href="https://developer.android.com/reference/androidx/room/Ignore" target="_blank" rel="noopener"><code>@Ignore</code></a> 为这些字段注释，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="keyword">val</span> lastName: String?,</span><br><span class="line">    <span class="meta">@Ignore</span> <span class="keyword">val</span> picture: Bitmap?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果实体继承了父实体的字段，则使用 <code>@Entity</code> 属性的 <a href="https://developer.android.com/reference/androidx/room/Entity#ignoredcolumns" target="_blank" rel="noopener"><code>ignoredColumns</code></a> 属性通常会更容易：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> picture: Bitmap? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity(ignoredColumns = arrayOf(<span class="meta-string">"picture"</span>)</span>)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteUser</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> hasVpn: <span class="built_in">Boolean</span></span><br><span class="line">) : User()</span><br></pre></td></tr></table></figure>



<h3 id="提供表搜索支持"><a href="#提供表搜索支持" class="headerlink" title="提供表搜索支持"></a>提供表搜索支持</h3><blockquote>
<p>Room 支持多种类型的注释，可让您更轻松地搜索数据库表中的详细信息。</p>
<p>除非应用的 <code>minSdkVersion</code> 低于 16，否则请使用全文搜索。</p>
</blockquote>
<h4 id="支持全文搜索-FTS：Full-text-Search"><a href="#支持全文搜索-FTS：Full-text-Search" class="headerlink" title="支持全文搜索(FTS：Full-text Search)"></a>支持全文搜索(FTS：Full-text Search)</h4><p>如果您的应用需要通过全文搜索 (FTS) 快速访问数据库信息，请使用虚拟表（使用 FTS3 或 FTS4 SQLite 扩展模块）为您的实体提供支持。要使用 Room 2.1.0 及更高版本中提供的这项功能，请将 @Fts3 或 @Fts4 注释添加到给定实体，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use `@Fts3` only if your app has strict disk space requirements or if you</span></span><br><span class="line"><span class="comment">// require compatibility with an older SQLite version.</span></span><br><span class="line"><span class="meta">@Fts4</span></span><br><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">"users"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="comment">/* Specifying a primary key for an FTS-table-backed entity is optional, but</span></span><br><span class="line"><span class="comment">       if you include one, it must use this type and column name. */</span></span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="meta">@ColumnInfo(name = <span class="meta-string">"rowid"</span>)</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"first_name"</span>)</span> <span class="keyword">val</span> firstName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：启用 FTS 的表始终使用 <code>INTEGER</code> 类型的主键且列名称为“rowid”。如果是由 FTS 表支持的实体定义主键，则<strong>必须</strong>使用相应的类型和列名称。</p>
<p>如果表支持以多种语言显示的内容，请使用 <code>languageId</code> 选项指定用于存储每一行语言信息的列：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Fts4(languageId = <span class="meta-string">"lid"</span>)</span></span><br><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">"users"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"lid"</span>)</span> <span class="keyword">val</span> languageId: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Room 提供了其他几个选项来定义由 FTS 支持的实体，包括结果排序、令牌生成器类型以及作为外部内容管理的表。如需详细了解这些选项，请参阅 <a href="https://developer.android.com/reference/androidx/room/FtsOptions" target="_blank" rel="noopener"><code>FtsOptions</code></a> 参考。</p>
</blockquote>
<h4 id="将特定列编入索引"><a href="#将特定列编入索引" class="headerlink" title="将特定列编入索引"></a>将特定列编入索引</h4><p>  如果您的应用必须支持不允许使用由 FTS3 或 FTS4 表支持的实体的 SDK 版本，您仍可以将数据库中的某些列编入索引，以加快查询速度。要为实体添加索引，请在 <a href="https://developer.android.com/reference/androidx/room/Entity" target="_blank" rel="noopener"><code>@Entity</code></a> 注释中添加 <a href="https://developer.android.com/reference/androidx/room/Entity#indices()" target="_blank" rel="noopener"><code>indices</code></a> 属性，以列出要在索引或复合索引中包含的列的名称。</p>
<p>以下代码段演示了此注释过程：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(indices = arrayOf(Index(value = [<span class="meta-string">"last_name"</span>, <span class="meta-string">"address"</span>])</span>))</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="keyword">val</span> address: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"last_name"</span>)</span> <span class="keyword">val</span> lastName: String?,</span><br><span class="line">    <span class="meta">@Ignore</span> <span class="keyword">val</span> picture: Bitmap?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>  有时，数据库中的某些字段或字段组必须是唯一的。您可以通过将 <a href="https://developer.android.com/reference/androidx/room" target="_blank" rel="noopener"><code>@Index</code></a> 注释的 <a href="https://developer.android.com/reference/androidx/room#unique()" target="_blank" rel="noopener"><code>unique</code></a> 属性设为 <code>true</code> 来强制实施此唯一性属性。</p>
<p>  以下代码示例可防止表格具有包含 <code>firstName</code> 和 <code>lastName</code> 列的同一组值的两行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(indices = arrayOf(Index(value = [<span class="meta-string">"first_name"</span>, <span class="meta-string">"last_name"</span>],</span></span><br><span class="line"><span class="meta">        unique = true)</span>))</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"first_name"</span>)</span> <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"last_name"</span>)</span> <span class="keyword">val</span> lastName: String?,</span><br><span class="line">    <span class="meta">@Ignore</span> <span class="keyword">var</span> picture: Bitmap?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="添加基于AutoValue的对象"><a href="#添加基于AutoValue的对象" class="headerlink" title="添加基于AutoValue的对象"></a>添加基于AutoValue的对象</h3><blockquote>
<p>此功能旨在用于基于 Java 的实体。要在基于 Kotlin 的实体中实现相同的功能，最好改用<a href="https://kotlinlang.org/docs/reference/data-classes.html" target="_blank" rel="noopener">数据类</a>。</p>
</blockquote>
<p>  在 Room 2.1.0 及更高版本中，您可以将基于 Java 的<a href="https://github.com/google/auto/blob/master/value/userguide/index.md">不可变值类</a>（使用 <code>@AutoValue</code> 为其注释）用作应用的数据库中的实体。此支持在实体的两个实例被视为相等（如果这两个实例的列包含相同的值）时尤为有用。</p>
<p>  将带有 <code>@AutoValue</code> 注释的类用作实体时，您可以使用 <code>@PrimaryKey</code>、<code>@ColumnInfo</code>、<code>@Embedded</code> 和 <code>@Relation</code> 为类的抽象方法注释。不过，您必须在每次使用这些注释时添加 <code>@CopyAnnotations</code> 注释，以便 Room 可以正确解释这些方法的自动生成实现。</p>
<p>以下代码段展示了一个使用 <code>@AutoValue</code> 注释的类（Room 将其标识为实体）的示例：</p>
<p>User.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoValue</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Supported annotations must include `@CopyAnnotations`.</span></span><br><span class="line">    <span class="meta">@CopyAnnotations</span></span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getFirstName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getLastName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Room uses this factory method to create User objects.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">create</span><span class="params">(<span class="keyword">long</span> id, String firstName, String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoValue_User(id, firstName, lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="定义对象之间的关系"><a href="#定义对象之间的关系" class="headerlink" title="定义对象之间的关系"></a>定义对象之间的关系</h2><blockquote>
<p>由于 SQLite 是关系型数据库，因此您可以指定各个对象之间的关系。尽管大多数对象关系映射库都允许实体对象互相引用，但 Room 明确禁止这样做</p>
</blockquote>
<h3 id="定义一对多关系"><a href="#定义一对多关系" class="headerlink" title="定义一对多关系"></a>定义一对多关系</h3><p>即使您不能使用直接关系，Room 仍允许您定义实体之间的外键约束。</p>
<p>例如，如果存在另一个名为 <code>Book</code> 的实体，您可以使用 <a href="https://developer.android.com/reference/androidx/room/ForeignKey" target="_blank" rel="noopener"><code>@ForeignKey</code></a> 注释定义该实体与 <code>User</code> 实体的关系，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(foreignKeys = arrayOf(ForeignKey(</span></span><br><span class="line"><span class="meta">            entity = User::class,</span></span><br><span class="line"><span class="meta">            parentColumns = arrayOf(<span class="meta-string">"id"</span>)</span>,</span><br><span class="line">            childColumns = arrayOf(<span class="string">"user_id"</span>))</span><br><span class="line">       )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> bookId: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> title: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"user_id"</span>)</span> <span class="keyword">val</span> userId: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>  由于零个或更多个 <code>Book</code> 实例可以通过 <code>user_id</code> 外键关联到一个 <code>User</code> 实例，因此这会在 <code>User</code> 和 <code>Book</code> 之间构建一对多关系模型。</p>
<p>  外键非常强大，可让您指定引用的实体更新后会发生什么。例如，您可以通过在 <a href="https://developer.android.com/reference/androidx/room/ForeignKey" target="_blank" rel="noopener"><code>@ForeignKey</code></a> 注释中添加 <a href="https://developer.android.com/reference/androidx/room/ForeignKey#onDelete()" target="_blank" rel="noopener"><code>onDelete = CASCADE</code></a>，在 <code>User</code> 的对应实例删除后告知 SQLite 删除该用户的所有图书。</p>
<blockquote>
<p><strong>注意</strong>：SQLite 将 <a href="https://developer.android.com/reference/androidx/room/OnConflictStrategy#REPLACE" target="_blank" rel="noopener"><code>@Insert(onConflict = REPLACE)</code></a> 作为一组 <code>REMOVE</code> 和 <code>REPLACE</code> 操作（而不是单个 <code>UPDATE</code> 操作）处理。这种替换冲突值的方法可能会影响您的外键约束。如需了解详情，请参阅有关 <code>ON_CONFLICT</code> 子句的 <a href="https://sqlite.org/lang_conflict.html" target="_blank" rel="noopener">SQLite 文档</a>。</p>
</blockquote>
<h3 id="创建嵌套对象"><a href="#创建嵌套对象" class="headerlink" title="创建嵌套对象"></a>创建嵌套对象</h3><p>  有时，您可能希望在数据库逻辑中将某个实体或数据对象表示为一个紧密的整体，即使该对象包含多个字段也是如此。在这些情况下，您可以使用 <a href="https://developer.android.com/reference/androidx/room/Embedded" target="_blank" rel="noopener"><code>@Embedded</code></a> 注释表示要解构到表中其子字段的对象。然后，您可以像查询其他各个列一样查询嵌套字段。</p>
<p>  例如，您的 <code>User</code> 类可以包含类型 <code>Address</code> 的字段，该类型表示一组分别名为 <code>street</code>、<code>city</code>、<code>state</code> 和 <code>postCode</code> 的字段。要在表中单独存储组成的列，请在 <code>User</code> 类（使用 <a href="https://developer.android.com/reference/androidx/room/Embedded" target="_blank" rel="noopener"><code>@Embedded</code></a> 注释）中添加 <code>Address</code> 字段，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>(</span><br><span class="line">    <span class="keyword">val</span> street: String?,</span><br><span class="line">    <span class="keyword">val</span> state: String?,</span><br><span class="line">    <span class="keyword">val</span> city: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"post_code"</span>)</span> <span class="keyword">val</span> postCode: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="meta">@Embedded</span> <span class="keyword">val</span> address: Address?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>  然后，表示 <code>User</code> 对象的表会包含具有以下名称的列：<code>id</code>、<code>firstName</code>、<code>street</code>、<code>state</code>、<code>city</code> 和 <code>post_code</code>。</p>
<blockquote>
<p><strong>注意</strong>：嵌套字段还可以包含其他嵌套字段。</p>
</blockquote>
<p>  如果某个实体具有同一类型的多个嵌套字段，您可以通过设置 <a href="https://developer.android.com/reference/androidx/room/Embedded#prefix()" target="_blank" rel="noopener"><code>prefix</code></a> 属性确保每个列都独一无二。然后，Room 会将提供的值添加到嵌套对象中每个列名称的开头。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embedded(prefix = <span class="meta-string">"loc_"</span>)</span></span><br><span class="line"> Coordinates coordinates;</span><br></pre></td></tr></table></figure>



<h3 id="定义多对多关系"><a href="#定义多对多关系" class="headerlink" title="定义多对多关系"></a>定义多对多关系</h3><p>  您通常希望在关系型数据库中构建的另一种关系模型是两个实体之间的多对多关系，其中每个实体都可以关联到另一个实体的零个或更多个实例。</p>
<p>  例如，假设有一个音乐在线播放应用，用户可以在该应用中将自己喜爱的歌曲整理到播放列表中。每个播放列表都可以包含任意数量的歌曲，每首歌曲都可以包含在任意数量的播放列表中。</p>
<p>要构建这种关系的模型，您需要创建下面三个对象：</p>
<ol>
<li>播放列表的实体类。</li>
<li>歌曲的实体类。</li>
<li>用于保存每个播放列表中的歌曲相关信息的中间类。</li>
</ol>
<p>您可以将实体类定义为独立单元：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Playlist</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">var</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> name: String?,</span><br><span class="line">    <span class="keyword">val</span> description: String?</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Song</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">var</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> songName: String?,</span><br><span class="line">    <span class="keyword">val</span> artistName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>  然后，将中间类定义为包含对 <code>Song</code> 和 <code>Playlist</code> 的外键引用的实体：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">"playlist_song_join"</span>,</span></span><br><span class="line"><span class="meta">        primaryKeys = arrayOf(<span class="meta-string">"playlistId"</span>,<span class="meta-string">"songId"</span>)</span>,</span><br><span class="line">        foreignKeys = arrayOf(</span><br><span class="line">                         ForeignKey(entity = Playlist::<span class="class"><span class="keyword">class</span>,<span class="type"></span></span></span><br><span class="line">                                    parentColumns = arrayOf(<span class="string">"id"</span>),</span><br><span class="line">                                    childColumns = arrayOf(<span class="string">"playlistId"</span>)),</span><br><span class="line">                         ForeignKey(entity = Song::<span class="class"><span class="keyword">class</span>,<span class="type"></span></span></span><br><span class="line">                                    parentColumns = arrayOf(<span class="string">"id"</span>),</span><br><span class="line">                                    childColumns = arrayOf(<span class="string">"songId"</span>))</span><br><span class="line">                              )</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaylistSongJoin</span></span>(</span><br><span class="line">    <span class="keyword">val</span> playlistId: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> songId: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>  这会生成一个多对多关系模型。借助该模型，您可以使用 DAO 按歌曲查询播放列表和按播放列表查询歌曲：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PlaylistSongJoinDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(playlistSongJoin: <span class="type">PlaylistSongJoin</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"""</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           SELECT * FROM playlist</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           INNER JOIN playlist_song_join</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           ON playlist.id=playlist_song_join.playlistId</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           WHERE playlist_song_join.songId=:songId</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           """</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPlaylistsForSong</span><span class="params">(songId: <span class="type">Int</span>)</span></span>: Array&lt;Playlist&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"""</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           SELECT * FROM song</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           INNER JOIN playlist_song_join</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           ON song.id=playlist_song_join.songId</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           WHERE playlist_song_join.playlistId=:playlistId</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">           """</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getSongsForPlaylist</span><span class="params">(playlistId: <span class="type">Int</span>)</span></span>: Array&lt;Song&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="在数据库中创建视图"><a href="#在数据库中创建视图" class="headerlink" title="在数据库中创建视图"></a>在数据库中创建视图</h2><blockquote>
<p>2.1.0 及更高版本的 <a href="https://developer.android.com/training/data-storage/room" target="_blank" rel="noopener">Room 持久性库</a>为 <a href="https://www.sqlite.org/lang_createview.html" target="_blank" rel="noopener">SQLite 数据库视图</a>提供了支持，从而允许您将查询封装到类中。Room 将这些查询支持的类称为视图，在 <a href="https://developer.android.com/training/data-storage/room/accessing-data" target="_blank" rel="noopener">DAO</a> 中使用时，它们的行为与简单数据对象的行为相同。</p>
<p><strong>注意</strong>：与<a href="https://developer.android.com/training/data-storage/room/defining-data" target="_blank" rel="noopener">实体</a>类似，您可以针对视图运行 <code>SELECT</code> 语句。不过，您无法针对视图运行 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 语句。</p>
</blockquote>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>要创建视图，请将 <a href="https://developer.android.com/reference/androidx/room/DatabaseView" target="_blank" rel="noopener"><code>@DatabaseView</code></a> 注释添加到类中。将注释的值设为类应该表示的查询。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DatabaseView(<span class="meta-string">"SELECT user.id, user.name, user.departmentId,"</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"department.name AS departmentName FROM user "</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"INNER JOIN department ON user.departmentId = department.id"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetail</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="keyword">val</span> name: String?,</span><br><span class="line">    <span class="keyword">val</span> departmentId: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="keyword">val</span> departmentName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="将视图与数据库相关联"><a href="#将视图与数据库相关联" class="headerlink" title="将视图与数据库相关联"></a>将视图与数据库相关联</h3><p>要将此视图添加为应用数据库的一部分，请在应用的 <code>@Database</code> 注释中添加 <a href="https://developer.android.com/reference/androidx/room/Database#views" target="_blank" rel="noopener"><code>views</code></a> 属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = arrayOf(User::class)</span>,</span><br><span class="line">          views = arrayOf(UserDetail::<span class="class"><span class="keyword">class</span>), <span class="type">version = 1)</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">userDao</span><span class="params">()</span></span>: UserDao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用DAO访问数据"><a href="#使用DAO访问数据" class="headerlink" title="使用DAO访问数据"></a>使用DAO访问数据</h2><blockquote>
<p>要使用 <a href="https://developer.android.com/training/data-storage/room" target="_blank" rel="noopener">Room 持久性库</a>访问应用的数据，您需要使用数据访问对象 (DAO)。这些 <a href="https://developer.android.com/reference/androidx/room/Dao" target="_blank" rel="noopener"><code>Dao</code></a> 对象构成了 Room 的主要组件，因为每个 DAO 都包含一些方法，这些方法提供对应用数据库的抽象访问权限。</p>
</blockquote>
<blockquote>
<p>DAO 既可以是接口，也可以是抽象类。如果是抽象类，则该 DAO 可以选择有一个以 <a href="https://developer.android.com/reference/androidx/room/RoomDatabase" target="_blank" rel="noopener"><code>RoomDatabase</code></a> 为唯一参数的构造函数。Room 会在编译时创建每个 DAO 实现。</p>
<p><strong>注意</strong>：除非您对构建器调用 <a href="https://developer.android.com/reference/androidx/room/RoomDatabase.Builder#allowMainThreadQueries()" target="_blank" rel="noopener"><code>allowMainThreadQueries()</code></a>，否则 Room 不支持在主线程上访问数据库，因为它可能会长时间锁定界面。异步查询（返回 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 或 <a href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html" target="_blank" rel="noopener"><code>Flowable</code></a> 实例的查询）无需遵守此规则，因为此类查询会根据需要在后台线程上异步运行查询。</p>
</blockquote>
<h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><p>  当您创建 DAO 方法并使用 <a href="https://developer.android.com/reference/androidx/room/Insert" target="_blank" rel="noopener"><code>@Insert</code></a> 对其进行注释时，Room 会生成一个实现，该实现在单个事务中将所有参数插入到数据库中。</p>
<p>以下代码段展示了几个示例查询：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertBothUsers</span><span class="params">(user1: <span class="type">User</span>, user2: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertUsersAndFriends</span><span class="params">(user: <span class="type">User</span>, friends: <span class="type">List</span>&lt;<span class="type">User</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <a href="https://developer.android.com/reference/androidx/room/Insert" target="_blank" rel="noopener"><code>@Insert</code></a> 方法只接收 1 个参数，则可返回 <code>long</code>，这是插入项的新 <code>rowId</code>。如果参数是数组或集合，则应返回 <code>long[]</code> 或 <code>List</code>。</p>
<blockquote>
<p>如需了解详情，请参阅 <a href="https://developer.android.com/reference/androidx/room/Insert" target="_blank" rel="noopener"><code>@Insert</code></a> 注释的参考文档以及 <a href="https://www.sqlite.org/rowidtable.html" target="_blank" rel="noopener">rowid 表格的 SQLite 文档</a>。</p>
</blockquote>
<h4 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h4><p><a href="https://developer.android.com/reference/androidx/room/Update" target="_blank" rel="noopener"><code>Update</code></a> 便捷方法会修改数据库中以参数形式给出的一组实体。它使用与每个实体的主键匹配的查询。</p>
<p>以下代码段演示了如何定义此方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然通常没有必要，但您可以让此方法返回一个 <code>int</code> 值，表示数据库中更新的行数</p>
</blockquote>
<h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><p><a href="https://developer.android.com/reference/androidx/room/Delete" target="_blank" rel="noopener"><code>Delete</code></a> 便捷方法会从数据库中删除一组以参数形式给出的实体。它使用主键查找要删除的实体。</p>
<p>以下代码段演示了如何定义此方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然通常没有必要，但您可以让此方法返回一个 <code>int</code> 值，表示从数据库中删除的行数。</p>
</blockquote>
<h3 id="查询信息"><a href="#查询信息" class="headerlink" title="查询信息"></a>查询信息</h3><blockquote>
<p> <a href="https://developer.android.com/reference/androidx/room/Query" target="_blank" rel="noopener"><code>@Query</code></a> 是 DAO 类中使用的主要注释。它允许您对数据库执行读/写操作。每个 <a href="https://developer.android.com/reference/androidx/room/Query" target="_blank" rel="noopener"><code>@Query</code></a> 方法都会在编译时进行验证，因此如果查询出现问题，则会发生编译错误，而不是运行时失败。</p>
<p> Room 还会验证查询的返回值，这样的话，当返回的对象中的字段名称与查询响应中的对应列名称不匹配时，Room 会通过以下两种方式之一提醒您：</p>
<ul>
<li><p>如果只有部分字段名称匹配，则会发出警告。</p>
</li>
<li><p>如果没有任何字段名称匹配，则会发出错误。</p>
</li>
</ul>
</blockquote>
<h4 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadAllUsers</span><span class="params">()</span></span>: Array&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一个极其简单的查询，可加载所有用户。在编译时，Room 知道它在查询用户表中的所有列。如果查询包含语法错误，或者数据库中没有用户表格，则 Room 会在您的应用编译时显示包含相应消息的错误。</p>
</blockquote>
<h4 id="将参数传递给查询"><a href="#将参数传递给查询" class="headerlink" title="将参数传递给查询"></a>将参数传递给查询</h4><p>在大多数情况下，您需要将参数传递给查询以执行过滤操作，例如仅显示某个年龄以上的用户。要完成此任务，请在 Room 注释中使用方法参数，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user WHERE age &gt; :minAge"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadAllUsersOlderThan</span><span class="params">(minAge: <span class="type">Int</span>)</span></span>: Array&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在编译时处理此查询时，Room 会将 <code>:minAge</code> 绑定参数与 <code>minAge</code> 方法参数相匹配。Room 通过参数名称进行匹配。如果有不匹配的情况，则应用编译时会出现错误。</p>
</blockquote>
<p>您还可以在查询中传递多个参数或多次引用这些参数，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadAllUsersBetweenAges</span><span class="params">(minAge: <span class="type">Int</span>, maxAge: <span class="type">Int</span>)</span></span>: Array&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user WHERE first_name LIKE :search "</span> +</span></span><br><span class="line"><span class="meta">           <span class="meta-string">"OR last_name LIKE :search"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findUserWithName</span><span class="params">(search: <span class="type">String</span>)</span></span>: List&lt;User&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="返回列的子集"><a href="#返回列的子集" class="headerlink" title="返回列的子集"></a>返回列的子集</h4><p>  大多数情况下，您只需获取实体的几个字段。例如，您的界面可能仅显示用户的名字和姓氏，而不是用户的每一条详细信息。通过仅提取应用界面中显示的列，您可以节省宝贵的资源，并且您的查询也能更快完成。</p>
<p>  借助 Room，您可以从查询中返回任何基于 Java 的对象，前提是结果列集合会映射到返回的对象。例如，您可以创建以下基于 Java 的普通对象 (POJO) 来获取用户的名字和姓氏：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">NameTuple</span></span>(</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"first_name"</span>)</span> <span class="keyword">val</span> firstName: String?,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">"last_name"</span>)</span> <span class="keyword">val</span> lastName: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>现在，您可以在查询方法中使用此 POJO：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT first_name, last_name FROM user"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadFullName</span><span class="params">()</span></span>: List&lt;NameTuple&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  Room 知道该查询会返回 <code>first_name</code> 和 <code>last_name</code> 列的值，并且这些值会映射到 <code>NameTuple</code> 类的字段。因此，Room 可以生成正确的代码。如果查询返回太多的列，或者返回 <code>NameTuple</code> 类中不存在的列，则 Room 会显示一条警告。</p>
<blockquote>
<p><strong>注意</strong>：这些 POJO 也可以使用 <a href="https://developer.android.com/reference/androidx/room/Embedded" target="_blank" rel="noopener"><code>@Embedded</code></a> 注释。</p>
</blockquote>
<h4 id="传递参数的集合"><a href="#传递参数的集合" class="headerlink" title="传递参数的集合"></a>传递参数的集合</h4><p>  部分查询可能要求您传入数量不定的参数，参数的确切数量要到运行时才知道。例如，您可能希望从部分区域中检索所有用户的相关信息。Room 知道参数何时表示集合，并根据提供的参数数量在运行时自动将其展开。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT first_name, last_name FROM user WHERE region IN (:regions)"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadUsersFromRegions</span><span class="params">(regions: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;NameTuple&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="可观察查询"><a href="#可观察查询" class="headerlink" title="可观察查询"></a>可观察查询</h4><p>  执行查询时，您通常会希望应用的界面在数据发生变化时自动更新。为此，请在查询方法说明中使用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 类型的返回值。当数据库更新时，Room 会生成更新 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 所必需的所有代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT first_name, last_name FROM user WHERE region IN (:regions)"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadUsersFromRegionsSync</span><span class="params">(regions: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: LiveData&lt;List&lt;User&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：自版本 1.0 起，Room 会根据在查询中访问的表格列表决定是否更新 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 实例。</p>
</blockquote>
<h4 id="使用RxJava进行响应式查询"><a href="#使用RxJava进行响应式查询" class="headerlink" title="使用RxJava进行响应式查询"></a>使用RxJava进行响应式查询</h4><p>Room 为 RxJava2 类型的返回值提供了以下支持：</p>
<ul>
<li><code>@Query</code> 方法：Room 支持 <a href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html" target="_blank" rel="noopener"><code>Publisher</code></a>、<a href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html" target="_blank" rel="noopener"><code>Flowable</code></a> 和 <a href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html" target="_blank" rel="noopener"><code>Observable</code></a> 类型的返回值。</li>
<li><code>@Insert</code>、<code>@Update</code> 和 <code>@Delete</code> 方法：Room 2.1.0 及更高版本支持 <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Completable.html" target="_blank" rel="noopener"><code>Completable</code></a>、<a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Single.html" target="_blank" rel="noopener"><code>Single</code></a> 和 <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Maybe.html" target="_blank" rel="noopener"><code>Maybe</code></a> 类型的返回值。</li>
</ul>
<p>要使用此功能，请在应用的 <code>build.gradle</code> 文件中添加最新版本的 <strong>rxjava2</strong> 工件：</p>
<p>app/build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;    </span><br><span class="line">  <span class="keyword">def</span> room_version = <span class="string">"2.1.0"</span>    </span><br><span class="line">  implementation <span class="string">'androidx.room:room-rxjava2:$room_version'</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码段展示了几个如何使用这些返回类型的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * from user where id = :id LIMIT 1"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadUserById</span><span class="params">(id: <span class="type">Int</span>)</span></span>: Flowable&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emits the number of users added to the database.</span></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertLargeNumberOfUsers</span><span class="params">(users: <span class="type">List</span>&lt;<span class="type">User</span>&gt;)</span></span>: Maybe&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure that the operation finishes successfully.</span></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertLargeNumberOfUsers</span><span class="params">(varargs users: <span class="type">User</span>)</span></span>: Completable</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Emits the number of users removed from the database. Always emits at</span></span><br><span class="line"><span class="comment">       least one user. */</span></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteAllUsers</span><span class="params">(users: <span class="type">List</span>&lt;<span class="type">User</span>&gt;)</span></span>: Single&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参阅 Google Developers <a href="https://medium.com/google-developers/room-rxjava-acb0cd4f3757" target="_blank" rel="noopener">Room 和 RxJava</a> 一文</p>
</blockquote>
<h4 id="直接光标访问"><a href="#直接光标访问" class="headerlink" title="直接光标访问"></a>直接光标访问</h4><p>如果应用的逻辑需要直接访问返回行，您可以从查询返回 <code>Cursor</code> 对象，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user WHERE age &gt; :minAge LIMIT 5"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadRawUsersOlderThan</span><span class="params">(minAge: <span class="type">Int</span>)</span></span>: Cursor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：强烈建议您不要使用 Cursor API，因为它无法保证行是否存在或者行包含哪些值。只有当您已具有需要光标且无法轻松重构的代码时，才使用此功能。</p>
</blockquote>
<h4 id="查询多个表格"><a href="#查询多个表格" class="headerlink" title="查询多个表格"></a>查询多个表格</h4><p>  部分查询可能需要访问多个表格才能计算出结果。借助 Room，您可以编写任何查询，因此您也可以联接表格。此外，如果响应是可观察数据类型（如 <a href="http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html" target="_blank" rel="noopener"><code>Flowable</code></a> 或 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a>），Room 会观察查询中引用的所有表格，以确定是否存在无效表格。</p>
<p>  以下代码段展示了如何执行表格联接来整合两个表格的信息：一个表格包含当前借阅图书的用户，另一个表格包含当前处于已被借阅状态的图书的数据。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"SELECT * FROM book "</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"INNER JOIN loan ON loan.book_id = book.id "</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"INNER JOIN user ON user.id = loan.user_id "</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"WHERE user.name LIKE :userName"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findBooksBorrowedByNameSync</span><span class="params">(userName: <span class="type">String</span>)</span></span>: List&lt;Book&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>您还可以从这些查询中返回 POJO。例如，您可以编写一条加载某位用户及其宠物名字的查询，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"SELECT user.name AS userName, pet.name AS petName "</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"FROM user, pet "</span> +</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"WHERE user.id = pet.user_id"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadUserAndPetNames</span><span class="params">()</span></span>: LiveData&lt;List&lt;UserPet&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You can also define this class in a separate file.</span></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPet</span></span>(<span class="keyword">val</span> userName: String?, <span class="keyword">val</span> petName: String?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用Kotlin协程编写异步方法"><a href="#使用Kotlin协程编写异步方法" class="headerlink" title="使用Kotlin协程编写异步方法"></a>使用Kotlin协程编写异步方法</h4><p>将 <code>suspend</code> Kotlin 关键字添加到 DAO 方法，以使用 Kotlin 协程功能使这些方法成为异步方法。这样可确保不会在主线程上执行这些方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Update</span></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Delete</span></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteUsers</span><span class="params">(<span class="keyword">vararg</span> users: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Query(<span class="meta-string">"SELECT * FROM user"</span>)</span></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadAllUsers</span><span class="params">()</span></span>: Array&lt;User&gt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：要将 Room 与 Kotlin 协程一起使用，您需要使用 Room 2.1.0、Kotlin 1.3.0 和 Cordoines 1.0.0 或更高版本。如需了解详情，请参阅<a href="https://developer.android.com/jetpack/androidx/releases/room#declaring_dependencies" target="_blank" rel="noopener">声明依赖项</a>。</p>
</blockquote>
<p>  本指南也适用于带有 <a href="https://developer.android.com/reference/androidx/room/Transaction" target="_blank" rel="noopener"><code>@Transaction</code></a> 注释的 DAO 方法。您可以使用此功能通过其他 DAO 方法构建暂停数据库方法。然后，这些方法会在单个数据库事务中运行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersDao</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Transaction</span></span><br><span class="line">        <span class="keyword">open</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">setLoggedInUser</span><span class="params">(loggedInUser: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            deleteUser(loggedInUser)</span><br><span class="line">            insertUser(loggedInUser)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Query(<span class="meta-string">"DELETE FROM users"</span>)</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteUser</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Insert</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertUser</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：应避免在单个数据库事务中执行额外的应用端工作，因为 Room 会将此类事务视为独占事务，并且按顺序每次仅执行一个事务。也就是说，包含不必要操作的事务很容易锁定您的数据库并影响性能。</p>
</blockquote>
<h2 id="预填充数据库"><a href="#预填充数据库" class="headerlink" title="预填充数据库"></a>预填充数据库</h2><h2 id="迁移数据库"><a href="#迁移数据库" class="headerlink" title="迁移数据库"></a>迁移数据库</h2><h2 id="测试和调试数据库"><a href="#测试和调试数据库" class="headerlink" title="测试和调试数据库"></a>测试和调试数据库</h2><h2 id="引用复杂数据"><a href="#引用复杂数据" class="headerlink" title="引用复杂数据"></a>引用复杂数据</h2><h3 id="使用类型转换器"><a href="#使用类型转换器" class="headerlink" title="使用类型转换器"></a>使用类型转换器</h3><h3 id="了解Room为何不允许对象引用"><a href="#了解Room为何不允许对象引用" class="headerlink" title="了解Room为何不允许对象引用"></a>了解Room为何不允许对象引用</h3><blockquote>
<p><strong>要点</strong>：Room 不允许实体类之间进行对象引用。因此，您必须明确请求您的应用所需的数据。</p>
<p>映射从数据库到相应对象模型之间的关系是一种常见做法，极其适用于服务器端。即使程序在访问字段时加载字段，服务器仍然可以正常工作。</p>
<p>但在客户端，这种延迟加载是不可行的，因为它通常发生在界面线程上，并且在界面线程上查询磁盘上的信息会导致严重的性能问题。界面线程通常需要大约 16 毫秒来计算和绘制 Activity 的更新后的布局，因此，即使查询只用了 5 毫秒，您的应用仍然可能会用尽剩余的时间来绘制框架，从而导致明显的显示故障。如果有一个并行运行的单独事务，或者设备正在运行其他磁盘密集型任务，则查询可能需要更多时间才能完成。不过，如果您不使用延迟加载，则应用会抓取一些不必要的数据，从而导致内存消耗问题。</p>
<p>对象关系型映射通常将决定权留给开发者，以便他们可以针对自己的应用用例执行最合适的操作。开发者通常会决定在应用和界面之间共享模型。不过，这种解决方案并不能很好地扩展，因为界面会不断发生变化，共享模型会出现开发者难以预测和调试的问题。</p>
<p>例如，假设界面加载了 <code>Book</code> 对象的列表，其中每本图书都有一个 <code>Author</code> 对象。您最初可能设计让查询使用延迟加载，从而让 <code>Book</code> 实例检索作者。对 <code>author</code> 字段的第一次检索会查询数据库。一段时间后，您发现还需要在应用的界面中显示作者姓名。您可以轻松访问此名称，如以下代码段所示：</p>
<p><code>authorNameTextView.text = book.author.name</code></p>
<p>不过，这种看似无害的更改会导致在主线程上查询 <code>Author</code> 表。</p>
<p>如果您事先查询作者信息，则在您不再需要这些数据时，就会很难更改数据加载方式。例如，如果应用的界面不再需要显示 <code>Author</code> 信息，则应用会有效地加载不再显示的数据，从而浪费宝贵的内存空间。如果 <code>Author</code> 类引用其他表（例如 <code>Books</code>），则应用的效率会进一步下降。</p>
<p>要使用 Room 同时引用多个实体，请改为创建包含每个实体的 POJO，然后编写用于联接相应表的查询。这种结构合理的模型结合 Room 强大的查询验证功能，可让您的应用在加载数据时消耗较少的资源，从而改善应用的性能和用户体验。</p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">liubo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://github.com/liuclub/liuclub.github.io.git/2020/05/28/8-Room%E6%8C%81%E4%B9%85%E6%80%A7%E5%BA%93/">https://github.com/liuclub/liuclub.github.io.git/2020/05/28/8-Room%E6%8C%81%E4%B9%85%E6%80%A7%E5%BA%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/28/9-ViewModel/"><i class="fa fa-chevron-left">  </i><span>9-ViewModel</span></a></div><div class="next-post pull-right"><a href="/2020/05/28/7-%E5%88%86%E9%A1%B5%E5%BA%93/"><span>7-分页库</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By liubo</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>