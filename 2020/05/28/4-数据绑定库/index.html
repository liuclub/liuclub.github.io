<!DOCTYPE html><html lang="[&quot;zh-tw&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="4-数据绑定库"><meta name="keywords" content=""><meta name="author" content="liubo"><meta name="copyright" content="liubo"><title>4-数据绑定库 | 凌晨三点的逗你玩</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#概览"><span class="toc-number">1.</span> <span class="toc-text">概览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-开始使用"><span class="toc-number">1.1.</span> <span class="toc-text">1. 开始使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-布局和绑定表达式"><span class="toc-number">1.2.</span> <span class="toc-text">2. 布局和绑定表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-使用可观察的数据对象"><span class="toc-number">1.3.</span> <span class="toc-text">3. 使用可观察的数据对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-生成的绑定类"><span class="toc-number">1.4.</span> <span class="toc-text">4. 生成的绑定类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-绑定适配器"><span class="toc-number">1.5.</span> <span class="toc-text">5. 绑定适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将布局视图绑定到架构组件"><span class="toc-number">1.6.</span> <span class="toc-text">将布局视图绑定到架构组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双向数据绑定"><span class="toc-number">1.7.</span> <span class="toc-text">双向数据绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用入门"><span class="toc-number">2.</span> <span class="toc-text">使用入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#布局和绑定表达式"><span class="toc-number">3.</span> <span class="toc-text">布局和绑定表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据对象"><span class="toc-number">3.1.</span> <span class="toc-text">数据对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绑定数据"><span class="toc-number">3.2.</span> <span class="toc-text">绑定数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表达式语言"><span class="toc-number">3.3.</span> <span class="toc-text">表达式语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺少的运算"><span class="toc-number">3.4.</span> <span class="toc-text">缺少的运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Null-合并运算符"><span class="toc-number">3.5.</span> <span class="toc-text">Null 合并运算符 (??)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性引用"><span class="toc-number">3.6.</span> <span class="toc-text">属性引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#避免出现-Null-指针异常"><span class="toc-number">3.7.</span> <span class="toc-text">避免出现 Null 指针异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集合"><span class="toc-number">3.8.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串"><span class="toc-number">3.9.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#资源"><span class="toc-number">3.10.</span> <span class="toc-text">资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件处理"><span class="toc-number">3.11.</span> <span class="toc-text">事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法引用"><span class="toc-number">3.11.1.</span> <span class="toc-text">方法引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#监听器绑定"><span class="toc-number">3.11.2.</span> <span class="toc-text">监听器绑定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#避免使用复杂的监听器"><span class="toc-number">3.11.3.</span> <span class="toc-text">避免使用复杂的监听器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#导入、变量和包含"><span class="toc-number">3.12.</span> <span class="toc-text">导入、变量和包含</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#导入"><span class="toc-number">3.12.1.</span> <span class="toc-text">导入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#变量"><span class="toc-number">3.12.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#包含"><span class="toc-number">3.12.3.</span> <span class="toc-text">包含</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用可观察的数据对象"><span class="toc-number">4.</span> <span class="toc-text">使用可观察的数据对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字段"><span class="toc-number">4.1.</span> <span class="toc-text">字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集合-1"><span class="toc-number">4.2.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象"><span class="toc-number">4.3.</span> <span class="toc-text">对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成的绑定类"><span class="toc-number">5.</span> <span class="toc-text">生成的绑定类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建绑定对象"><span class="toc-number">5.1.</span> <span class="toc-text">创建绑定对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#带ID的视图"><span class="toc-number">5.2.</span> <span class="toc-text">带ID的视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量-1"><span class="toc-number">5.3.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ViewStubs"><span class="toc-number">5.4.</span> <span class="toc-text">ViewStubs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#即时绑定"><span class="toc-number">5.5.</span> <span class="toc-text">即时绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高级绑定"><span class="toc-number">5.6.</span> <span class="toc-text">高级绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#动态变量"><span class="toc-number">5.6.1.</span> <span class="toc-text">动态变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#后台线程"><span class="toc-number">5.7.</span> <span class="toc-text">后台线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义绑定类名称"><span class="toc-number">5.8.</span> <span class="toc-text">自定义绑定类名称</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定适配器"><span class="toc-number">6.</span> <span class="toc-text">绑定适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#设置属性值"><span class="toc-number">6.1.</span> <span class="toc-text">设置属性值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#自动选择方法"><span class="toc-number">6.1.1.</span> <span class="toc-text">自动选择方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#指定自定义方法名称"><span class="toc-number">6.1.2.</span> <span class="toc-text">指定自定义方法名称</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#提供自定义逻辑"><span class="toc-number">6.1.3.</span> <span class="toc-text">提供自定义逻辑</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象转换"><span class="toc-number">6.2.</span> <span class="toc-text">对象转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#自动对象转换"><span class="toc-number">6.2.1.</span> <span class="toc-text">自动对象转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#自定义转换"><span class="toc-number">6.2.2.</span> <span class="toc-text">自定义转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将布局视图绑定到架构组件-1"><span class="toc-number">7.</span> <span class="toc-text">将布局视图绑定到架构组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用LiveData将数据变化通知给页面"><span class="toc-number">7.1.</span> <span class="toc-text">使用LiveData将数据变化通知给页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用ViewModel管理界面相关数据"><span class="toc-number">7.2.</span> <span class="toc-text">使用ViewModel管理界面相关数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Observable-ViewModel以更好地控制绑定适配器"><span class="toc-number">7.3.</span> <span class="toc-text">使用Observable ViewModel以更好地控制绑定适配器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双向数据绑定-1"><span class="toc-number">8.</span> <span class="toc-text">双向数据绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用自定义特性的双向数据绑定"><span class="toc-number">8.1.</span> <span class="toc-text">使用自定义特性的双向数据绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#转换器"><span class="toc-number">8.2.</span> <span class="toc-text">转换器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用双向数据绑定的无限循环"><span class="toc-number">8.3.</span> <span class="toc-text">使用双向数据绑定的无限循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双向特性"><span class="toc-number">8.4.</span> <span class="toc-text">双向特性</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">liubo</div><div class="author-info__description text-center">人最大的问题就是习惯自我辩解，但我们远比自己想象中更许巍、下作和幽暗。</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">凌晨三点的逗你玩</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">4-数据绑定库</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[TOC]</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><blockquote>
<p>数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。</p>
</blockquote>
<h4 id="1-开始使用"><a href="#1-开始使用" class="headerlink" title="1. 开始使用"></a>1. 开始使用</h4><p>了解如何准备开发环境以使用数据绑定库，包括在 Android Studio 中支持数据绑定代码。</p>
<h4 id="2-布局和绑定表达式"><a href="#2-布局和绑定表达式" class="headerlink" title="2. 布局和绑定表达式"></a>2. 布局和绑定表达式</h4><p>借助表达式语言，您可以编写将变量关联到布局中的视图的表达式。数据绑定库会自动生成将布局中的视图与您的数据对象绑定所需的类。该库提供了可在布局中使用的导入、变量和包含等功能。</p>
<p>该库的这些功能可与您的现有布局无缝地共存。例如，可以在表达式中使用的绑定变量在 <strong>data</strong> 元素（界面布局根元素的同级）内定义。这两个元素都封装在<strong>layout</strong> 标记中，如以下示例所示</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"viewmodel"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"com.myapp.data.ViewModel"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintLayout...</span> /&gt;</span> <span class="comment">&lt;!-- UI layout's root element --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-使用可观察的数据对象"><a href="#3-使用可观察的数据对象" class="headerlink" title="3. 使用可观察的数据对象"></a>3. 使用可观察的数据对象</h4><p>数据绑定库提供了可让您轻松地观察数据更改情况的类和方法。您不必操心在底层数据源发生更改时刷新界面。您可以将变量或其属性设为可观察。借助该库，您可以将对象、字段或集合设为可观察。</p>
<h4 id="4-生成的绑定类"><a href="#4-生成的绑定类" class="headerlink" title="4. 生成的绑定类"></a>4. 生成的绑定类</h4><p>数据绑定库可以生成用于访问布局变量和视图的绑定类。此页面展示了如何使用和自定义所生成的绑定类。</p>
<h4 id="5-绑定适配器"><a href="#5-绑定适配器" class="headerlink" title="5. 绑定适配器"></a>5. 绑定适配器</h4><p>每一个布局表达式都有一个对应的绑定适配器，要求必须进行框架调用来设置相应的属性或监听器。</p>
<p>例如，绑定适配器负责调用 setText() 方法来设置文本属性，或者调用 setOnClickListener() 方法向点击事件添加监听器。最常拥的绑定适配器（例如针对本页面的示例中使用的 android:text 属性）可供您在 android.databinding.adapters 软件包中使用。如需常用绑定适配器列表，请参阅适配器。您也可以按照以下示例所示创建自定义适配器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"app:goneUnless"</span>)</span></span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">goneUnless</span><span class="params">(view: <span class="type">View</span>, visible: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">     view.visibility = <span class="keyword">if</span> (visible) View.VISIBLE <span class="keyword">else</span> View.GONE</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>​    </p>
<h4 id="将布局视图绑定到架构组件"><a href="#将布局视图绑定到架构组件" class="headerlink" title="将布局视图绑定到架构组件"></a>将布局视图绑定到架构组件</h4><p>Android 支持库包含架构组件，您可以使用这些组件设计稳健、可测试且易维护的应用。您可以将架构组件与数据绑定库一起使用，以进一步简化界面开发。</p>
<h4 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h4><p>数据绑定库支持双向数据绑定。此类绑定使用的表示法支持以下操作：</p>
<ul>
<li>接收对属性的数据更改</li>
<li>监听用户对此属性的更新</li>
</ul>
<h3 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h3><p>在app的build.gradle文件中添加dataBinding元素</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ···</span><br><span class="line">  dataBinding &#123;</span><br><span class="line">    enabled = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="布局和绑定表达式"><a href="#布局和绑定表达式" class="headerlink" title="布局和绑定表达式"></a>布局和绑定表达式</h3><p><strong>数据绑定布局文件略有不同，以根标记 <code>layout</code> 开头，后跟 <code>data</code> 元素和 <code>view</code> 根元素。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String)</span><br></pre></td></tr></table></figure>

<h4 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h4><p>系统会为每个布局文件生成一个绑定类。默认情况下，类名称基于布局文件的名称，它会转换为 Pascal 大小写形式（<strong>大驼峰命名方式</strong>）并<strong>在末尾添加 Binding 后缀</strong>。以上布局文件名为 <code>activity_main.xml</code>，因此生成的对应类为 <code>ActivityMainBinding</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> binding: ActivityMainBinding = DataBindingUtil.setContentView(</span><br><span class="line">            <span class="keyword">this</span>, R.layout.activity_main)</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	val binding: ActivityMainBinding = ActivityMainBinding.inflate(getLayoutInflater())</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line"></span><br><span class="line">    binding.user = User(<span class="string">"Test"</span>, <span class="string">"User"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您要在 Fragment、ListView 或 RecyclerView 适配器中使用数据绑定项，您可能更愿意使用绑定类或 DataBindingUtil 类的 inflate() 方法，如以下代码示例所示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">val</span> listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h4 id="表达式语言"><a href="#表达式语言" class="headerlink" title="表达式语言"></a>表达式语言</h4><p>表达式语言与托管代码中的表达式非常相似。您可以在表达式语言中使用以下运算符和关键字：</p>
<ul>
<li>算术运算符 <code>+ - / * %</code></li>
<li>字符串连接运算符 <code>+</code></li>
<li>逻辑运算符 <code>&amp;&amp; ||</code></li>
<li>二元运算符 <code>&amp; | ^</code></li>
<li>一元运算符 <code>+ - ! ~</code></li>
<li>移位运算符 <code>&gt;&gt; &gt;&gt;&gt; &lt;&lt;</code></li>
<li>比较运算符 <code>== &gt; &lt; &gt;= &lt;=</code>（请注意，<code>&lt;</code> 需要转义为 <code>&lt;</code>）</li>
<li><code>instanceof</code></li>
<li>分组运算符 <code>()</code></li>
<li>字面量运算符 - 字符、字符串、数字、<code>null</code></li>
<li>类型转换</li>
<li>方法调用</li>
<li>字段访问</li>
<li>数组访问 <code>[]</code></li>
<li>三元运算符 <code>?:</code></li>
</ul>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:text&#x3D;&quot;@&#123;String.valueOf(index + 1)&#125;&quot;</span><br><span class="line">  android:visibility&#x3D;&quot;@&#123;age &gt; 13 ? View.GONE : View.VISIBLE&#125;&quot;</span><br><span class="line">  android:transitionName&#x3D;&#39;@&#123;&quot;image_&quot; + id&#125;&#39;</span><br></pre></td></tr></table></figure>

<h4 id="缺少的运算"><a href="#缺少的运算" class="headerlink" title="缺少的运算"></a>缺少的运算</h4><p>您可以在托管代码中使用的表达式语法中缺少以下运算：</p>
<ul>
<li><code>this</code></li>
<li><code>super</code></li>
<li><code>new</code></li>
<li>显式泛型调用</li>
</ul>
<h4 id="Null-合并运算符"><a href="#Null-合并运算符" class="headerlink" title="Null 合并运算符 (??)"></a>Null 合并运算符 (??)</h4><p>如果左边运算数不是 null，则 Null 合并运算符 (??) 选择左边运算数，如果左边运算数为 ，则选择右边运算数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text&#x3D;&quot;@&#123;user.displayName ?? user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>这在功能上等效于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text&#x3D;&quot;@&#123;user.displayName !&#x3D; null ? user.displayName : user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="属性引用"><a href="#属性引用" class="headerlink" title="属性引用"></a>属性引用</h4><p>表达式可以使用以下格式在类中引用属性，这对于<strong>字段、getter 和 ObservableField 对象</strong>都一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text&#x3D;&quot;@&#123;user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="避免出现-Null-指针异常"><a href="#避免出现-Null-指针异常" class="headerlink" title="避免出现 Null 指针异常"></a>避免出现 Null 指针异常</h4><p><strong>生成的数据绑定代码会自动检查有没有 null 值并避免出现 Null 指针异常。</strong>例如，在表达式 @{user.name} 中，如果 user 为 Null，则为 user.name 分配默认值 null。如果您引用 user.age，其中 age 的类型为 int，则数据绑定使用默认值 0。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>为方便起见，可使用 <code>[]</code> 运算符访问常见集合，例如数组、列表、稀疏列表和映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">        &lt;import type&#x3D;&quot;android.util.SparseArray&quot;&#x2F;&gt;</span><br><span class="line">        &lt;import type&#x3D;&quot;java.util.Map&quot;&#x2F;&gt;</span><br><span class="line">        &lt;import type&#x3D;&quot;java.util.List&quot;&#x2F;&gt;</span><br><span class="line">        &lt;variable name&#x3D;&quot;list&quot; type&#x3D;&quot;List&lt;String&gt;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;variable name&#x3D;&quot;sparse&quot; type&#x3D;&quot;SparseArray&lt;String&gt;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;variable name&#x3D;&quot;map&quot; type&#x3D;&quot;Map&lt;String, String&gt;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;variable name&#x3D;&quot;index&quot; type&#x3D;&quot;int&quot;&#x2F;&gt;</span><br><span class="line">        &lt;variable name&#x3D;&quot;key&quot; type&#x3D;&quot;String&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;data&gt;</span><br><span class="line">    …</span><br><span class="line">    android:text&#x3D;&quot;@&#123;list[index]&#125;&quot;</span><br><span class="line">    …</span><br><span class="line">    android:text&#x3D;&quot;@&#123;sparse[index]&#125;&quot;</span><br><span class="line">    …</span><br><span class="line">    android:text&#x3D;&quot;@&#123;map[key]&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>注意：要使 XML 不含语法错误，您必须转义 &lt; 字符。例如：不要写成 <strong>List<String></strong> 形式，而是必须写成<strong><code>List&amp;lt;String&gt;</code></strong>。</p>
<p>还可以使用 <code>object.key</code> 表示法在映射中引用值。例如，以上示例中的 <code>@{map[key]}</code> 可替换为 <code>@{map.key}</code>。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>使用单引号括住属性值，这样就可以在表达式中使用双引号，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:text&#x3D;&#39;@&#123;map[&quot;firstName&quot;]&#125;&#39;</span><br><span class="line">&lt;!-- 或者 --&gt;</span><br><span class="line">android:text&#x3D;&quot;@&#123;map[&#96;firstName&#96;]&#125;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>可以使用以下语法访问表达式中的资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:padding&#x3D;&quot;@&#123;large? @dimen&#x2F;largePadding : @dimen&#x2F;smallPadding&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>格式字符串和复数形式可通过提供参数进行求值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:text&#x3D;&quot;@&#123;@string&#x2F;nameFormat(firstName, lastName)&#125;&quot;</span><br><span class="line">android:text&#x3D;&quot;@&#123;@plurals&#x2F;banana(bananaCount)&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>当一个复数带有多个参数时，应传递所有参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  Have an orange</span><br><span class="line">  Have %d oranges</span><br><span class="line"></span><br><span class="line">android:text&#x3D;&quot;@&#123;@plurals&#x2F;orange(orangeCount, orangeCount)&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>某些资源需要显式类型求值，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th>—</th>
<th>表达式引用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">String[]</td>
<td>@array</td>
<td>@stringArray</td>
</tr>
<tr>
<td align="left">int[]</td>
<td>@array</td>
<td>@intArray</td>
</tr>
<tr>
<td align="left">TypedArray</td>
<td>@array</td>
<td>@typedArray</td>
</tr>
<tr>
<td align="left">Animator</td>
<td>@animator</td>
<td>@animator</td>
</tr>
<tr>
<td align="left">StateListAnimator</td>
<td>@animator</td>
<td>@stateListAnimator</td>
</tr>
<tr>
<td align="left">color int</td>
<td>@color</td>
<td>@color</td>
</tr>
<tr>
<td align="left">ColorStateList</td>
<td>@color</td>
<td>@colorStateList</td>
</tr>
</tbody></table>
<h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><blockquote>
<p>通过数据绑定，您可以编写从视图分派的表达式处理事件（例如，<code>onClick()</code> 方法）。事件特性名称由监听器方法的名称确定，但有一些例外情况</p>
</blockquote>
<table>
<thead>
<tr>
<th>类</th>
<th>监听器 setter</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>SearchView</td>
<td>setOnSearchClickListener(View.OnClickListener)</td>
<td>android:onSearchClick</td>
</tr>
<tr>
<td>ZoomControls</td>
<td>setOnZoomInClickListener(View.OnClickListener)</td>
<td>android:onZoomIn</td>
</tr>
<tr>
<td>ZoomControls</td>
<td>setOnZoomOutClickListener(View.OnClickListener)</td>
<td>android:onZoomOut</td>
</tr>
<tr>
<td>ZoomControls</td>
<td>setOnClickListener(View.OnClickListener)</td>
<td>android:onClick</td>
</tr>
</tbody></table>
<h5 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h5><p>事件可以直接绑定到处理脚本方法，类似于为 Activity 中的方法指定android:onClick 的方式。</p>
<blockquote>
<p>与 View onClick 特性相比，一个主要优点是表达式在编译时进行处理，因此，如果该方法不存在或其签名不正确，则会收到编译时错误。</p>
</blockquote>
<p>方法引用和监听器绑定之间的主要区别在于:</p>
<blockquote>
<p>实际监听器实现是在绑定数据时创建的，而不是在事件触发时创建的。</p>
<p>如果您希望在事件发生时对表达式求值，则应使用监听器绑定。</p>
</blockquote>
<p>示例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandlers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClickFriend</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">    &lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">       &lt;data&gt;</span><br><span class="line">           &lt;variable name&#x3D;&quot;handlers&quot; type&#x3D;&quot;com.example.MyHandlers&quot;&#x2F;&gt;</span><br><span class="line">           &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;data&gt;</span><br><span class="line">       &lt;LinearLayout</span><br><span class="line">           android:orientation&#x3D;&quot;vertical&quot;</span><br><span class="line">           android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">           android:layout_height&#x3D;&quot;match_parent&quot;&gt;</span><br><span class="line">           &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">               android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">               android:text&#x3D;&quot;@&#123;user.firstName&#125;&quot;</span><br><span class="line">               android:onClick&#x3D;&quot;@&#123;handlers::onClickFriend&#125;&quot;&#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;LinearLayout&gt;</span><br><span class="line">    &lt;&#x2F;layout&gt;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>表达式中的方法签名必须与监听器对象中的方法签名完全一致。</strong></p>
<h5 id="监听器绑定"><a href="#监听器绑定" class="headerlink" title="监听器绑定"></a>监听器绑定</h5><blockquote>
<p>监听器绑定是在事件发生时运行的绑定表达式。它们类似于方法引用，但允许您运行任意数据绑定表达式。此功能适用于 Gradle 2.0 版及更高版本的 Android Gradle 插件。</p>
<p>在方法引用中，方法的参数必须与事件监听器的参数匹配。</p>
<p>在监听器绑定中，只有您的返回值必须与监听器的预期返回值相匹配（预期返回值无效除外）。</p>
</blockquote>
<p>例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSaveClick</span><span class="params">(task: <span class="type">Task</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">    &lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">        &lt;data&gt;</span><br><span class="line">            &lt;variable name&#x3D;&quot;task&quot; type&#x3D;&quot;com.android.example.Task&quot; &#x2F;&gt;</span><br><span class="line">            &lt;variable name&#x3D;&quot;presenter&quot; type&#x3D;&quot;com.android.example.Presenter&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;data&gt;</span><br><span class="line">        &lt;LinearLayout </span><br><span class="line">						android:layout_width&#x3D;&quot;match_parent&quot; </span><br><span class="line">						android:layout_height&#x3D;&quot;match_parent&quot;&gt;</span><br><span class="line">            &lt;Button </span><br><span class="line">								android:layout_width&#x3D;&quot;wrap_content&quot; </span><br><span class="line">								android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            		android:onClick&#x3D;&quot;@&#123;() -&gt; presenter.onSaveClick(task)&#125;&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;LinearLayout&gt;</span><br><span class="line">    &lt;&#x2F;layout&gt;</span><br></pre></td></tr></table></figure>

<p>监听器绑定提供两个监听器参数选项：您可以忽略方法的所有参数，也可以命名所有参数。如果您想命名参数，则可以在表达式中使用这些参数。</p>
<p>例如，上面的表达式可以写成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick&#x3D;&quot;@&#123;(view) -&gt; presenter.onSaveClick(task)&#125;&quot;</span><br></pre></td></tr></table></figure>



<p>如果想在表达式中使用参数，则采用如下形式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSaveClick</span><span class="params">(view: <span class="type">View</span>, task: <span class="type">Task</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick&#x3D;&quot;@&#123;(theView) -&gt; presenter.onSaveClick(theView, task)&#125;&quot;</span><br></pre></td></tr></table></figure>



<p>可以在 lambda 表达式中使用多个参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onCompletedChanged</span><span class="params">(task: <span class="type">Task</span>, completed: <span class="type">Boolean</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox </span><br><span class="line">		android:layout_width&#x3D;&quot;wrap_content&quot; </span><br><span class="line">		android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:onCheckedChanged&#x3D;&quot;@&#123;(cb, isChecked) -&gt; presenter.completeChanged(task, isChecked)&#125;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>



<p>如果您监听的事件返回类型不是 void 的值，则您的表达式也必须返回相同类型的值。</p>
<p>例如，如果要监听长按事件，表达式应返回一个布尔值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onLongClick</span><span class="params">(view: <span class="type">View</span>, task: <span class="type">Task</span>)</span></span>: <span class="built_in">Boolean</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onLongClick&#x3D;&quot;@&#123;(theView) -&gt; presenter.onLongClick(theView, task)&#125;&quot;</span><br></pre></td></tr></table></figure>



<p>如果由于 <code>null</code> 对象而无法对表达式求值，则数据绑定将返回该类型的默认值。例如，引用类型返回 <code>null</code>，<code>int</code> 返回 <code>0</code>，<code>boolean</code> 返回 <code>false</code>，等等。</p>
<p>如果您需要将表达式与谓词（例如，三元运算符）结合使用，则可以使用 <code>void</code> 作为符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick&#x3D;&quot;@&#123;(v) -&gt; v.isVisible() ? doSomething() : void&#125;&quot;</span><br></pre></td></tr></table></figure>



<h5 id="避免使用复杂的监听器"><a href="#避免使用复杂的监听器" class="headerlink" title="避免使用复杂的监听器"></a>避免使用复杂的监听器</h5><p>监听器表达式功能非常强大，可以使您的代码非常易于阅读。另一方面，包含复杂表达式的监听器会使您的布局难以阅读和维护。</p>
<p>这些表达式应该像将可用数据从界面传递到回调方法一样简单。您应该在从监听器表达式调用的回调方法中实现任何业务逻辑。</p>
<h4 id="导入、变量和包含"><a href="#导入、变量和包含" class="headerlink" title="导入、变量和包含"></a>导入、变量和包含</h4><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><blockquote>
<p>通过导入功能，您可以轻松地在布局文件中引用类。</p>
</blockquote>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">      &lt;import type&#x3D;&quot;android.view.View&quot;&#x2F;&gt;</span><br><span class="line">		&lt;!-- 类型别名：适用于类名出现冲突的情况--&gt;</span><br><span class="line">  		&lt;import type&#x3D;&quot;com.example.real.estate.View&quot;</span><br><span class="line">          alias&#x3D;&quot;Vista&quot;&#x2F;&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;&#x2F;data&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">       android:text&#x3D;&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">       android:visibility&#x3D;&quot;@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<p>在表达式中引用静态字段和方法时，也可以使用导入的类型。以下代码会导入 <code>MyStringUtils</code> 类，并引用其 <code>capitalize</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">      &lt;import type&#x3D;&quot;com.example.MyStringUtils&quot;&#x2F;&gt;</span><br><span class="line">      &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;data&gt;</span><br><span class="line">  …</span><br><span class="line">  &lt;TextView</span><br><span class="line">     android:text&#x3D;&quot;@&#123;MyStringUtils.capitalize(user.lastName)&#125;&quot;</span><br><span class="line">     android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">     android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><blockquote>
<p>通过变量功能，您可以描述可在绑定表达式中使用的属性。</p>
</blockquote>
<p>您可以在 <code>data</code> 元素中使用多个 <code>variable</code> 元素。每个 <code>variable</code> 元素都描述了一个可以在布局上设置、并将在布局文件中的绑定表达式中使用的属性。</p>
<p>以下示例声明了 <code>user</code>、<code>image</code> 和 <code>note</code> 变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">      &lt;import type&#x3D;&quot;android.graphics.drawable.Drawable&quot;&#x2F;&gt;</span><br><span class="line">      &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">      &lt;variable name&#x3D;&quot;image&quot; type&#x3D;&quot;Drawable&quot;&#x2F;&gt;</span><br><span class="line">      &lt;variable name&#x3D;&quot;note&quot; type&#x3D;&quot;String&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;data&gt;</span><br></pre></td></tr></table></figure>



<p>变量类型在编译时进行检查，因此，如果变量实现 Observable 或者是可观察集合，则应反映在类型中。如果该变量是不实现 Observable 接口的基类或接口，则变量是“不可观察的”。</p>
<p>如果不同配置（例如横向或纵向）有不同的布局文件，则变量会合并在一起。这些布局文件之间<strong>不得存在有冲突的变量定义</strong>。</p>
<blockquote>
<p>在生成的绑定类中，每个描述的变量都有一个对应的 setter 和 getter。在调用 setter 之前，这些变量一直采用默认的托管代码值，例如引用类型采用 <code>null</code>，<code>int</code> 采用 <code>0</code>，<code>boolean</code> 采用 <code>false</code>，等等。</p>
<p>系统会根据需要生成名为 <code>context</code> 的特殊变量，用于绑定表达式。<code>context</code> 的值是根视图的 <code>getContext()</code> 方法中的 <code>Context</code> 对象。<code>context</code> 变量会被具有该名称的显式变量声明替换。</p>
</blockquote>
<h5 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h5><blockquote>
<p>通过包含功能，您可以在整个应用中重复使用复杂的布局。</p>
</blockquote>
<p>通过使用应用命名空间和特性中的变量名称，变量可以从包含的布局传递到被包含布局的绑定。</p>
<p>以下示例展示了来自 <code>name.xml</code> 和 <code>contact.xml</code> 布局文件的被包含 <code>user</code> 变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">  &lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">          xmlns:bind&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;&gt;</span><br><span class="line">     &lt;data&gt;</span><br><span class="line">         &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">     &lt;&#x2F;data&gt;</span><br><span class="line">     &lt;LinearLayout</span><br><span class="line">         android:orientation&#x3D;&quot;vertical&quot;</span><br><span class="line">         android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">         android:layout_height&#x3D;&quot;match_parent&quot;&gt;</span><br><span class="line">         &lt;include layout&#x3D;&quot;@layout&#x2F;name&quot;</span><br><span class="line">             bind:user&#x3D;&quot;@&#123;user&#125;&quot;&#x2F;&gt;</span><br><span class="line">         &lt;include layout&#x3D;&quot;@layout&#x2F;contact&quot;</span><br><span class="line">             bind:user&#x3D;&quot;@&#123;user&#125;&quot;&#x2F;&gt;</span><br><span class="line">     &lt;&#x2F;LinearLayout&gt;</span><br><span class="line">  &lt;&#x2F;layout&gt;</span><br></pre></td></tr></table></figure>

<p><strong>数据绑定不支持 include 作为 merge 元素的直接子元素。</strong>例如，以下布局不受支持：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">  &lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">          xmlns:bind&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;&gt;</span><br><span class="line">     &lt;data&gt;</span><br><span class="line">         &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">     &lt;&#x2F;data&gt;</span><br><span class="line">     &lt;merge&gt;&lt;!-- Doesn&#39;t work --&gt;</span><br><span class="line">         &lt;include layout&#x3D;&quot;@layout&#x2F;name&quot;</span><br><span class="line">             bind:user&#x3D;&quot;@&#123;user&#125;&quot;&#x2F;&gt;</span><br><span class="line">         &lt;include layout&#x3D;&quot;@layout&#x2F;contact&quot;</span><br><span class="line">             bind:user&#x3D;&quot;@&#123;user&#125;&quot;&#x2F;&gt;</span><br><span class="line">     &lt;&#x2F;merge&gt;</span><br><span class="line">  &lt;&#x2F;layout&gt;</span><br></pre></td></tr></table></figure>





<h3 id="使用可观察的数据对象"><a href="#使用可观察的数据对象" class="headerlink" title="使用可观察的数据对象"></a>使用可观察的数据对象</h3><blockquote>
<p>可观察性是指一个对象将其数据变化通知给其他对象的能力。通过数据绑定库，您可以让对象、字段或集合变为可观察。</p>
</blockquote>
<p>任何普通对象都可用于数据绑定，但修改对象不会自动使界面更新。通过数据绑定，数据对象可在其数据发生更改时通知其他对象，即监听器。可观察类有三种不同类型：<strong>对象</strong>、<strong>字段</strong>和<strong>集合</strong>。</p>
<blockquote>
<p>当其中一个可观察数据对象绑定到界面并且该数据对象的属性发生更改时，界面会自动更新。</p>
</blockquote>
<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>在创建实现 Observable 接口的类时要完成一些操作，但如果您的类只有少数几个属性，则这样操作的意义不大。在这种情况下，您可以使用通用 Observable 类和以下特定于基元的类，将字段设为可观察字段：</p>
<ul>
<li>ObservableBoolean</li>
<li>ObservableByte</li>
<li>ObservableChar</li>
<li>ObservableShort</li>
<li>ObservableInt</li>
<li>ObservableLong</li>
<li>ObservableFloat</li>
<li>ObservableDouble</li>
<li>ObservableParcelable</li>
</ul>
<p>可观测字段是自成一体的可观测对象。原始版本在访问操作时避免了装箱和解装箱。要使用这种机制，在Java编程语言中创建一个公共的最终属性，或者在Kotlin中创建一个只读属性，如下例所示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> firstName = ObservableField&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> lastName = ObservableField&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> age = ObservableInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要访问字段值，请使用 set() 和 get() 访问器方法，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.firstName = <span class="string">"Google"</span></span><br><span class="line"><span class="keyword">val</span> age = user.age</span><br></pre></td></tr></table></figure>

<p>注意：Android Studio 3.1 及更高版本允许用 <strong>LiveData</strong> 对象替换可观察字段，从而为您的应用提供额外的好处。有关详情，请参阅使用 LiveData 将数据变化通知给界面。</p>
<h4 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h4><p>某些应用使用动态结构来保存数据。可观察集合允许使用键访问这些结构。当键为引用类型（如 <code>String</code>）时，<a href="https://developer.android.com/reference/androidx/databinding/ObservableArrayMap" target="_blank" rel="noopener"><code>ObservableArrayMap</code></a> 类非常有用，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayMap&lt;String, Any&gt;().apply &#123;</span><br><span class="line">    put(<span class="string">"firstName"</span>, <span class="string">"Google"</span>)</span><br><span class="line">    put(<span class="string">"lastName"</span>, <span class="string">"Inc."</span>)</span><br><span class="line">    put(<span class="string">"age"</span>, <span class="number">17</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在布局文件中，也可以使用以字符串为键的Map，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type&#x3D;&quot;android.databinding.ObservableMap&quot;&#x2F;&gt;</span><br><span class="line">    &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;ObservableMap&lt;String, Object&gt;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;data&gt;</span><br><span class="line">…</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:text&#x3D;&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:text&#x3D;&quot;@&#123;String.valueOf(1 + (Integer)user.age)&#125;&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>当键是整数的时候，ObservableArrayList就很方便：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayList&lt;Any&gt;().apply &#123;</span><br><span class="line">    add(<span class="string">"Google"</span>)</span><br><span class="line">    add(<span class="string">"Inc."</span>)</span><br><span class="line">    add(<span class="number">17</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在布局文件中，允许List使用角标进行索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type&#x3D;&quot;android.databinding.ObservableList&quot;&#x2F;&gt;</span><br><span class="line">    &lt;import type&#x3D;&quot;com.example.my.app.Fields&quot;&#x2F;&gt;</span><br><span class="line">    &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;ObservableList&lt;Object&gt;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;data&gt;</span><br><span class="line">…</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:text&#x3D;&#39;@&#123;user[Fields.LAST_NAME]&#125;&#39;</span><br><span class="line">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:text&#x3D;&#39;@&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;&#39;</span><br><span class="line">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><blockquote>
<p>实现 <a href="https://developer.android.com/reference/androidx/databinding/Observable" target="_blank" rel="noopener"><code>Observable</code></a> 接口的类允许注册监听器，以便它们接收有关可观察对象的属性更改的通知。</p>
</blockquote>
<p>Observable 接口具有添加和移除监听器的机制，但何时发送通知则必须由您决定。</p>
<p>为便于开发，数据绑定库提供了用于实现监听器注册机制的 BaseObservable 类。实现 BaseObservable 的数据类负责在属性更改时发出通知。具体操作过程是向 getter 分配 Bindable 注释，然后在 setter 中调用 notifyPropertyChanged() 方法，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> : <span class="type">BaseObservable</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Bindable</span></span><br><span class="line">    <span class="keyword">var</span> firstName: String = <span class="string">""</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            notifyPropertyChanged(BR.firstName)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Bindable</span></span><br><span class="line">    <span class="keyword">var</span> lastName: String = <span class="string">""</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            notifyPropertyChanged(BR.lastName)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据绑定在模块包中生成一个名为 BR 的类，该类包含用于数据绑定的资源的 ID。在编译期间，Bindable 注释会在 BR 类文件中生成一个条目。如果数据类的基类无法更改，则 Observable 接口可以使用 PropertyChangeRegistry 对象实现，以便有效地注册和通知监听器。</p>
</blockquote>
<h3 id="生成的绑定类"><a href="#生成的绑定类" class="headerlink" title="生成的绑定类"></a>生成的绑定类</h3><blockquote>
<p>生成的绑定类将布局变量与布局中的视图关联起来。绑定类的名称和包可以自定义。所有生成的绑定类都是从 ViewDataBinding 类继承而来的。</p>
</blockquote>
<h4 id="创建绑定对象"><a href="#创建绑定对象" class="headerlink" title="创建绑定对象"></a>创建绑定对象</h4><p>在对布局进行扩充后，应尽快创建绑定对象，以确保视图层次结构在通过表达式与布局内的视图绑定之前不会被修改。</p>
<p>将对象绑定到布局的最常用方法是在绑定类上使用静态方法。使用绑定类的 <code>inflate()</code> 方法来扩充视图层次结构并将对象绑定到该层次结构，如以下示例所示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">val</span> binding: MyLayoutBinding = MyLayoutBinding.inflate(layoutInflater)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inflate() 方法还有另外一个版本，这个版本不仅使用 LayoutInflater 对象，还使用 ViewGroup 对象，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> binding: MyLayoutBinding = MyLayoutBinding.inflate(getLayoutInflater(), viewGroup, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>如果布局是使用其他机制扩充的，可单独绑定，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> viewRoot = LayoutInflater.from(<span class="keyword">this</span>).inflate(layoutId, parent, attachToParent)</span><br><span class="line"><span class="keyword">val</span> binding: ViewDataBinding? = DataBindingUtil.bind(viewRoot)</span><br></pre></td></tr></table></figure>



<p><strong>如果您要在 Fragment、ListView 或 RecyclerView 适配器中使用数据绑定项，您可能更愿意使用绑定类的 inflate() 方法或 DataBindingUtil 类</strong>，如以下代码示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">val</span> listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>



<h4 id="带ID的视图"><a href="#带ID的视图" class="headerlink" title="带ID的视图"></a>带ID的视图</h4><p>数据绑定库会针对布局中具有 ID 的每个视图在绑定类中创建不可变字段。例如，数据绑定库会根据以下布局创建 <code>TextView</code> 类型的 <code>firstName</code> 和 <code>lastName</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">       &lt;data&gt;</span><br><span class="line">           &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;data&gt;</span><br><span class="line">       &lt;LinearLayout</span><br><span class="line">           android:orientation&#x3D;&quot;vertical&quot;</span><br><span class="line">           android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">           android:layout_height&#x3D;&quot;match_parent&quot;&gt;</span><br><span class="line">           &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">               android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">               android:text&#x3D;&quot;@&#123;user.firstName&#125;&quot;</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;firstName&quot;&#x2F;&gt;</span><br><span class="line">           &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">               android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">               android:text&#x3D;&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">      android:id&#x3D;&quot;@+id&#x2F;lastName&quot;&#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;LinearLayout&gt;</span><br><span class="line">    &lt;&#x2F;layout&gt;</span><br></pre></td></tr></table></figure>

<p>该库一次性从视图层次结构中提取包含 ID 的视图。相较于针对布局中的每个视图调用 <code>findViewById()</code> 方法，这种机制速度更快。</p>
<h4 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h4><p>数据绑定库为布局中声明的每个变量生成访问器方法。例如，以下布局在绑定类中针对 <code>user</code>、<code>image</code> 和 <code>note</code> 变量生成了 setter 和 getter 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">     &lt;import type&#x3D;&quot;android.graphics.drawable.Drawable&quot;&#x2F;&gt;</span><br><span class="line">     &lt;variable name&#x3D;&quot;user&quot; type&#x3D;&quot;com.example.User&quot;&#x2F;&gt;</span><br><span class="line">     &lt;variable name&#x3D;&quot;image&quot; type&#x3D;&quot;Drawable&quot;&#x2F;&gt;</span><br><span class="line">     &lt;variable name&#x3D;&quot;note&quot; type&#x3D;&quot;String&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;data&gt;</span><br></pre></td></tr></table></figure>



<h4 id="ViewStubs"><a href="#ViewStubs" class="headerlink" title="ViewStubs"></a>ViewStubs</h4><blockquote>
<p>与普通视图不同，<code>ViewStub</code> 对象初始是一个不可见视图。当它们显示出来或者获得明确指示进行扩充时，它们会通过扩充另一个布局在布局中完成自我取代。</p>
<p>由于 <code>ViewStub</code> 实际上会从视图层次结构中消失，因此绑定对象中的视图也必须消失，才能通过垃圾回收进行回收。由于视图是最终结果，因此 <a href="https://developer.android.com/reference/androidx/databinding/ViewStubProxy" target="_blank" rel="noopener"><code>ViewStubProxy</code></a> 对象将取代生成的绑定类中的 <code>ViewStub</code>，让您能够访问 <code>ViewStub</code>（如果存在），同时还能访问 <code>ViewStub</code> 进行扩充后的扩充版视图层次结构。</p>
<p>在扩充其他布局时，必须为新布局建立绑定。因此，<code>ViewStubProxy</code> 必须监听 <code>ViewStub</code> <code>OnInflateListener</code> 并在必要时建立绑定。由于在给定时间只能有一个监听器，因此 <code>ViewStubProxy</code> 允许您设置 <code>OnInflateListener</code>，它将在建立绑定后调用这个监听器。</p>
</blockquote>
<h4 id="即时绑定"><a href="#即时绑定" class="headerlink" title="即时绑定"></a>即时绑定</h4><blockquote>
<p>当可变或可观察对象发生更改时，绑定会按照计划在下一帧之前发生更改。但有时必须立即执行绑定。要强制执行，请使用 <a href="https://developer.android.com/reference/androidx/databinding/ViewDataBinding#executePendingBindings()" target="_blank" rel="noopener"><code>executePendingBindings()</code></a> 方法。</p>
</blockquote>
<h4 id="高级绑定"><a href="#高级绑定" class="headerlink" title="高级绑定"></a>高级绑定</h4><h5 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h5><p>有时，系统并不知道特定的绑定类。例如，针对任意布局运行的 <code>RecyclerView.Adapter</code> 不知道特定绑定类。在调用 <code>onBindViewHolder()</code> 方法时，仍必须指定绑定值。</p>
<p>在以下示例中，<code>RecyclerView</code> 绑定到的所有布局都有 <code>item</code> 变量。<code>BindingHolder</code> 对象具有一个 <code>getBinding()</code> 方法，这个方法返回 <a href="https://developer.android.com/reference/androidx/databinding/ViewDataBinding" target="_blank" rel="noopener"><code>ViewDataBinding</code></a> 基类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">BindingHolder</span>, position: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    item: T = items.<span class="keyword">get</span>(position)</span><br><span class="line">    holder.binding.setVariable(BR.item, item);</span><br><span class="line">    holder.binding.executePendingBindings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：数据绑定库在模块包中生成一个名为 <code>BR</code> 的类，其中包含用于数据绑定的资源的 ID。在上例中，该库自动生成 <code>BR.item</code> 变量。</p>
</blockquote>
<h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><blockquote>
<p>可以在后台线程中更改数据模型，但前提是这个模型不是集合。数据绑定会在求值过程中对每个变量/字段进行本地化，以避免出现并发问题。</p>
</blockquote>
<h4 id="自定义绑定类名称"><a href="#自定义绑定类名称" class="headerlink" title="自定义绑定类名称"></a>自定义绑定类名称</h4><p>默认情况下，绑定类是根据布局文件的名称生成的，以大写字母开头，移除下划线 ( _ )，将后一个字母大写，最后添加后缀 <strong>Binding</strong>。该类位于模块包下的 <code>databinding</code> 包中。例如，布局文件 <code>contact_item.xml</code> 会生成 <code>ContactItemBinding</code> 类。如果模块包是 <code>com.example.my.app</code>，则绑定类放在 <code>com.example.my.app.databinding</code> 包中。</p>
<p>通过调整 <code>data</code> 元素的 <code>class</code> 特性，绑定类可重命名或放置在不同的包中。例如，以下布局在当前模块的 <code>databinding</code> 包中生成 <code>ContactItem</code> 绑定类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">data</span> <span class="class"><span class="keyword">class</span>="<span class="title">ContactItem</span>"&gt;</span></span><br><span class="line">        …</span><br><span class="line">    &lt;/<span class="keyword">data</span>&gt;</span><br></pre></td></tr></table></figure>

<p>您可以在类名前添加句点和前缀，从而在其他文件包中生成绑定类。以下示例在模块包中生成绑定类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">data</span> <span class="class"><span class="keyword">class</span>=".<span class="title">ContactItem</span>"&gt;</span></span><br><span class="line">        …</span><br><span class="line">&lt;/<span class="keyword">data</span>&gt;</span><br></pre></td></tr></table></figure>

<p>您还可以使用完整软件包名称来生成绑定类。以下示例在 <code>com.example</code> 包中创建 <code>ContactItem</code> 绑定类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">data</span> <span class="class"><span class="keyword">class</span>="<span class="title">com</span>.<span class="title">example</span>.<span class="title">ContactItem</span>"&gt;</span></span><br><span class="line">        …</span><br><span class="line">&lt;/<span class="keyword">data</span>&gt;</span><br></pre></td></tr></table></figure>





<h3 id="绑定适配器"><a href="#绑定适配器" class="headerlink" title="绑定适配器"></a>绑定适配器</h3><blockquote>
<p>绑定适配器负责发出相应的框架调用来设置值。例如，设置属性值就像调用 <code>setText()</code> 方法一样。再比如，设置事件监听器就像调用 <code>setOnClickListener()</code> 方法。</p>
<p>数据绑定库允许您通过使用适配器指定为设置值而调用的方法、提供您自己的绑定逻辑，以及指定返回对象的类型。</p>
</blockquote>
<h4 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a>设置属性值</h4><blockquote>
<p>只要绑定值发生更改，生成的绑定类就必须使用绑定表达式在视图上调用 setter 方法。您可以允许数据绑定库自动确定方法、显式声明方法或提供选择方法的自定义逻辑。</p>
</blockquote>
<h5 id="自动选择方法"><a href="#自动选择方法" class="headerlink" title="自动选择方法"></a>自动选择方法</h5><h5 id="指定自定义方法名称"><a href="#指定自定义方法名称" class="headerlink" title="指定自定义方法名称"></a>指定自定义方法名称</h5><p>某些特性拥有名称不符的 setter。在这些情况下，某个特性可能会使用 <a href="https://developer.android.com/reference/androidx/databinding/BindingMethods" target="_blank" rel="noopener"><code>BindingMethods</code></a> 注释与 setter 相关联。</p>
<p>注释与类一起使用，可以包含多个 <a href="https://developer.android.com/reference/androidx/databinding/BindingMethod" target="_blank" rel="noopener"><code>BindingMethod</code></a> 注释，每个注释对应一个重命名的方法。绑定方法是可添加到应用中任何类的注释。</p>
<p>在以下示例中，<code>android:tint</code> 特性与 <code>setImageTintList(ColorStateList)</code> 方法相关联，而不与 <code>setTint()</code> 方法相关联：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingMethods(value = [</span></span><br><span class="line"><span class="meta">    BindingMethod(</span></span><br><span class="line"><span class="meta">        type = android.widget.ImageView::class,</span></span><br><span class="line"><span class="meta">        attribute = <span class="meta-string">"android:tint"</span>,</span></span><br><span class="line"><span class="meta">        method = <span class="meta-string">"setImageTintList"</span>)</span>])</span><br></pre></td></tr></table></figure>



<h5 id="提供自定义逻辑"><a href="#提供自定义逻辑" class="headerlink" title="提供自定义逻辑"></a>提供自定义逻辑</h5><p><strong>某些特性需要自定义绑定逻辑。</strong>例如，<code>android:paddingLeft</code> 特性没有关联的 setter，而是提供了 <code>setPadding(left, top, right, bottom)</code> 方法。使用 <a href="https://developer.android.com/reference/androidx/databinding/BindingAdapter" target="_blank" rel="noopener"><code>BindingAdapter</code></a> 注释的静态绑定适配器方法支持自定义特性 setter 的调用方式。</p>
<p>Android 框架类的特性已经创建了 <code>BindingAdapter</code> 注释。例如，以下示例展示了 <code>paddingLeft</code> 特性的绑定适配器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"android:paddingLeft"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setPaddingLeft</span><span class="params">(view: <span class="type">View</span>, padding: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    view.setPadding(padding,</span><br><span class="line">                view.getPaddingTop(),</span><br><span class="line">                view.getPaddingRight(),</span><br><span class="line">                view.getPaddingBottom())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个参数用于确定与特性关联的视图类型；第二个参数用于确定在给定特性的绑定表达式中接受的类型。</p>
</blockquote>
<p>绑定适配器对其他类型的自定义很有用。例如，可以通过工作器线程调用自定义加载程序来加载图片。</p>
<p><strong>出现冲突时，您定义的绑定适配器会替换由 Android 框架提供的默认适配器。</strong></p>
<p>您还可以使用接收多个特性的适配器，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"imageUrl"</span>, <span class="meta-string">"error"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loadImage</span><span class="params">(view: <span class="type">ImageView</span>, url: <span class="type">String</span>, error: <span class="type">Drawable</span>)</span></span> &#123;</span><br><span class="line">    Picasso.<span class="keyword">get</span>().load(url).error(error).into(view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以在布局中使用适配器，如以下示例所示。请注意，<code>@drawable/venueError</code> 引用应用中的资源。使用 <code>@{}</code> 将资源括起来可使其成为有效的绑定表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView </span><br><span class="line">	app:imageUrl&#x3D;&quot;@&#123;venue.imageUrl&#125;&quot; </span><br><span class="line">	app:error&#x3D;&quot;@&#123;@drawable&#x2F;venueError&#125;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：数据绑定库在匹配时会忽略自定义命名空间。</p>
<p>如果 <code>ImageView</code> 对象同时使用了 <code>imageUrl</code> 和 <code>error</code>，并且 <code>imageUrl</code> 是字符串，<code>error</code> 是 <code>Drawable</code>，则会调用适配器。</p>
<p>如果您希望在设置了任意特性时调用适配器，则可以将适配器的可选 <a href="https://developer.android.com/reference/androidx/databinding/BindingAdapter#requireAll()" target="_blank" rel="noopener"><code>requireAll</code></a> 标记设置为 <code>false</code>，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(value = [<span class="meta-string">"imageUrl"</span>, <span class="meta-string">"placeholder"</span>], requireAll = false)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setImageUrl</span><span class="params">(imageView: <span class="type">ImageView</span>, url: <span class="type">String</span>?, placeHolder: <span class="type">Drawable</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">        imageView.setImageDrawable(placeholder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MyImageLoader.loadInto(imageView, url, placeholder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：出现冲突时，绑定适配器会替换默认的数据绑定适配器。</p>
<p>绑定适配器方法可以选择性在处理程序中使用旧值。同时采用旧值和新值的方法应该先为特性声明所有旧值，然后再声明新值，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"android:paddingLeft"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setPaddingLeft</span><span class="params">(view: <span class="type">View</span>, oldPadding: <span class="type">Int</span>, newPadding: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldPadding != newPadding) &#123;</span><br><span class="line">        view.setPadding(padding,</span><br><span class="line">                    view.getPaddingTop(),</span><br><span class="line">                    view.getPaddingRight(),</span><br><span class="line">                    view.getPaddingBottom())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>事件处理程序只能与具有一种抽象方法的接口或抽象类一起使用，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"android:onLayoutChange"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnLayoutChangeListener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        view: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        oldValue: <span class="type">View</span>.<span class="type">OnLayoutChangeListener</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        newValue: <span class="type">View</span>.<span class="type">OnLayoutChangeListener</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.removeOnLayoutChangeListener(oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.addOnLayoutChangeListener(newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按如下所示在布局中使用此事件处理脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;View </span><br><span class="line">		android:onLayoutChange&#x3D;&quot;@&#123;() -&gt; handler.layoutChanged()&#125;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<p><strong>当监听器有多个方法时，必须将它拆分为多个监听器。</strong>例如，<code>View.OnAttachStateChangeListener</code> 有两个方法：<code>onViewAttachedToWindow(View)</code> 和 <code>onViewDetachedFromWindow(View)</code>。该库提供了两个接口，用于区分它们的特性和处理脚本：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Translation from provided interfaces in Java:</span></span><br><span class="line"><span class="meta">@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnViewDetachedFromWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnViewAttachedToWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为更改一个监听器也会影响另一个监听器，所以需要适用于其中一个特性或同时适用于这两个特性的适配器。您可以在注释中将 <a href="https://developer.android.com/reference/androidx/databinding/BindingAdapter#requireAll()" target="_blank" rel="noopener"><code>requireAll</code></a> 设置为 <code>false</code>，以指定并非必须为每个特性都分配绑定表达式，如以下示例所示：</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"android:onViewDetachedFromWindow"</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"android:onViewAttachedToWindow"</span>,</span></span><br><span class="line"><span class="meta">        requireAll = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setListener</span><span class="params">(view: <span class="type">View</span>, detach: <span class="type">OnViewDetachedFromWindow</span>?, attach: <span class="type">OnViewAttachedToWindow</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        <span class="keyword">val</span> newListener: View.OnAttachStateChangeListener?</span><br><span class="line">        newListener = <span class="keyword">if</span> (detach == <span class="literal">null</span> &amp;&amp; attach == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">object</span> : View.OnAttachStateChangeListener &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">                    attach.onViewAttachedToWindow(v)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">                    detach.onViewDetachedFromWindow(v)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> oldListener: View.OnAttachStateChangeListener? =</span><br><span class="line">                ListenerUtil.trackListener(view, newListener, R.id.onAttachStateChangeListener)</span><br><span class="line">        <span class="keyword">if</span> (oldListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(oldListener)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(newListener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上示例比一般情况稍微复杂一些，因为 <code>View</code> 类使用 <code>addOnAttachStateChangeListener()</code> 和 <code>removeOnAttachStateChangeListener()</code> 方法，而非 <code>OnAttachStateChangeListener</code> 的 setter 方法。<code>android.databinding.adapters.ListenerUtil</code> 类有助于跟踪以前的监听器，以便在绑定适配器中将它们移除。</p>
<p>通过用 <code>@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</code> 注释接口 <code>OnViewDetachedFromWindow</code> 和 <code>OnViewAttachedToWindow</code>，数据绑定代码生成器知道只应在运行 Android 3.1（API 级别 12）及更高级别（<code>addOnAttachStateChangeListener()</code> 方法支持的相同版本）时生成监听器。</p>
</blockquote>
<h4 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h4><h5 id="自动对象转换"><a href="#自动对象转换" class="headerlink" title="自动对象转换"></a>自动对象转换</h5><p><strong>当绑定表达式返回 <code>Object</code> 时，库会选择用于设置属性值的方法。</strong><code>Object</code> 会转换为所选方法的参数类型。对于使用 <a href="https://developer.android.com/reference/androidx/databinding/ObservableMap" target="_blank" rel="noopener"><code>ObservableMap</code></a> 类存储数据的应用，这种行为非常便捷，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">       android:text&#x3D;&#39;@&#123;userMap[&quot;lastName&quot;]&#125;&#39;</span><br><span class="line">       android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;wrap_content&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：您还可以使用 <code>object.key</code> 表示法引用映射中的值。例如，以上示例中的 <code>@{userMap[&quot;lastName&quot;]}</code> 可替换为 <code>@{userMap.lastName}</code>。</p>
<blockquote>
<p>表达式中的 <code>userMap</code> 对象会返回一个值，该值会自动转换为用于设置 <code>android:text</code> 属性值的 <code>setText(CharSequence)</code> 方法中的参数类型。如果参数类型不明确，则必须在表达式中强制转换返回类型。</p>
</blockquote>
<h5 id="自定义转换"><a href="#自定义转换" class="headerlink" title="自定义转换"></a>自定义转换</h5><p>在某些情况下，需要在特定类型之间进行自定义转换。</p>
<p>例如，视图的 <code>android:background</code> 特性需要 <code>Drawable</code>，但指定的 <code>color</code> 值是整数。以下示例展示了某个特性需要 <code>Drawable</code>，但结果提供了一个整数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">       android:background&#x3D;&quot;@&#123;isError ? @color&#x2F;red : @color&#x2F;white&#125;&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>每当需要 <code>Drawable</code> 且返回整数时，<code>int</code> 都应转换为 <code>ColorDrawable</code>。您可以使用带有 <a href="https://developer.android.com/reference/androidx/databinding/BindingConversion" target="_blank" rel="noopener"><code>BindingConversion</code></a> 注释的静态方法完成这个转换，如下所示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingConversion</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">convertColorToDrawable</span><span class="params">(color: <span class="type">Int</span>)</span></span> = ColorDrawable(color)</span><br></pre></td></tr></table></figure>

<p>但是，<strong>绑定表达式中提供的值类型必须保持一致。</strong>您不能在同一个表达式中使用不同的类型，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">       android:background&#x3D;&quot;@&#123;isError ? @drawable&#x2F;error : @color&#x2F;white&#125;&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<h3 id="将布局视图绑定到架构组件-1"><a href="#将布局视图绑定到架构组件-1" class="headerlink" title="将布局视图绑定到架构组件"></a>将布局视图绑定到架构组件</h3><h4 id="使用LiveData将数据变化通知给页面"><a href="#使用LiveData将数据变化通知给页面" class="headerlink" title="使用LiveData将数据变化通知给页面"></a>使用LiveData将数据变化通知给页面</h4><blockquote>
<p>与实现 <a href="https://developer.android.com/reference/androidx/databinding/Observable" target="_blank" rel="noopener"><code>Observable</code></a> 的对象（例如<a href="https://developer.android.com/topic/libraries/data-binding/observability#observable_fields" target="_blank" rel="noopener">可观察字段</a>）不同，<code>LiveData</code> 对象了解订阅数据更改的观察器的生命周期。</p>
</blockquote>
<p>要将 <code>LiveData</code> 对象与绑定类一起使用，<strong>需要指定生命周期所有者来定义 对象的范围。</strong></p>
<p>以下示例在绑定类实例化后将 Activity 指定为生命周期所有者：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Inflate view and obtain an instance of the binding class.</span></span><br><span class="line">        <span class="keyword">val</span> binding: UserBinding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Specify the current activity as the lifecycle owner.</span></span><br><span class="line">        binding.setLifecycleOwner(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以根据使用 ViewModel 管理界面相关数据中所述，使用 ViewModel 组件来将数据绑定到布局。在 ViewModel 组件中，您可以使用 LiveData 对象转换数据或合并多个数据源。</p>
<p>以下示例展示了如何在 ViewModel 中转换数据：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScheduleViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> userName: LiveData</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> result = Repository.userName</span><br><span class="line">        userName = Transformations.map(result) &#123; result -&gt; result.value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用ViewModel管理界面相关数据"><a href="#使用ViewModel管理界面相关数据" class="headerlink" title="使用ViewModel管理界面相关数据"></a>使用ViewModel管理界面相关数据</h4><p>要将 <code>ViewModel</code> 组件与数据绑定库一起使用，必须实例化从 类继承而来的组件，获取绑定类的实例，并将您的 组件分配给绑定类中的属性。</p>
<p>以下示例展示了如何将组件与库结合使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Obtain the ViewModel component.</span></span><br><span class="line">        UserModel userModel = ViewModelProviders.of(getActivity())</span><br><span class="line">                                                  .<span class="keyword">get</span>(UserModel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Inflate view and obtain an instance of the binding class.</span></span><br><span class="line">        <span class="keyword">val</span> binding: UserBinding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assign the component to a property in the binding class.</span></span><br><span class="line">        binding.viewmodel = userModel</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在布局中，使用绑定表达式将 <code>ViewModel</code> 组件的属性和方法分配给对应的视图，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;rememberMeCheckBox&quot;</span><br><span class="line">        android:checked&#x3D;&quot;@&#123;viewmodel.rememberMe&#125;&quot;</span><br><span class="line">        android:onCheckedChanged&#x3D;&quot;@&#123;() -&gt; viewmodel.rememberMeChanged()&#125;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>



<h4 id="使用Observable-ViewModel以更好地控制绑定适配器"><a href="#使用Observable-ViewModel以更好地控制绑定适配器" class="headerlink" title="使用Observable ViewModel以更好地控制绑定适配器"></a>使用Observable ViewModel以更好地控制绑定适配器</h4><blockquote>
<p>使用实现 <code>Observable</code> 的 <code>ViewModel</code> 组件可让您更好地控制应用中的绑定适配器。例如，这种模式可让您更多地控制数据更改时的通知，您还可以指定自定义方法来设置双向数据绑定中的属性值。</p>
</blockquote>
<p>要实现可观察的 <code>ViewModel</code> 组件，您必须创建一个从 类继承而来并实现 <a href="https://developer.android.com/reference/androidx/databinding/Observable" target="_blank" rel="noopener"><code>Observable</code></a> 接口的类。您可以使用 <a href="https://developer.android.com/reference/androidx/databinding/Observable#addOnPropertyChangedCallback(android.databinding.Observable.OnPropertyChangedCallback)" target="_blank" rel="noopener"><code>addOnPropertyChangedCallback()</code></a> 和 <a href="https://developer.android.com/reference/androidx/databinding/Observable#removeOnPropertyChangedCallback(android.databinding.Observable.OnPropertyChangedCallback)" target="_blank" rel="noopener"><code>removeOnPropertyChangedCallback()</code></a> 方法提供观察器订阅或取消订阅通知时的自定义逻辑。您还可以在 <a href="https://developer.android.com/reference/androidx/databinding/BaseObservable#notifyPropertyChanged(int)" target="_blank" rel="noopener"><code>notifyPropertyChanged()</code></a> 方法中提供属性更改时运行的自定义逻辑。以下代码示例展示了如何实现一个可观察的 <code>ViewModel</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A ViewModel that is also an Observable,</span></span><br><span class="line"><span class="comment"> * to be used with the Data Binding Library.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableViewModel</span> : <span class="type">ViewModel</span></span>(), Observable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> callbacks: PropertyChangeRegistry = PropertyChangeRegistry()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addOnPropertyChangedCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            callback: <span class="type">Observable</span>.<span class="type">OnPropertyChangedCallback</span>)</span></span> &#123;</span><br><span class="line">        callbacks.add(callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeOnPropertyChangedCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            callback: <span class="type">Observable</span>.<span class="type">OnPropertyChangedCallback</span>)</span></span> &#123;</span><br><span class="line">        callbacks.remove(callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies observers that all properties of this instance have changed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">notifyChange</span><span class="params">()</span></span> &#123;</span><br><span class="line">        callbacks.notifyCallbacks(<span class="keyword">this</span>, <span class="number">0</span>, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies observers that a specific property has changed. The getter for the</span></span><br><span class="line"><span class="comment">     * property that changes should be marked with the <span class="doctag">@Bindable</span> annotation to</span></span><br><span class="line"><span class="comment">     * generate a field in the BR class to be used as the fieldId parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldId The generated BR id for the Bindable field.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">notifyPropertyChanged</span><span class="params">(fieldId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        callbacks.notifyCallbacks(<span class="keyword">this</span>, fieldId, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="双向数据绑定-1"><a href="#双向数据绑定-1" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>使用单向数据绑定，您可以为特性设置值，并设置对该特性更改作出反应的监听器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/rememberMeCheckBox"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:checked</span>=<span class="string">"@&#123;viewmodel.rememberMe&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onCheckedChanged</span>=<span class="string">"@&#123;viewmodel.rememberMeChanged&#125;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>双向数据绑定为此过程提供了一个快捷方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/rememberMeCheckBox"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:checked</span>=<span class="string">"@=&#123;viewmodel.rememberMe&#125;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>@={}</code></strong> 表示法接收属性的数据更改并同时监听用户更新，其中重要的是包含“=”符号。</p>
<p>为了应对后备数据的更改，您可以将您的布局变量设置为 <code>Observable</code>（通常为 <a href="https://developer.android.com/reference/androidx/databinding/BaseObservable" target="_blank" rel="noopener"><code>BaseObservable</code></a>）的实现，并使用 <a href="https://developer.android.com/reference/androidx/databinding/Bindable" target="_blank" rel="noopener"><code>@Bindable</code></a> 注释，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginViewModel</span> : <span class="type">BaseObservable &#123;</span></span></span><br><span class="line">    <span class="comment">// val data = ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRememberMe</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>.rememberMe</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setRememberMe</span><span class="params">(value: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Avoids infinite loops.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">data</span>.rememberMe != value) &#123;</span><br><span class="line">            <span class="keyword">data</span>.rememberMe = value</span><br><span class="line"></span><br><span class="line">            <span class="comment">// React to the change.</span></span><br><span class="line">            saveData()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Notify observers of a new value.</span></span><br><span class="line">            notifyPropertyChanged(BR.remember_me)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用自定义特性的双向数据绑定"><a href="#使用自定义特性的双向数据绑定" class="headerlink" title="使用自定义特性的双向数据绑定"></a>使用自定义特性的双向数据绑定</h4><p>如果您希望结合使用双向数据绑定和自定义特性，则需要使用 <a href="https://developer.android.com/reference/androidx/databinding/InverseBindingAdapter" target="_blank" rel="noopener"><code>@InverseBindingAdapter</code></a> 和 <a href="https://developer.android.com/reference/androidx/databinding/InverseBindingMethod" target="_blank" rel="noopener"><code>@InverseBindingMethod</code></a> 注释。</p>
<p>例如，如果要在名为 <code>MyView</code> 的自定义视图中对 <code>&quot;time&quot;</code> 特性启用双向数据绑定，请完成以下步骤：</p>
<ol>
<li><p>使用 <code>@BindingAdapter</code>，对用来设置初始值并在值更改时进行更新的方法进行注释：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"time"</span>)</span></span><br><span class="line"><span class="meta">@JvmStatic</span> <span class="function"><span class="keyword">fun</span> <span class="title">setTime</span><span class="params">(view: <span class="type">MyView</span>, newValue: <span class="type">Time</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Important to break potential infinite loops.</span></span><br><span class="line">    <span class="keyword">if</span> (view.time != newValue) &#123;</span><br><span class="line">        view.time = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>使用 <code>@InverseBindingAdapter</code> 对从视图中读取值的方法进行注释：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InverseBindingAdapter(<span class="meta-string">"time"</span>)</span></span><br><span class="line"><span class="meta">@JvmStatic</span> <span class="function"><span class="keyword">fun</span> <span class="title">getTime</span><span class="params">(view: <span class="type">MyView</span>)</span></span> : Time &#123;</span><br><span class="line">    <span class="keyword">return</span> view.getTime()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时，数据绑定知道在数据发生更改时要执行的操作（调用使用 <a href="https://developer.android.com/reference/androidx/databinding/BindingAdapter" target="_blank" rel="noopener"><code>@BindingAdapter</code></a> 注释的方法）以及当 view 视特性发生更改时要调用的内容（调用 <a href="https://developer.android.com/reference/androidx/databinding/InverseBindingListener" target="_blank" rel="noopener"><code>InverseBindingListener</code></a>）。但是，它不知道特性何时或如何更改。</p>
</blockquote>
</li>
</ol>
<p>   为此，您需要在视图上设置监听器。这可以是与您的自定义视图相关联的自定义监听器，也可以是通用事件，例如失去焦点或文本更改。将 <code>@BindingAdapter</code> 注释添加到设置监听器（用来监听属性更改）的方法中：</p>
   <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"app:timeAttrChanged"</span>)</span></span><br><span class="line"><span class="meta">@JvmStatic</span> <span class="function"><span class="keyword">fun</span> <span class="title">setListeners</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        view: <span class="type">MyView</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        attrChange: <span class="type">InverseBindingListener</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Set a listener for click, focus, touch, etc.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该监听器包含一个 <code>InverseBindingListener</code> 参数。您可以使用 <code>InverseBindingListener</code> 告知数据绑定系统，特性已更改。然后，该系统可以开始调用使用 <code>@InverseBindingAdapter</code> 注释的方法，依此类推。</p>
</blockquote>
<p>   <strong>注意</strong>：每个双向绑定都会生成“合成事件特性”。该特性与基本特性具有相同的名称，但包含后缀 <code>&quot;AttrChanged&quot;</code>。合成事件特性允许库创建使用 <code>@BindingAdapter</code> 注释的方法，以将事件监听器与相应的 <code>View</code> 实例相关联。</p>
<h4 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h4><p>如果绑定到 <a href="https://developer.android.com/reference/android/view/View" target="_blank" rel="noopener"><code>View</code></a> 对象的变量需要设置格式、转换或更改后才能显示，则可以使用 <code>Converter</code> 对象。</p>
<p>以显示日期的 <code>EditText</code> 对象为例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/birth_date"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@=&#123;Converter.dateToString(viewmodel.birthDate)&#125;"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>viewmodel.birthDate</code> 属性包含 <code>Long</code> 类型的值，因此需要使用转换器设置格式。</p>
</blockquote>
<p>由于使用了双向表达式，因此还需要使用反向转换器，以告知库如何将用户提供的字符串转换回后备数据类型（在本例中为 <code>Long</code>）。此过程是通过向其中一个转换器添加 <a href="https://developer.android.com/reference/androidx/databinding/InverseMethod" target="_blank" rel="noopener"><code>@InverseMethod</code></a> 注释并让此注释引用反向转换器来完成的。以下代码段显示了此配置的一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Converter &#123;</span><br><span class="line">    <span class="meta">@InverseMethod(<span class="meta-string">"stringToDate"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dateToString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        view: <span class="type">EditText</span>, oldValue: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        value: <span class="type">Long</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: String &#123;</span><br><span class="line">        <span class="comment">// Converts long to String.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stringToDate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        view: <span class="type">EditText</span>, oldValue: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        value: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">        <span class="comment">// Converts String to long.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用双向数据绑定的无限循环"><a href="#使用双向数据绑定的无限循环" class="headerlink" title="使用双向数据绑定的无限循环"></a>使用双向数据绑定的无限循环</h4><blockquote>
<p>使用双向数据绑定时，请注意不要引入无限循环。当用户更改特性时，系统会调用使用 <code>@InverseBindingAdapter</code> 注释的方法，并且该值将分配给后备属性。继而调用使用 <code>@BindingAdapter</code> 注释的方法，从而触发对使用 <code>@InverseBindingAdapter</code> 注释的方法的另一个调用，依此类推。</p>
</blockquote>
<p>因此，<strong>通过比较使用 <code>@BindingAdapter</code> 注释的方法中的新值和旧值，可以打破可能出现的无限循环</strong></p>
<h4 id="双向特性"><a href="#双向特性" class="headerlink" title="双向特性"></a>双向特性</h4><p>当您使用下表中的特性时，该平台提供对双向数据绑定的内置支持。有关平台如何提供此类支持的详细信息，请参阅相应绑定适配器的实现：</p>
<table>
<thead>
<tr>
<th align="left">类</th>
<th align="left">特性</th>
<th align="left">绑定适配器</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.android.com/reference/android/widget/AdapterView" target="_blank" rel="noopener"><code>AdapterView</code></a></td>
<td align="left"><code>android:selectedItemPosition</code> <code>android:selection</code></td>
<td align="left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/AdapterViewBindingAdapter.java" target="_blank" rel="noopener"><code>AdapterViewBindingAdapter</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.android.com/reference/android/widget/CalendarView" target="_blank" rel="noopener"><code>CalendarView</code></a></td>
<td align="left"><code>android:date</code></td>
<td align="left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/CalendarViewBindingAdapter.java" target="_blank" rel="noopener"><code>CalendarViewBindingAdapter</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.android.com/reference/android/widget/CompoundButton" target="_blank" rel="noopener"><code>CompoundButton</code></a></td>
<td align="left"><a href="https://developer.android.com/reference/android/R.attr#checked" target="_blank" rel="noopener"><code>android:checked</code></a></td>
<td align="left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/CompoundButtonBindingAdapter.java" target="_blank" rel="noopener"><code>CompoundButtonBindingAdapter</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.android.com/reference/android/widget/DatePicker" target="_blank" rel="noopener"><code>DatePicker</code></a></td>
<td align="left"><code>android:year</code> <code>android:month</code> <code>android:day</code></td>
<td align="left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/DatePickerBindingAdapter.java" target="_blank" rel="noopener"><code>DatePickerBindingAdapter</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.android.com/reference/android/widget/NumberPicker" target="_blank" rel="noopener"><code>NumberPicker</code></a></td>
<td align="left"><a href="https://developer.android.com/reference/android/R.attr#value" target="_blank" rel="noopener"><code>android:value</code></a></td>
<td align="left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/NumberPickerBindingAdapter.java" target="_blank" rel="noopener"><code>NumberPickerBindingAdapter</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.android.com/reference/android/widget/RadioButton" target="_blank" rel="noopener"><code>RadioButton</code></a></td>
<td align="left"><a href="https://developer.android.com/reference/android/R.attr#checkedButton" target="_blank" rel="noopener"><code>android:checkedButton</code></a></td>
<td align="left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/RadioGroupBindingAdapter.java" target="_blank" rel="noopener"><code>RadioGroupBindingAdapter</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.android.com/reference/android/widget/RatingBar" target="_blank" rel="noopener"><code>RatingBar</code></a></td>
<td align="left"><a href="https://developer.android.com/reference/android/R.attr#rating" target="_blank" rel="noopener"><code>android:rating</code></a></td>
<td align="left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/RatingBarBindingAdapter.java" target="_blank" rel="noopener"><code>RatingBarBindingAdapter</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.android.com/reference/android/widget/SeekBar" target="_blank" rel="noopener"><code>SeekBar</code></a></td>
<td align="left"><a href="https://developer.android.com/reference/android/R.attr#progress" target="_blank" rel="noopener"><code>android:progress</code></a></td>
<td align="left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/SeekBarBindingAdapter.java" target="_blank" rel="noopener"><code>SeekBarBindingAdapter</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.android.com/reference/android/widget/TabHost" target="_blank" rel="noopener"><code>TabHost</code></a></td>
<td align="left"><code>android:currentTab</code></td>
<td align="left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/TabHostBindingAdapter.java" target="_blank" rel="noopener"><code>TabHostBindingAdapter</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.android.com/reference/android/widget/TextView" target="_blank" rel="noopener"><code>TextView</code></a></td>
<td align="left"><a href="https://developer.android.com/reference/android/R.attr#text" target="_blank" rel="noopener"><code>android:text</code></a></td>
<td align="left"><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/refs/heads/studio-master-dev/extensions/baseAdapters/src/main/java/androidx/databinding/adapters/TextViewBindingAdapter.java" target="_blank" rel="noopener"><code>TextViewBindingAdapter</code></a></td>
</tr>
<tr>
<td align="left"><a href="https://developer.android.com/reference/android/widget/TimePicker" target="_blank" rel="noopener"><code>TimePicker</code></a></td>
<td align="left"><code>android:hour</code> <code>android:minute</code></td>
<td align="left">[<code>TimePickerBindingAdapter</code>](</td>
</tr>
</tbody></table>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">liubo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://github.com/liuclub/liuclub.github.io.git/2020/05/28/4-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%BA%93/">https://github.com/liuclub/liuclub.github.io.git/2020/05/28/4-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%BA%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/28/5-%E5%A4%84%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"><i class="fa fa-chevron-left">  </i><span>5-处理生命周期</span></a></div><div class="next-post pull-right"><a href="/2020/05/28/3-%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9A/"><span>3-视图绑定</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By liubo</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>