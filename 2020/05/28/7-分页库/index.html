<!DOCTYPE html><html lang="[&quot;zh-Hans&quot;,&quot;default&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="7-分页库"><meta name="keywords" content=""><meta name="author" content="liubo"><meta name="copyright" content="liubo"><title>7-分页库 | 凌晨三点的逗你玩</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#声明依赖项"><span class="toc-number">1.</span> <span class="toc-text"> 声明依赖项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#概览"><span class="toc-number">2.</span> <span class="toc-text"> 概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#库架构"><span class="toc-number">2.1.</span> <span class="toc-text"> 库架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pagelist"><span class="toc-number">2.1.1.</span> <span class="toc-text"> PageList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#界面"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 界面</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#支持不同的数据架构"><span class="toc-number">2.2.</span> <span class="toc-text"> 支持不同的数据架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#网络"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#网络和数据库"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 网络和数据库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理网络错误"><span class="toc-number">2.3.</span> <span class="toc-text"> 处理网络错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新现有应用"><span class="toc-number">2.4.</span> <span class="toc-text"> 更新现有应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义分页解析"><span class="toc-number">2.4.1.</span> <span class="toc-text"> 自定义分页解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用列表而不是网页加载的数据"><span class="toc-number">2.4.2.</span> <span class="toc-text"> 使用列表而不是网页加载的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用cursoradapter将数据光标与列表视图相关联"><span class="toc-number">2.4.3.</span> <span class="toc-text"> 使用CursorAdapter将数据光标与列表视图相关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用asynclistutil异步加载内容"><span class="toc-number">2.4.4.</span> <span class="toc-text"> 使用AsyncListUtil异步加载内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库示例"><span class="toc-number">2.5.</span> <span class="toc-text"> 数据库示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用livedata观察分页数据"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 使用LiveData观察分页数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用rxjava2观察分页数据"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 使用RxJava2观察分页数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#显示分页列表"><span class="toc-number">3.</span> <span class="toc-text"> 显示分页列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将界面与视图模型关联"><span class="toc-number">3.1.</span> <span class="toc-text"> 将界面与视图模型关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现差异回调"><span class="toc-number">3.2.</span> <span class="toc-text"> 实现差异回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用其它适配器类型实现差异回调功能"><span class="toc-number">3.3.</span> <span class="toc-text"> 使用其它适配器类型实现差异回调功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在界面中提供占位符placeholder"><span class="toc-number">3.4.</span> <span class="toc-text"> 在界面中提供占位符（placeholder）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加载分页数据"><span class="toc-number">4.</span> <span class="toc-text"> 加载分页数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造可观察列表"><span class="toc-number">4.1.</span> <span class="toc-text"> 构造可观察列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义分页配置"><span class="toc-number">4.2.</span> <span class="toc-text"> 自定义分页配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择合适的数据源类型"><span class="toc-number">4.3.</span> <span class="toc-text"> 选择合适的数据源类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据无效时发送通知"><span class="toc-number">4.4.</span> <span class="toc-text"> 数据无效时发送通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义数据源"><span class="toc-number">4.5.</span> <span class="toc-text"> 自定义数据源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#考虑内容更新的运作方式"><span class="toc-number">4.6.</span> <span class="toc-text"> 考虑内容更新的运作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提供数据映射"><span class="toc-number">4.7.</span> <span class="toc-text"> 提供数据映射</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s1.ax1x.com/2020/05/29/tmMe1O.jpg"></div><div class="author-info__name text-center">liubo</div><div class="author-info__description text-center">人最大的问题就是习惯自我辩解，但我们远比自己想象中更许巍、下作和幽暗。</div><div class="follow-button"><a href="https://github.com/liuclub">Follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">14</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s1.ax1x.com/2020/05/29/tmKQYV.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">凌晨三点的逗你玩</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">种类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">7-分页库</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JetPack/">JetPack</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 16 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>分页库可帮助您一次加载和显示一小块数据。按需载入部分数据会减少网络带宽和系统资源的使用量。</p>
</blockquote>
<h2 id="声明依赖项"><a class="markdownIt-Anchor" href="#声明依赖项"></a> 声明依赖项</h2>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> paging_version = <span class="string">"2.1.1"</span></span><br><span class="line"></span><br><span class="line">  implementation <span class="string">"androidx.paging:paging-runtime:$paging_version"</span> <span class="comment">// For Kotlin use paging-runtime-ktx</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// alternatively - without Android dependencies for testing</span></span><br><span class="line">  testImplementation <span class="string">"androidx.paging:paging-common:$paging_version"</span> <span class="comment">// For Kotlin use paging-common-ktx</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - RxJava support</span></span><br><span class="line">  implementation <span class="string">"androidx.paging:paging-rxjava2:$paging_version"</span> <span class="comment">// For Kotlin use paging-rxjava2-ktx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h2>
<h3 id="库架构"><a class="markdownIt-Anchor" href="#库架构"></a> 库架构</h3>
<h4 id="pagelist"><a class="markdownIt-Anchor" href="#pagelist"></a> PageList</h4>
<blockquote>
<p>分页库的关键组件是 PagedList 类，用于加载应用数据块或页面。随着所需数据的增多，系统会将其分页到现有的 PagedList 对象中。如果任何已加载的数据发生更改，会从 LiveData 或基于 RxJava2 的对象向可观察数据存储器发出一个新的 PagedList 实例。随着 PagedList 对象的生成，应用界面会呈现其内容，同时还会考虑界面控件的生命周期。</p>
</blockquote>
<p>示例</p>
<p>以下代码段展示了如何配置应用的视图模型，以便使用 PagedList 对象的 LiveData 存储器加载和显示数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertViewModel</span></span>(concertDao: ConcertDao) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> concertList: LiveData&lt;PagedList&lt;Concert&gt;&gt; =</span><br><span class="line">            concertDao.concertsByDate().toLiveData(pageSize = <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据"><a class="markdownIt-Anchor" href="#数据"></a> 数据</h4>
<blockquote>
<p>每个 PagedList 实例都会从对应的 DataSource 对象加载应用数据的最新快照。数据从您应用的后端或数据库流向 PagedList 对象。</p>
</blockquote>
<p>以下示例使用 Room 持久性库来整理应用数据，但如果要通过其他方式存储数据，也可以提供自己的数据源工厂：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ConcertDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The Int type parameter tells Room to use a PositionalDataSource object.</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM concerts ORDER BY date DESC"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">concertsByDate</span><span class="params">()</span></span>: DataSource.Factory&lt;<span class="built_in">Int</span>, Concert&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="界面"><a class="markdownIt-Anchor" href="#界面"></a> 界面</h4>
<blockquote>
<p>PagedList 类使用 PagedListAdapter 将项加载到 RecyclerView。这些类共同作用，在内容加载时抓取和显示内容，预取不在视线范围内的内容以及针对内容更改添加动画。</p>
</blockquote>
<h3 id="支持不同的数据架构"><a class="markdownIt-Anchor" href="#支持不同的数据架构"></a> 支持不同的数据架构</h3>
<h4 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h4>
<p>要显示来自后端服务器的数据，请使用同步版本的 <a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit API</a>，将信息加载到<a href="https://developer.android.com/topic/libraries/architecture/paging/data#custom-data-source" target="_blank" rel="noopener">您自己的自定义 <code>DataSource</code> 对象</a>中。</p>
<p><strong>注意</strong>：由于不同的应用处理和显示错误界面的方式不同，因此分页库的 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 对象不提供任何错误处理。如果发生错误，请遵循结果回调，并在稍后重试请求。有关此行为的示例，请参阅 <a href="https://github.com/googlesamples/android-architecture-components/tree/master/PagingWithNetworkSample">PagingWithNetwork 示例</a>。</p>
<h4 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h4>
<p>设置您的 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView" target="_blank" rel="noopener"><code>RecyclerView</code></a> 以观察本地存储空间，最好使用 <a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="noopener">Room 持久性库</a>。这样，无论您何时在应用数据库中插入或修改数据，这些更改都会自动反映在显示此数据的 <code>RecyclerView</code> 中。</p>
<h4 id="网络和数据库"><a class="markdownIt-Anchor" href="#网络和数据库"></a> 网络和数据库</h4>
<p>在开始观察数据库之后，您可以使用 <a href="https://developer.android.com/reference/androidx/paging/PagedList.BoundaryCallback" target="_blank" rel="noopener"><code>PagedList.BoundaryCallback</code></a> 监听数据库中的数据何时耗尽。然后，您可以从网络中获取更多项目并将它们插入到数据库中。如果界面正在观察数据库，则您只需执行此操作即可</p>
<h3 id="处理网络错误"><a class="markdownIt-Anchor" href="#处理网络错误"></a> 处理网络错误</h3>
<p>通过分页库，使用网络对要显示的数据进行抓取或分页时，请务必不要始终将网络视为“可用”或“不可用”，因为许多连接会断断续续或不稳定：</p>
<ul>
<li>特定服务器可能无法响应网络请求。</li>
<li>设备可能连接到速度较慢或信号较弱的网络。</li>
</ul>
<p>您的应用应检查每个请求是否失败，并在网络不可用的情况下尽可能正常恢复。例如，如果数据刷新步骤不起作用，您可以提供“重试”按钮供用户选择。如果在数据分页步骤中发生错误，则最好自动重新尝试分页请求。</p>
<h3 id="更新现有应用"><a class="markdownIt-Anchor" href="#更新现有应用"></a> 更新现有应用</h3>
<h4 id="自定义分页解析"><a class="markdownIt-Anchor" href="#自定义分页解析"></a> 自定义分页解析</h4>
<p>如果您使用自定义功能从应用的数据源加载较小的数据子集，则可以将此逻辑替换为 PagedList 类中的逻辑。PagedList 实例提供了与常见数据源的内置连接。这些实例还为应用界面中可能包含的 RecyclerView 对象提供了适配器。</p>
<h4 id="使用列表而不是网页加载的数据"><a class="markdownIt-Anchor" href="#使用列表而不是网页加载的数据"></a> 使用列表而不是网页加载的数据</h4>
<p>如果您使用内存中列表作为界面适配器的后备数据结构，并且列表中的项目数量可能会变得非常大，请考虑使用 <a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 类观察数据更新。</p>
<p>__PagedList 实例可以使用 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 或 <code>Observable</code> 向您的应用界面传递数据更新，从而最大限度地缩短加载时间并减少内存用量。__在应用中将 <a href="https://developer.android.com/reference/java/util/List" target="_blank" rel="noopener"><code>List</code></a> 对象替换成 <code>PagedList</code> 对象会得到更理想的结果，因为后者不需要对应用界面结构或数据更新逻辑进行任何更改。</p>
<h4 id="使用cursoradapter将数据光标与列表视图相关联"><a class="markdownIt-Anchor" href="#使用cursoradapter将数据光标与列表视图相关联"></a> 使用CursorAdapter将数据光标与列表视图相关联</h4>
<p>您的应用可能会使用 CursorAdapter 将 Cursor 的数据与 ListView 相关联。</p>
<p>在这种情况下，您通常需要：</p>
<ul>
<li>
<p>从 ListView 迁移到 RecyclerView，以后者作为应用的列表界面容器，</p>
</li>
<li>
<p>将 Cursor 组件替换为 Room 或 PositionalDataSource，具体取决于 Cursor 实例是否会访问 SQLite 数据库。</p>
<p>在某些情况下，例如在使用 Spinner 的实例时，您只需提供适配器本身。然后，库将获取加载到该适配器中的数据，并为您显示这些数据。</p>
<p>在这类情况下，请将适配器的数据类型更改为 LiveData<PagedList>，然后将此列表封装到 ArrayAdapter 对象中，再尝试让库类扩充界面中的这些项目。</p>
</li>
</ul>
<h4 id="使用asynclistutil异步加载内容"><a class="markdownIt-Anchor" href="#使用asynclistutil异步加载内容"></a> 使用AsyncListUtil异步加载内容</h4>
<p>如果您使用 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/AsyncListUtil" target="_blank" rel="noopener"><code>AsyncListUtil</code></a> 对象来异步加载和显示信息组，则通过分页库可以更轻松地加载数据：</p>
<ul>
<li>**您的数据无需固定位置。**通过分页库，您可以使用网络提供的密钥直接从后端加载数据。</li>
<li>**您的数据可能会非常庞大。**通过分页库，您可以将数据加载到网页中，直到没有剩余数据为止。</li>
<li>**您可以更轻松地观察数据。**分页库可以为您呈现应用 ViewModel 存储在可观察数据结构中的数据。</li>
</ul>
<h3 id="数据库示例"><a class="markdownIt-Anchor" href="#数据库示例"></a> 数据库示例</h3>
<h4 id="使用livedata观察分页数据"><a class="markdownIt-Anchor" href="#使用livedata观察分页数据"></a> 使用LiveData观察分页数据</h4>
<p>以下代码段显示了完整代码。随着在数据库中添加、移除或更改 concert 事件，<a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView" target="_blank" rel="noopener"><code>RecyclerView</code></a> 中的内容会自动且高效地更新：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ConcertDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The Int type parameter tells Room to use a PositionalDataSource</span></span><br><span class="line">    <span class="comment">// object, with position-based loading under the hood.</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM concerts ORDER BY date DESC"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">concertsByDate</span><span class="params">()</span></span>: DataSource.Factory&lt;<span class="built_in">Int</span>, Concert&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertViewModel</span></span>(concertDao: ConcertDao) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> concertList: LiveData&lt;PagedList&lt;Concert&gt;&gt; =</span><br><span class="line">            concertDao.concertsByDate().toLiveData(pageSize = <span class="number">50</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> viewModel = ViewModelProviders.of(<span class="keyword">this</span>)</span><br><span class="line">                .<span class="keyword">get</span>&lt;ConcertViewModel&gt;()</span><br><span class="line">        <span class="keyword">val</span> recyclerView = findViewById(R.id.concert_list)</span><br><span class="line">        <span class="keyword">val</span> adapter = ConcertAdapter()</span><br><span class="line">        viewModel.livePagedList.observe(<span class="keyword">this</span>, PagedList(adapter::submitList))</span><br><span class="line">        recyclerView.setAdapter(adapter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertAdapter</span></span>() :</span><br><span class="line">        PagedListAdapter&lt;Concert, ConcertViewHolder&gt;(DIFF_CALLBACK) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ConcertViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> concert: Concert? = getItem(position)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that "concert" is a placeholder if it's null.</span></span><br><span class="line">        holder.bindTo(concert)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> DIFF_CALLBACK = <span class="keyword">object</span> :</span><br><span class="line">                DiffUtil.ItemCallback&lt;Concert&gt;() &#123;</span><br><span class="line">            <span class="comment">// Concert details may have changed if reloaded from the database,</span></span><br><span class="line">            <span class="comment">// but ID is fixed.</span></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areItemsTheSame</span><span class="params">(oldConcert: <span class="type">Concert</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    newConcert: <span class="type">Concert</span>)</span></span> = oldConcert.id == newConcert.id</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areContentsTheSame</span><span class="params">(oldConcert: <span class="type">Concert</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    newConcert: <span class="type">Concert</span>)</span></span> = oldConcert == newConcert</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用rxjava2观察分页数据"><a class="markdownIt-Anchor" href="#使用rxjava2观察分页数据"></a> 使用RxJava2观察分页数据</h4>
<p>如果您倾向于使用 <a href="https://github.com/ReactiveX/RxJava">RxJava2</a> 而不是 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a>，则可以改为创建 <code>Observable</code> 或 <code>Flowable</code> 对象：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertViewModel</span></span>(concertDao: ConcertDao) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> concertList: Observable&lt;PagedList&lt;Concert&gt;&gt; =</span><br><span class="line">            concertDao.concertsByDate().toObservable(pageSize = <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，您可以使用以下代码段中的代码来开始和停止观察数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> adapter: ConcertAdapter()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: ConcertViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> disposable = CompositeDisposable()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> recyclerView = findViewById(R.id.concert_list)</span><br><span class="line">        viewModel = ViewModelProviders.of(<span class="keyword">this</span>)</span><br><span class="line">                .<span class="keyword">get</span>&lt;ConcertViewModel&gt;()</span><br><span class="line">        recyclerView.setAdapter(adapter)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        disposable.add(viewModel.concertList</span><br><span class="line">                .subscribe(adapter::submitList)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        disposable.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于基于 <a href="https://github.com/ReactiveX/RxJava">RxJava2</a> 的解决方案，<code>ConcertDao</code> 和 <code>ConcertAdapter</code> 的代码是相同的，对于基于 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 的解决方案也是如此。</p>
</blockquote>
<h2 id="显示分页列表"><a class="markdownIt-Anchor" href="#显示分页列表"></a> 显示分页列表</h2>
<blockquote>
<p>本指南基于_分页库概览_，介绍了如何在应用界面中向用户显示信息列表，尤其是在此信息发生变化时。</p>
</blockquote>
<h3 id="将界面与视图模型关联"><a class="markdownIt-Anchor" href="#将界面与视图模型关联"></a> 将界面与视图模型关联</h3>
<p>将 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 的实例连接到 <a href="https://developer.android.com/reference/androidx/paging/PagedListAdapter" target="_blank" rel="noopener"><code>PagedListAdapter</code></a>，如以下代码段所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> adapter = ConcertAdapter()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: ConcertViewModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    viewModel = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(ConcertViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    viewModel.concerts.observe(<span class="keyword">this</span>, Observer &#123; adapter.submitList(it) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数据源提供 PagedList 的新实例时，Activity 会将这些对象发送到适配器。PagedListAdapter 实现定义了更新的计算方式，并自动处理分页和列表差异。因此，您的 ViewHolder 只需要绑定到提供的特定项即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertAdapter</span></span>() :</span><br><span class="line">        PagedListAdapter&lt;Concert, ConcertViewHolder&gt;(DIFF_CALLBACK) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ConcertViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> concert: Concert? = getItem(position)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that "concert" is a placeholder if it's null.</span></span><br><span class="line">        holder.bindTo(concert)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> DIFF_CALLBACK = ... <span class="comment">// See Implement the diffing callback section.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.android.com/reference/androidx/paging/PagedListAdapter" target="_blank" rel="noopener"><code>PagedListAdapter</code></a> 使用 <a href="https://developer.android.com/reference/androidx/paging/PagedList.Callback" target="_blank" rel="noopener"><code>PagedList.Callback</code></a> 对象处理网页加载事件。当用户滚动时，<code>PagedListAdapter</code> 会调用 <a href="https://developer.android.com/reference/androidx/paging/PagedList#loadaround" target="_blank" rel="noopener"><code>PagedList.loadAround()</code></a> 来向底层 <a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 提供关于应从 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 获取哪些项的提示。</p>
<p><strong>注意</strong>：<a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 具有内容不可变特性。这意味着即使可以将新内容加载到 <code>PagedList</code> 的实例中，但加载的项目本身不会在加载后立即改变。因此，如果 <code>PagedList</code> 中的内容更新，则 <a href="https://developer.android.com/reference/androidx/paging/PagedListAdapter" target="_blank" rel="noopener"><code>PagedListAdapter</code></a> 对象会收到包含更新后信息的<strong>全新 <code>PagedList</code></strong>。</p>
<h3 id="实现差异回调"><a class="markdownIt-Anchor" href="#实现差异回调"></a> 实现差异回调</h3>
<p>以下示例展示了用于比较相关对象字段的 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil.ItemCallback#arecontentsthesame" target="_blank" rel="noopener"><code>areContentsTheSame()</code></a> 的手动实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> DIFF_CALLBACK = <span class="keyword">object</span> : DiffUtil.ItemCallback&lt;Concert&gt;() &#123;</span><br><span class="line">    <span class="comment">// The ID property identifies when items are the same.</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areItemsTheSame</span><span class="params">(oldItem: <span class="type">Concert</span>, newItem: <span class="type">Concert</span>)</span></span> =</span><br><span class="line">            oldItem.id == newItem.id</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you use the "==" operator, make sure that the object implements</span></span><br><span class="line">    <span class="comment">// .equals(). Alternatively, write custom data comparison logic here.</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areContentsTheSame</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            oldItem: <span class="type">Concert</span>, newItem: <span class="type">Concert</span>)</span></span> = oldItem == newItem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于适配器包含比较项的定义，因此适配器会在有新的 <code>PagedList</code> 对象加载时自动检测这些项的更改。这样，适配器就会在您的 <code>RecyclerView</code> 对象内触发有效的项目动画。</p>
</blockquote>
<h3 id="使用其它适配器类型实现差异回调功能"><a class="markdownIt-Anchor" href="#使用其它适配器类型实现差异回调功能"></a> 使用其它适配器类型实现差异回调功能</h3>
<p>如果您选择不从 <a href="https://developer.android.com/reference/androidx/paging/PagedListAdapter" target="_blank" rel="noopener"><code>PagedListAdapter</code></a> 继承（例如，当您使用的库提供自己的适配器时），仍可以直接通过 <a href="https://developer.android.com/reference/androidx/paging/AsyncPagedListDiffer" target="_blank" rel="noopener"><code>AsyncPagedListDiffer</code></a> 对象来使用分页库适配器的差异化功能。</p>
<h3 id="在界面中提供占位符placeholder"><a class="markdownIt-Anchor" href="#在界面中提供占位符placeholder"></a> 在界面中提供占位符（placeholder）</h3>
<p>如果您希望界面在应用完成数据获取前显示列表，可以向用户显示占位符列表项。<a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 对这种情况的处理方式是将列表项数据显示为 <code>null</code>，直到加载了数据为止。</p>
<blockquote>
<p><strong>注意</strong>：默认情况下，分页库支持这种占位符行为。</p>
</blockquote>
<p>占位符具有以下优点：</p>
<ul>
<li><strong>支持滚动条</strong>：<a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 可向 <a href="https://developer.android.com/reference/androidx/paging/PagedListAdapter" target="_blank" rel="noopener"><code>PagedListAdapter</code></a> 提供列表项数量。此信息允许适配器绘制滚动条来传达整个列表大小。有新页面载入时，滚动条不会跳到指定位置，因为列表不会改变大小。</li>
<li><strong>无需加载旋转图标</strong>：由于列表大小已知，因此无需提醒用户正在加载更多项。占位符本身会传达这一信息。</li>
</ul>
<p>不过，在添加对占位符的支持之前，请注意以下前提条件：</p>
<ul>
<li><strong>需要可计数的数据集</strong>：<a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="noopener">Room 持久性库</a> 中的 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 实例可以有效地计算项的数量。但如果您使用的是自定义本地存储解决方案或<a href="https://developer.android.com/topic/libraries/architecture/paging#network-only-data-arch" target="_blank" rel="noopener">网络专用数据架构</a>，确定数据集包含多少项可能会开销极大，甚至根本无法确定。</li>
<li><strong>适配器必须考虑未加载的项</strong>：为准备列表以应对增长而使用的适配器或呈现机制需要处理 Null 列表项。例如，将数据绑定到 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder" target="_blank" rel="noopener"><code>ViewHolder</code></a> 时，您需要提供默认值来表示未加载数据。</li>
<li><strong>需要同样大小的项视图</strong>：如果列表项大小会随着内容而变（例如社交网络更新），则项之间的交叉渐变效果并不理想。在这种情况下，我们强烈建议停用占位符。</li>
</ul>
<h2 id="加载分页数据"><a class="markdownIt-Anchor" href="#加载分页数据"></a> 加载分页数据</h2>
<blockquote>
<p>讨论如何自定义应用的数据加载解决方案以满足应用的架构需求</p>
</blockquote>
<h3 id="构造可观察列表"><a class="markdownIt-Anchor" href="#构造可观察列表"></a> 构造可观察列表</h3>
<blockquote>
<p>通常，您的界面代码会观察 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 对象（如果您使用 <a href="https://github.com/ReactiveX/RxJava">RxJava2</a>，则会观察 <code>Flowable</code> 或 <code>Observable</code> 对象），该对象位于您应用的 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 中。此可观察对象搭起应用列表数据的呈现与内容之间的关联。</p>
<p>为了创建其中一个可观察的 <a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 对象，请将 <a href="https://developer.android.com/reference/androidx/paging/DataSource.Factory" target="_blank" rel="noopener"><code>DataSource.Factory</code></a> 的实例传递到 <a href="https://developer.android.com/reference/androidx/paging/LivePagedListBuilder" target="_blank" rel="noopener"><code>LivePagedListBuilder</code></a> 或 <a href="https://developer.android.com/reference/androidx/paging/RxPagedListBuilder" target="_blank" rel="noopener"><code>RxPagedListBuilder</code></a> 对象。<a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 对象会加载单个 <code>PagedList</code> 的页面。Factory 类会创建新的 <code>PagedList</code> 实例来响应内容更新，例如数据库表失效和网络刷新。<a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="noopener">Room 持久性库</a>可为您提供 <code>DataSource.Factory</code> 对象，您也可以<a href="https://developer.android.com/topic/libraries/architecture/paging/data#custom-data-source" target="_blank" rel="noopener">构建自己的对象</a>。</p>
</blockquote>
<p>以下代码段展示了如何使用 Room 的 <a href="https://developer.android.com/reference/androidx/paging/DataSource.Factory" target="_blank" rel="noopener"><code>DataSource.Factory</code></a> 构建功能在应用的 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener"><code>ViewModel</code></a> 类中创建新的 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 实例：</p>
<p>ConcertDao</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ConcertDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The Int type parameter tells Room to use a PositionalDataSource</span></span><br><span class="line">    <span class="comment">// object, with position-based loading under the hood.</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">"SELECT * FROM concerts ORDER BY date DESC"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">concertsByDate</span><span class="params">()</span></span>: DataSource.Factory&lt;<span class="built_in">Int</span>, Concert&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcertViewModel</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The Int type argument corresponds to a PositionalDataSource object.</span></span><br><span class="line"><span class="keyword">val</span> myConcertDataSource : DataSource.Factory&lt;<span class="built_in">Int</span>, Concert&gt; =</span><br><span class="line">       concertDao.concertsByDate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> concertList = myConcertDataSource.toLiveData(pageSize = <span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<h3 id="自定义分页配置"><a class="markdownIt-Anchor" href="#自定义分页配置"></a> 自定义分页配置</h3>
<blockquote>
<p>要进一步为高级用例配置 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a>，您还可以定义自己的分页配置。特别是，您可以定义以下特性：</p>
<ul>
<li><strong><a href="https://developer.android.com/reference/androidx/paging/PagedList.Config.Builder#setPageSize(int)" target="_blank" rel="noopener">页面大小</a></strong>：每个页面中的项数。</li>
<li><strong><a href="https://developer.android.com/reference/androidx/paging/PagedList.Config.Builder#setPrefetchDistance(int)" target="_blank" rel="noopener">预取距离</a></strong>：给定应用界面中的最后一个可见项，分页库应尝试提前获取的超出此最后一项的项数。此值应是页面大小的数倍大。</li>
<li><strong><a href="https://developer.android.com/reference/androidx/paging/PagedList.Config.Builder#setEnablePlaceholders(boolean)" target="_blank" rel="noopener">占位符存在</a></strong>：确定界面是否对尚未完成加载的列表项显示占位符。有关使用占位符的优缺点的探讨，请参阅如何<a href="https://developer.android.com/topic/libraries/architecture/paging/ui#provide-placeholders" target="_blank" rel="noopener">在界面中提供占位符</a>。</li>
</ul>
</blockquote>
<p>如果您希望更好地控制分页库何时从应用数据库加载列表，请将自定义 <a href="https://developer.android.com/reference/java/util/concurrent/Executor" target="_blank" rel="noopener"><code>Executor</code></a> 对象传递给 <a href="https://developer.android.com/reference/androidx/paging/LivePagedListBuilder" target="_blank" rel="noopener"><code>LivePagedListBuilder</code></a>，如以下代码段所示：</p>
<p>ConcertViewModel</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myPagingConfig = Config(</span><br><span class="line">        pageSize = <span class="number">50</span>,</span><br><span class="line">        prefetchDistance = <span class="number">150</span>,</span><br><span class="line">        enablePlaceholders = <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The Int type argument corresponds to a PositionalDataSource object.</span></span><br><span class="line"><span class="keyword">val</span> myConcertDataSource : DataSource.Factory&lt;<span class="built_in">Int</span>, Concert&gt; =</span><br><span class="line">        concertDao.concertsByDate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> concertList = myConcertDataSource.toLiveData(</span><br><span class="line">        pagingConfig = myPagingConfig,</span><br><span class="line">        fetchExecutor = myExecutor</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="选择合适的数据源类型"><a class="markdownIt-Anchor" href="#选择合适的数据源类型"></a> 选择合适的数据源类型</h3>
<blockquote>
<p>请务必连接到能最好地处理源数据结构的数据源：</p>
<ul>
<li>
<p>如果您加载的网页嵌入了上一页/下一页的键，请使用 <a href="https://developer.android.com/reference/androidx/paging/PageKeyedDataSource" target="_blank" rel="noopener"><code>PageKeyedDataSource</code></a>。例如，如果您从网络中获取社交媒体帖子，则可能需要将一个 <code>nextPage</code> 令牌从一次加载传递到后续加载。</p>
</li>
<li>
<p>如果您需要使用项目 N 中的数据来获取项目 N+1，请使用 <a href="https://developer.android.com/reference/androidx/paging/ItemKeyedDataSource" target="_blank" rel="noopener"><code>ItemKeyedDataSource</code></a>。例如，如果您要为讨论应用获取会话式评论，则可能需要传递最后一条评论的 ID 以获取下一条评论的内容。</p>
</li>
<li>
<p>如果您需要从数据存储区中选择的任意位置获取数据页，请使用 <a href="https://developer.android.com/reference/androidx/paging/PositionalDataSource" target="_blank" rel="noopener"><code>PositionalDataSource</code></a>。该类支持从您选择的任意位置开始请求一组数据项。例如，该请求可能会返回从位置 1500 开始的 50 个数据项。</p>
</li>
</ul>
</blockquote>
<h3 id="数据无效时发送通知"><a class="markdownIt-Anchor" href="#数据无效时发送通知"></a> 数据无效时发送通知</h3>
<p>当使用分页库时，由<strong>数据层</strong>在表或行已过时通知应用的其他层。为此，请从您为应用选择的 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 类中调用 <a href="https://developer.android.com/reference/androidx/paging/DataSource#invalidate" target="_blank" rel="noopener"><code>invalidate()</code></a>。</p>
<blockquote>
<p><strong>注意</strong>：应用界面可以使用<a href="https://developer.android.com/training/swipe" target="_blank" rel="noopener">下拉刷新</a>模型触发此数据失效功能。</p>
</blockquote>
<h3 id="自定义数据源"><a class="markdownIt-Anchor" href="#自定义数据源"></a> 自定义数据源</h3>
<p>如果您使用自定义本地数据解决方案，或直接从网络加载数据，则可以实现其中一个 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 子类。</p>
<p>以下代码段展示了从指定音乐会开始时间开始的数据源：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertTimeDataSource</span></span>() :</span><br><span class="line">        ItemKeyedDataSource&lt;Date, Concert&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getKey</span><span class="params">(item: <span class="type">Concert</span>)</span></span> = item.startTime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadInitial</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            params: <span class="type">LoadInitialParams</span>&lt;<span class="type">Date</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">            callback: <span class="type">LoadInitialCallback</span>&lt;<span class="type">Concert</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> items = fetchItems(params.requestedInitialKey,</span><br><span class="line">                params.requestedLoadSize)</span><br><span class="line">        callback.onResult(items)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadAfter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            params: <span class="type">LoadParams</span>&lt;<span class="type">Date</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">            callback: <span class="type">LoadCallback</span>&lt;<span class="type">Concert</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> items = fetchItemsAfter(</span><br><span class="line">            date = params.key,</span><br><span class="line">            limit = params.requestedLoadSize)</span><br><span class="line">        callback.onResult(items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，您可以通过创建具体的 <a href="https://developer.android.com/reference/androidx/paging/DataSource.Factory" target="_blank" rel="noopener"><code>DataSource.Factory</code></a> 子类，将此自定义数据加载到 <code>PagedList</code> 对象中。</p>
<p>以下代码段展示了如何生成前面代码段中定义的自定义数据源的新实例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertTimeDataSourceFactory</span> :<span class="type"></span></span></span><br><span class="line">        DataSource.Factory&lt;Date, Concert&gt;() &#123;</span><br><span class="line">    <span class="keyword">val</span> sourceLiveData = MutableLiveData&lt;ConcertTimeDataSource&gt;()</span><br><span class="line">    <span class="keyword">var</span> latestSource: ConcertDataSource?</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: DataSource&lt;Date, Concert&gt; &#123;</span><br><span class="line">        latestSource = ConcertTimeDataSource()</span><br><span class="line">        sourceLiveData.postValue(latestSource)</span><br><span class="line">        <span class="keyword">return</span> latestSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="考虑内容更新的运作方式"><a class="markdownIt-Anchor" href="#考虑内容更新的运作方式"></a> 考虑内容更新的运作方式</h3>
<p>构建可观察的 <a href="https://developer.android.com/reference/androidx/paging/PagedList" target="_blank" rel="noopener"><code>PagedList</code></a> 对象时，请考虑内容更新的运作方式。如果直接从 <a href="https://developer.android.com/training/data-storage/room" target="_blank" rel="noopener">Room 数据库</a>加载数据，则更新会自动推送至应用界面。</p>
<p>使用分页网络 API 时，您通常需要使用“下拉刷新”这样的用户互动，以指示系统让最近使用的 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 的失效。然后请求该数据源的新实例。</p>
<p>以下代码段演示了此行为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        concertTimeViewModel.refreshState.observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">            <span class="comment">// Shows one possible way of triggering a refresh operation.</span></span><br><span class="line">            swipeRefreshLayout.isRefreshing =</span><br><span class="line">                    it == MyNetworkState.LOADING</span><br><span class="line">        &#125;)</span><br><span class="line">        swipeRefreshLayout.setOnRefreshListener &#123;</span><br><span class="line">            concertTimeViewModel.invalidateDataSource()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertTimeViewModel</span></span>(firstConcertStartTime: Date) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> dataSourceFactory = ConcertTimeDataSourceFactory(firstConcertStartTime)</span><br><span class="line">    <span class="keyword">val</span> concertList: LiveData&lt;PagedList&lt;Concert&gt;&gt; =</span><br><span class="line">            dataSourceFactory.toLiveData(</span><br><span class="line">                pageSize = <span class="number">50</span>,</span><br><span class="line">                fetchExecutor = myExecutor</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invalidateDataSource</span><span class="params">()</span></span> =</span><br><span class="line">            dataSourceFactory.sourceLiveData.value?.invalidate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提供数据映射"><a class="markdownIt-Anchor" href="#提供数据映射"></a> 提供数据映射</h3>
<p>分页库支持基于项目或基于页面转换由 <a href="https://developer.android.com/reference/androidx/paging/DataSource" target="_blank" rel="noopener"><code>DataSource</code></a> 加载的项目。</p>
<p>在以下代码段中，音乐会名称和音乐会日期的组合映射到同时包含名称和日期的单个字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcertViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> concertDescriptions : LiveData&lt;PagedList&lt;String&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> concerts = database.allConcertsFactory()</span><br><span class="line">                    .map <span class="string">"<span class="subst">$&#123;it.name&#125;</span> - <span class="subst">$&#123;it.date&#125;</span>"</span> &#125;</span><br><span class="line">                    .toLiveData(pageSize = <span class="number">50</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果您希望在项目加载后进行换行、转换或准备，这将非常有用。由于这项工作是在提取执行程序上完成的，因此您可以执行开销可能很大的工作，如从磁盘读取或查询单独的数据库。</strong></p>
<blockquote>
<p><strong>注意</strong>：JOIN 查询作为 <code>map()</code> 的一部分，总是能够更高效地进行重新查询。</p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">liubo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/liuclub/liuclub.github.io.git/2020/05/28/7-%E5%88%86%E9%A1%B5%E5%BA%93/">https://github.com/liuclub/liuclub.github.io.git/2020/05/28/7-%E5%88%86%E9%A1%B5%E5%BA%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/liuclub/liuclub.github.io.git">凌晨三点的逗你玩</a>！</span></div></div><div class="post-meta__tag-list"></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://s1.ax1x.com/2020/05/29/tmKo6g.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://s1.ax1x.com/2020/05/29/tmK5p8.png"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/28/8-Room%E6%8C%81%E4%B9%85%E6%80%A7%E5%BA%93/"><i class="fa fa-chevron-left">  </i><span>8-Room持久性库</span></a></div><div class="next-post pull-right"><a href="/2020/05/28/6-LiveData/"><span>6-LiveData</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s1.ax1x.com/2020/05/29/tmKQYV.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By liubo</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>