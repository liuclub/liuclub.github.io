<!DOCTYPE html><html lang="[&quot;zh-tw&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="10-WorkManager"><meta name="keywords" content=""><meta name="author" content="liuclub"><meta name="copyright" content="liuclub"><title>10-WorkManager | 凌晨三点的逗你玩</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#概览"><span class="toc-number">1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用入门"><span class="toc-number">2.</span> <span class="toc-text">使用入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#将WorkManager添加到项目中"><span class="toc-number">2.1.</span> <span class="toc-text">将WorkManager添加到项目中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建后台任务"><span class="toc-number">2.2.</span> <span class="toc-text">创建后台任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置运行任务的方式和时间"><span class="toc-number">2.3.</span> <span class="toc-text">配置运行任务的方式和时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将任务提交给系统"><span class="toc-number">2.4.</span> <span class="toc-text">将任务提交给系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#后续步骤"><span class="toc-number">2.5.</span> <span class="toc-text">后续步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法指南"><span class="toc-number">3.</span> <span class="toc-text">方法指南</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义WorkRequest"><span class="toc-number">3.1.</span> <span class="toc-text">定义WorkRequest</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#工作约束"><span class="toc-number">3.1.1.</span> <span class="toc-text">工作约束</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#初始延迟"><span class="toc-number">3.1.2.</span> <span class="toc-text">初始延迟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重试和退避政策"><span class="toc-number">3.1.3.</span> <span class="toc-text">重试和退避政策</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#定义任务的输入-输出"><span class="toc-number">3.1.4.</span> <span class="toc-text">定义任务的输入&#x2F;输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#标记工作"><span class="toc-number">3.1.5.</span> <span class="toc-text">标记工作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#观察工作状态"><span class="toc-number">3.2.</span> <span class="toc-text">观察工作状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#工作状态"><span class="toc-number">3.2.1.</span> <span class="toc-text">工作状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#观察工作状态-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">观察工作状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#观察工作器的中间进度"><span class="toc-number">3.3.</span> <span class="toc-text">观察工作器的中间进度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#更新进度"><span class="toc-number">3.3.1.</span> <span class="toc-text">更新进度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#观察进度"><span class="toc-number">3.3.2.</span> <span class="toc-text">观察进度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将工作链接在一起"><span class="toc-number">3.4.</span> <span class="toc-text">将工作链接在一起</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#简介"><span class="toc-number">3.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Input-Merger"><span class="toc-number">3.4.2.</span> <span class="toc-text">Input Merger</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#链接和工作状态"><span class="toc-number">3.4.3.</span> <span class="toc-text">链接和工作状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取消和停止工作"><span class="toc-number">3.5.</span> <span class="toc-text">取消和停止工作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#停止正在运行的工作器"><span class="toc-number">3.5.1.</span> <span class="toc-text">停止正在运行的工作器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理重复性工作"><span class="toc-number">3.6.</span> <span class="toc-text">处理重复性工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理唯一作业"><span class="toc-number">3.7.</span> <span class="toc-text">处理唯一作业</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试Worker实现"><span class="toc-number">3.8.</span> <span class="toc-text">测试Worker实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#测试ListenableWorker及其子类"><span class="toc-number">3.8.1.</span> <span class="toc-text">测试ListenableWorker及其子类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#测试Workers"><span class="toc-number">3.8.2.</span> <span class="toc-text">测试Workers</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用WorkManager进行集成测试"><span class="toc-number">3.9.</span> <span class="toc-text">使用WorkManager进行集成测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#介绍和设置"><span class="toc-number">3.9.1.</span> <span class="toc-text">介绍和设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#概念"><span class="toc-number">3.9.2.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#结构化测试"><span class="toc-number">3.9.3.</span> <span class="toc-text">结构化测试</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#基本测试"><span class="toc-number">3.9.3.1.</span> <span class="toc-text">基本测试</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#模拟约束、延迟和周期性工作"><span class="toc-number">3.9.4.</span> <span class="toc-text">模拟约束、延迟和周期性工作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#测试初始化延迟"><span class="toc-number">3.9.4.1.</span> <span class="toc-text">测试初始化延迟</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#测试约束"><span class="toc-number">3.9.4.2.</span> <span class="toc-text">测试约束</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#测试周期性工作"><span class="toc-number">3.9.4.3.</span> <span class="toc-text">测试周期性工作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调试WorkManager"><span class="toc-number">3.10.</span> <span class="toc-text">调试WorkManager</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高级概念"><span class="toc-number">4.</span> <span class="toc-text">高级概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#配置和初始化"><span class="toc-number">4.1.</span> <span class="toc-text">配置和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#WorkManager-2-1-0及更高版本"><span class="toc-number">4.1.1.</span> <span class="toc-text">WorkManager 2.1.0及更高版本</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#按需初始化"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">按需初始化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#移除默认初始化程序"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">移除默认初始化程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#实现Configration-Provider"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">实现Configration.Provider</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WorkManager-2-0-1及更早版本"><span class="toc-number">4.1.2.</span> <span class="toc-text">WorkManager 2.0.1及更早版本</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#默认初始化"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">默认初始化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#自定义初始化"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">自定义初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WorkManager中的线程处理"><span class="toc-number">4.2.</span> <span class="toc-text">WorkManager中的线程处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#概览-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#用Worker处理线程"><span class="toc-number">4.2.2.</span> <span class="toc-text">用Worker处理线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#用CoroutineWorker处理线程"><span class="toc-number">4.2.3.</span> <span class="toc-text">用CoroutineWorker处理线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#用RxWorker处理线程"><span class="toc-number">4.2.4.</span> <span class="toc-text">用RxWorker处理线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#用ListenableWorker处理线程"><span class="toc-number">4.2.5.</span> <span class="toc-text">用ListenableWorker处理线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#支持长时间运行的工作器"><span class="toc-number">4.3.</span> <span class="toc-text">支持长时间运行的工作器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建和管理长时间运行的任务"><span class="toc-number">4.3.1.</span> <span class="toc-text">创建和管理长时间运行的任务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Java"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">Java</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Kotlin"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">Kotlin</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从Firebase-JobDispatcher迁移"><span class="toc-number">5.</span> <span class="toc-text">从Firebase JobDispatcher迁移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从GCMNetworkManager迁移"><span class="toc-number">6.</span> <span class="toc-text">从GCMNetworkManager迁移</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">liuclub</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">凌晨三点的逗你玩</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">10-WorkManager</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JetPack/">JetPack</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[TOC]</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>使用 WorkManager API 可以轻松地调度即使在应用退出或设备重启时仍应运行的可延迟异步任务。</p>
<p><strong>主要功能</strong>：</p>
<ul>
<li>最高向后兼容到 API 14<ul>
<li>在运行 API 23 (Android 6.0)及以上级别的设备上使用 JobScheduler</li>
<li>在运行 API 14-22 的设备上结合使用 BroadcastReceiver 和 AlarmManager</li>
</ul>
</li>
<li>添加网络可用性或充电状态等工作约束</li>
<li>调度一次性或周期性异步任务</li>
<li>监控和管理计划任务</li>
<li>将任务链接起来</li>
<li>确保任务执行，即使应用或设备重启也同样执行任务</li>
<li>遵循低电耗模式等省电功能</li>
</ul>
<p>WorkManager 旨在用于<strong>可延迟</strong>运行（即不需要立即运行）并且在应用退出或设备重启时必须能够可靠运行的任务。例如：</p>
<ul>
<li>向后端服务发送日志或分析数据</li>
<li>定期将应用数据与服务器同步</li>
</ul>
<p>WorkManager 不适用于应用进程结束时能够安全终止的运行中后台工作，也不适用于需要立即执行的任务。请查看<a href="https://developer.android.com/guide/background" target="_blank" rel="noopener">后台处理指南</a>，了解哪种解决方案符合您的需求。</p>
<h3 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h3><h4 id="将WorkManager添加到项目中"><a href="#将WorkManager添加到项目中" class="headerlink" title="将WorkManager添加到项目中"></a>将WorkManager添加到项目中</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  def work_version = <span class="string">"2.3.1"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (Java only)</span></span><br><span class="line">    implementation <span class="string">"androidx.work:work-runtime:<span class="variable">$work_version</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin + coroutines</span></span><br><span class="line">    implementation <span class="string">"androidx.work:work-runtime-ktx:<span class="variable">$work_version</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava2 support</span></span><br><span class="line">    implementation <span class="string">"androidx.work:work-rxjava2:<span class="variable">$work_version</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - GCMNetworkManager support</span></span><br><span class="line">    implementation <span class="string">"androidx.work:work-gcm:<span class="variable">$work_version</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers</span></span><br><span class="line">    androidTestImplementation <span class="string">"androidx.work:work-testing:<span class="variable">$work_version</span>"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建后台任务"><a href="#创建后台任务" class="headerlink" title="创建后台任务"></a>创建后台任务</h4><p>  任务是使用 <a href="https://developer.android.com/reference/androidx/work/Worker" target="_blank" rel="noopener"><code>Worker</code></a> 类定义的。<code>doWork()</code> 方法在 WorkManager 提供的后台线程上同步运行。</p>
<p>  要创建后台任务，请扩展 <code>Worker</code> 类并替换 <code>doWork()</code> 方法。</p>
<p>  例如，要创建上传图像的 <code>Worker</code>，您可以执行以下操作：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadWorker</span></span>(appContext: Context, workerParams: WorkerParameters)</span><br><span class="line">    : Worker(appContext, workerParams) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="comment">// Do the work here--in this case, upload the images.</span></span><br><span class="line"></span><br><span class="line">        uploadImages()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Indicate whether the task finished successfully with the Result</span></span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从 <code>doWork()</code> 返回的 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result" target="_blank" rel="noopener"><code>Result</code></a> 会通知 WorkManager 任务是否：</p>
<ul>
<li><p>已成功完成：<code>Result.success()</code></p>
</li>
<li><p>已失败：<code>Result.failure()</code></p>
</li>
<li><p>需要稍后重试：<code>Result.retry()</code></p>
</li>
</ul>
</blockquote>
<h4 id="配置运行任务的方式和时间"><a href="#配置运行任务的方式和时间" class="headerlink" title="配置运行任务的方式和时间"></a>配置运行任务的方式和时间</h4><p>  <code>Worker</code> 定义工作单元，<a href="https://developer.android.com/reference/androidx/work/WorkRequest" target="_blank" rel="noopener"><code>WorkRequest</code></a> 则定义工作的运行方式和时间。</p>
<blockquote>
<p>任务可以是一次性的，也可以是周期性的。</p>
<ul>
<li><p>一次性 <code>WorkRequest</code>，请使用 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" target="_blank" rel="noopener"><code>OneTimeWorkRequest</code></a>;</p>
</li>
<li><p>周期性工作，请使用 <a href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest" target="_blank" rel="noopener"><code>PeriodicWorkRequest</code></a></p>
</li>
</ul>
</blockquote>
<p>在本例中，为 UploadWorker 构建 <code>WorkRequest</code> 最简单的示例为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;().build()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>WorkRequest</code> 中还可以包含其他信息，例如任务在运行时应遵循的约束、工作输入、延迟，以及重试工作的退避时间政策。</p>
</blockquote>
<h4 id="将任务提交给系统"><a href="#将任务提交给系统" class="headerlink" title="将任务提交给系统"></a>将任务提交给系统</h4><p>定义 <code>WorkRequest</code> 之后，您现在可以通过 <a href="https://developer.android.com/reference/androidx/work/WorkManager" target="_blank" rel="noopener"><code>WorkManager</code></a> 使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#enqueue(androidx.work.WorkRequest)" target="_blank" rel="noopener"><code>enqueue()</code></a> 方法来调度它。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(myContext).enqueue(uploadWorkRequest)</span><br></pre></td></tr></table></figure>



<h4 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h4><blockquote>
<ul>
<li>查看 WorkManager 在<a href="https://github.com/googlesamples/android-architecture-components/tree/master/WorkManagerSample">简单的图像处理应用</a>中的运行情况</li>
<li>使用 <a href="https://codelabs.developers.google.com/codelabs/android-workmanager-kt/" target="_blank" rel="noopener">Kotlin</a>、<a href="https://codelabs.developers.google.com/codelabs/android-workmanager/" target="_blank" rel="noopener">Java</a> 在 codelab 中进行实操练习</li>
<li>了解<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work" target="_blank" rel="noopener">如何添加工作约束</a>。</li>
</ul>
</blockquote>
<h3 id="方法指南"><a href="#方法指南" class="headerlink" title="方法指南"></a>方法指南</h3><h4 id="定义WorkRequest"><a href="#定义WorkRequest" class="headerlink" title="定义WorkRequest"></a>定义WorkRequest</h4><h5 id="工作约束"><a href="#工作约束" class="headerlink" title="工作约束"></a>工作约束</h5><p>您可以向工作添加 <code>Constraints</code>，以指明工作何时可以运行。</p>
<p>例如，您可以指定工作应仅在设备空闲且接通电源时运行。</p>
<p>下面的代码展示了如何将这些约束添加到 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" target="_blank" rel="noopener"><code>OneTimeWorkRequest</code></a>。有关所支持约束的完整列表，请参阅 <a href="https://developer.android.com/reference/androidx/work/Constraints.Builder" target="_blank" rel="noopener"><code>Constraints.Builder</code> 参考文档</a>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a Constraints object that defines when the task should run</span></span><br><span class="line"><span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">        .setRequiresDeviceIdle(<span class="literal">true</span>)</span><br><span class="line">        .setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...then create a OneTimeWorkRequest that uses those constraints</span></span><br><span class="line"><span class="keyword">val</span> compressionWork = OneTimeWorkRequestBuilder&lt;CompressWorker&gt;().setConstraints(constraints).build()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果指定了多个约束，您的任务将仅在满足所有约束时才会运行。</p>
<p>如果在任务运行期间某个约束不再得到满足，则 WorkManager 将停止工作器。当约束继续得到满足时，系统将重新尝试执行该任务。</p>
</blockquote>
<h5 id="初始延迟"><a href="#初始延迟" class="headerlink" title="初始延迟"></a>初始延迟</h5><p>如果您的工作没有约束，或者工作加入队列时所有约束均已得到满足，则系统可能会选择立即运行任务。如果您不希望任务立即运行，则可以将工作指定为在经过最短的初始延迟后启动。</p>
<p>下面的示例展示了如何将任务设置为在加入队列后至少经过 10 分钟再运行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;()</span><br><span class="line">        .setInitialDelay(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：执行工作器的确切时间还取决于 WorkRequest 中使用的约束和系统优化。WorkManager 经过设计，能够在满足这些约束的情况下提供可能的最佳行为。</p>
<h5 id="重试和退避政策"><a href="#重试和退避政策" class="headerlink" title="重试和退避政策"></a>重试和退避政策</h5><p>如果您需要让 WorkManager 重新尝试执行您的任务，可以从工作器返回 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result#retry()" target="_blank" rel="noopener"><code>Result.retry()</code></a>。</p>
<p>然后，系统会根据默认的退避延迟时间和政策重新调度您的工作。退避延迟时间指定重试工作前的最短等待时间。<a href="https://developer.android.com/reference/androidx/work/BackoffPolicy" target="_blank" rel="noopener">退避政策</a>定义了在后续重试的尝试过程中，退避延迟时间随时间以怎样的方式增长；默认情况下按 <a href="https://developer.android.com/reference/androidx/work/BackoffPolicy" target="_blank" rel="noopener"><code>EXPONENTIAL</code></a> 延长。</p>
<p>以下是自定义退避延迟时间和政策的示例。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;()</span><br><span class="line">          .setBackoffCriteria(</span><br><span class="line">                  BackoffPolicy.LINEAR,</span><br><span class="line">                  OneTimeWorkRequest.MIN_BACKOFF_MILLIS,</span><br><span class="line">                  TimeUnit.MILLISECONDS)</span><br><span class="line">          .build()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Criteria      标准, 准则, 规范</p>
</blockquote>
<h5 id="定义任务的输入-输出"><a href="#定义任务的输入-输出" class="headerlink" title="定义任务的输入/输出"></a>定义任务的输入/输出</h5><p>任务可能需要数据以输入参数的形式传入，或者将数据返回为结果。例如，某个任务负责处理图像上传，它要求以要上传的图像的 URI 为输入，并且可能要求用已上传图像的网址作为输出。</p>
<p>输入和输出值以键值对的形式存储在 <a href="https://developer.android.com/reference/androidx/work/Data" target="_blank" rel="noopener"><code>Data</code></a> 对象中。下面的代码展示了如何在 <code>WorkRequest</code> 中设置输入数据。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// workDataOf (part of KTX) converts a list of pairs to a [Data] object.</span></span><br><span class="line"><span class="keyword">val</span> imageData = workDataOf(Constants.KEY_IMAGE_URI to imageUriString)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;()</span><br><span class="line">        .setInputData(imageData)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>

<p><code>Worker</code> 类可通过调用 Worker.getInputData() 访问输入参数。</p>
<p>类似地，<code>Data</code> 类可用于输出返回值。要返回 <code>Data</code> 对象，请将它包含到 <code>Result</code> 的 <code>Result.success()</code> 或 <code>Result.failure()</code> 中，如下所示。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadWorker</span></span>(appContext: Context, workerParams: WorkerParameters)</span><br><span class="line">    : Worker(appContext, workerParams) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the input</span></span><br><span class="line">            <span class="keyword">val</span> imageUriInput = getInputData().getString(Constants.KEY_IMAGE_URI)</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> validate inputs.</span></span><br><span class="line">            <span class="comment">// Do the work</span></span><br><span class="line">            <span class="keyword">val</span> response = uploadFile(imageUriInput)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the output of the work</span></span><br><span class="line">            <span class="keyword">val</span> outputData = workDataOf(Constants.KEY_IMAGE_URL to response.imageUrl)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Return the output</span></span><br><span class="line">            <span class="keyword">return</span> Result.success(outputData)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：按照设计，<code>Data</code> 对象应该很小，值可以是字符串、基元类型或数组变体。如果需要将更多数据传入和传出工作器，应该将数据放在其他位置，例如 Room 数据库。Data 对象的大小上限为 10KB。</p>
<h5 id="标记工作"><a href="#标记工作" class="headerlink" title="标记工作"></a>标记工作</h5><p>  可以通过为任意 <a href="https://developer.android.com/reference/androidx/work/WorkRequest" target="_blank" rel="noopener"><code>WorkRequest</code></a> 对象分配标记字符串，按逻辑对任务进行分组。这样就可以对使用特定标记的所有任务执行操作。</p>
<p>  例如，<a href="https://developer.android.com/reference/androidx/work/WorkManager#cancelAllWorkByTag(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.cancelAllWorkByTag(String)</code></a> 会取消使用特定标记的所有任务，而 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfosByTagLiveData(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfosByTagLiveData(String)</code></a> 会返回 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 和具有该标记的所有任务的状态列表。</p>
<p>  以下代码展示了如何使用 <a href="https://developer.android.com/reference/androidx/work/WorkRequest.Builder#addTag(java.lang.String)" target="_blank" rel="noopener"><code>WorkRequest.Builder.addTag(String)</code></a> 向任务添加“cleanup”标记：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cacheCleanupTask =</span><br><span class="line">        OneTimeWorkRequestBuilder&lt;CacheCleanupWorker&gt;()</span><br><span class="line">    .setConstraints(constraints)</span><br><span class="line">    .addTag(<span class="string">"cleanup"</span>)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<h4 id="观察工作状态"><a href="#观察工作状态" class="headerlink" title="观察工作状态"></a>观察工作状态</h4><h5 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h5><p>在工作的整个生命周期内，它会经历多个不同的 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State" target="_blank" rel="noopener"><code>State</code></a></p>
<ul>
<li>如果有尚未完成的<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/chain-work" target="_blank" rel="noopener">前提性工作</a>，则工作处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#BLOCKED" target="_blank" rel="noopener"><code>BLOCKED</code></a> <code>State</code>。</li>
<li>如果工作能够在满足 <a href="https://developer.android.com/reference/androidx/work/Constraints" target="_blank" rel="noopener"><code>Constraints</code></a> 和时机条件后立即运行，则被视为处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#ENQUEUED" target="_blank" rel="noopener"><code>ENQUEUED</code></a> 状态。</li>
<li>当工作器在活跃地执行时，其处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#RUNNING" target="_blank" rel="noopener"><code>RUNNING</code></a> <code>State</code>。</li>
<li>如果工作器返回 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result#success()" target="_blank" rel="noopener"><code>Result.success()</code></a>，则被视为处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#SUCCEEDED" target="_blank" rel="noopener"><code>SUCCEEDED</code></a> 状态。这是一种终止 <code>State</code>；只有 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" target="_blank" rel="noopener"><code>OneTimeWorkRequest</code></a> 可以进入这种 <code>State</code>。</li>
<li>相反，如果工作器返回 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result#failure()" target="_blank" rel="noopener"><code>Result.failure()</code></a>，则被视为处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#FAILED" target="_blank" rel="noopener"><code>FAILED</code></a> 状态。这也是一个终止 <code>State</code>；只有 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" target="_blank" rel="noopener"><code>OneTimeWorkRequest</code></a> 可以进入这种 <code>State</code>。所有依赖工作也会被标记为 <code>FAILED</code>，并且不会运行。</li>
<li>当您明确<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work" target="_blank" rel="noopener">取消</a>尚未终止的 <code>WorkRequest</code> 时，它会进入 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#CANCELLED" target="_blank" rel="noopener"><code>CANCELLED</code></a> <code>State</code>。所有依赖工作也会被标记为 <code>CANCELLED</code>，并且不会运行。</li>
</ul>
<h5 id="观察工作状态-1"><a href="#观察工作状态-1" class="headerlink" title="观察工作状态"></a>观察工作状态</h5><p>将工作加入队列后，您可以通过 WorkManager 检查其状态。相关信息在 <a href="https://developer.android.com/reference/androidx/work/WorkInfo" target="_blank" rel="noopener"><code>WorkInfo</code></a> 对象中提供，包括工作的 <code>id</code>、标签、当前 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State" target="_blank" rel="noopener"><code>State</code></a> 和任何输出数据。</p>
<p>您通过以下三种方式之一来获取 <code>WorkInfo</code>：</p>
<ul>
<li>对于特定的 <a href="https://developer.android.com/reference/androidx/work/WorkRequest" target="_blank" rel="noopener"><code>WorkRequest</code></a>，您可以利用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfoById(java.util.UUID)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfoById(UUID)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfoByIdLiveData(java.util.UUID)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfoByIdLiveData(UUID)</code></a> 来通过 <code>WorkRequest</code> <code>id</code> 检索其 <code>WorkInfo</code>。</li>
<li>对于指定的<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work#tag" target="_blank" rel="noopener">标记</a>，您可以利用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfosByTag(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfosByTag(String)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfosByTagLiveData(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfosByTagLiveData(String)</code></a> 检索所有匹配的 <code>WorkRequest</code> 的 <code>WorkInfo</code> 对象。</li>
<li>对于<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/unique-work" target="_blank" rel="noopener">唯一工作名称</a>，您可以利用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfosForUniqueWork(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfosForUniqueWork(String)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfosForUniqueWorkLiveData(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.getWorkInfosForUniqueWorkLiveData(String)</code></a> 检索所有匹配的 <code>WorkRequest</code> 的 <code>WorkInfo</code> 对象。</li>
</ul>
<p>利用每个方法的 <a href="https://developer.android.com/topic/libraries/architecture/livedata" target="_blank" rel="noopener"><code>LiveData</code></a> 变量，您可以通过注册监听器来观察 <code>WorkInfo</code> 的变化。例如，如果您想要在某项工作成功完成后向用户显示消息，您可以进行如下设置：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(myContext).getWorkInfoByIdLiveData(uploadWorkRequest.id)</span><br><span class="line">        .observe(lifecycleOwner, Observer &#123; workInfo -&gt;</span><br><span class="line">            <span class="keyword">if</span> (workInfo != <span class="literal">null</span> &amp;&amp; workInfo.state == WorkInfo.State.SUCCEEDED) &#123;</span><br><span class="line">                displayMessage(<span class="string">"Work finished!"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>



<h4 id="观察工作器的中间进度"><a href="#观察工作器的中间进度" class="headerlink" title="观察工作器的中间进度"></a>观察工作器的中间进度</h4><blockquote>
<p>WorkManager <code>2.3.0-alpha01</code> 为设置和观察工作器的中间进度添加了一流支持。如果应用在前台运行时，工作器保持运行状态，也可以使用返回 <a href="https://developer.android.com/reference/androidx/work/WorkInfo" target="_blank" rel="noopener"><code>WorkInfo</code></a> 的 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData" target="_blank" rel="noopener"><code>LiveData</code></a> 的 API 向用户显示此信息。</p>
<p><a href="https://developer.android.com/reference/androidx/work/ListenableWorker" target="_blank" rel="noopener"><code>ListenableWorker</code></a> 现在支持 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#setProgressAsync(androidx.work.Data)" target="_blank" rel="noopener"><code>setProgressAsync()</code></a> API，此类 API 可以保留中间进度。借助这些 API，开发者能够设置可通过界面观察到的中间进度。进度由 <a href="https://developer.android.com/reference/androidx/work/Data" target="_blank" rel="noopener"><code>Data</code></a> 类型表示，这是一个可序列化的属性容器（类似于 <a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced#params" target="_blank" rel="noopener"><code>input</code> 和 <code>output</code></a>，并且受到相同的限制）。</p>
<p>只有在 <code>ListenableWorker</code> 运行时才能观察到和更新进度信息。如果尝试在 <code>ListenableWorker</code> 完成执行后在其中设置进度，则将会被忽略。您还可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfoById(java.util.UUID)" target="_blank" rel="noopener"><code>getWorkInfoBy…()</code> 或 <code>getWorkInfoBy…LiveData()</code></a> 方法来观察进度信息。这两个方法会返回 <a href="https://developer.android.com/reference/androidx/work/WorkInfo" target="_blank" rel="noopener"><code>WorkInfo</code></a> 的实例，后者有一个返回 <code>Data</code> 的新 <a href="https://developer.android.com/reference/androidx/work/WorkInfo#getProgress()" target="_blank" rel="noopener"><code>getProgress()</code></a> 方法。</p>
</blockquote>
<h5 id="更新进度"><a href="#更新进度" class="headerlink" title="更新进度"></a>更新进度</h5><p>对于使用 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker" target="_blank" rel="noopener"><code>ListenableWorker</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/Worker" target="_blank" rel="noopener"><code>Worker</code></a> 的 Java 开发者，<a href="https://developer.android.com/reference/androidx/work/ListenableWorker#setProgressAsync(androidx.work.Data)" target="_blank" rel="noopener"><code>setProgressAsync()</code></a> API 会返回 <code>ListenableFuture&lt;Void&gt;</code>；更新进度是异步过程，因为更新过程包括将进度信息存储在数据库中。在 Kotlin 中，您可以使用 <a href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker" target="_blank" rel="noopener"><code>CoroutineWorker</code></a> 对象的 <a href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker#setprogress" target="_blank" rel="noopener"><code>setProgress()</code></a> 扩展函数来更新进度信息。</p>
<p>此示例展示了一个简单的 <code>ProgressWorker</code>。该 <code>Worker</code> 启动时将进度设置为 0，完成时将进度值更新为 100。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> androidx.work.CoroutineWorker</span><br><span class="line"><span class="keyword">import</span> androidx.work.Data</span><br><span class="line"><span class="keyword">import</span> androidx.work.WorkerParameters</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.delay</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgressWorker</span></span>(context: Context, parameters: WorkerParameters) :</span><br><span class="line">    CoroutineWorker(context, parameters) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> Progress = <span class="string">"Progress"</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> delayDuration = <span class="number">1L</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="keyword">val</span> firstUpdate = workDataOf(Progress to <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> lastUpdate = workDataOf(Progress to <span class="number">100</span>)</span><br><span class="line">        setProgress(firstUpdate)</span><br><span class="line">        delay(delayDuration)</span><br><span class="line">        setProgress(lastUpdate)</span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="观察进度"><a href="#观察进度" class="headerlink" title="观察进度"></a>观察进度</h5><p>观察进度信息也很简单。您可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getWorkInfoById(java.util.UUID)" target="_blank" rel="noopener"><code>getWorkInfoBy…()</code> 或 <code>getWorkInfoBy…LiveData()</code></a> 方法，并引用 <a href="https://developer.android.com/reference/androidx/work/WorkInfo" target="_blank" rel="noopener"><code>WorkInfo</code></a>。</p>
<p>以下是使用 <code>getWorkInfoByIdLiveData</code> API 的示例。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(applicationContext)</span><br><span class="line">    <span class="comment">// requestId is the WorkRequest id</span></span><br><span class="line">    .getWorkInfoByIdLiveData(requestId)</span><br><span class="line">    .observe(observer, Observer &#123; workInfo: WorkInfo? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (workInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> progress = workInfo.progress</span><br><span class="line">                <span class="keyword">val</span> value = progress.getInt(Progress, <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// Do something with progress information</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="将工作链接在一起"><a href="#将工作链接在一起" class="headerlink" title="将工作链接在一起"></a>将工作链接在一起</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager" target="_blank" rel="noopener">WorkManager</a> 创建工作链并为其排队。工作链用于指定多个关联任务并定义这些任务的运行顺序。当您需要以特定的顺序运行多个任务时，这尤其有用。</p>
<p>要创建工作链，您可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#beginWith(androidx.work.OneTimeWorkRequest)" target="_blank" rel="noopener"><code>WorkManager.beginWith(OneTimeWorkRequest)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkManager#beginWith(java.util.List)" target="_blank" rel="noopener"><code>WorkManager.beginWith(List)</code></a>，这会返回 <a href="https://developer.android.com/reference/androidx/work/WorkContinuation" target="_blank" rel="noopener"><code>WorkContinuation</code></a> 实例。</p>
<p>然后，可以通过 <code>WorkContinuation</code> 使用 <a href="https://developer.android.com/reference/androidx/work/WorkContinuation#then(androidx.work.OneTimeWorkRequest)" target="_blank" rel="noopener"><code>WorkContinuation.then(OneTimeWorkRequest)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkContinuation#then(java.util.List)" target="_blank" rel="noopener"><code>WorkContinuation.then(List)</code></a> 来添加从属 <code>OneTimeWorkRequest</code>。</p>
<p>每次调用 <code>WorkContinuation.then(...)</code> 都会返回一个新的 <code>WorkContinuation</code> 实例。如果添加了 <code>OneTimeWorkRequest</code> 的 <code>List</code>，这些请求可能会并行运行。</p>
<p>最后，您可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkContinuation#enqueue()" target="_blank" rel="noopener"><code>WorkContinuation.enqueue()</code></a> 方法为 <code>WorkContinuation</code> 链排队。</p>
<p>让我们看一个示例：某个应用对 3 个不同的图像执行图像滤镜（可能会并行执行），然后将这些图像压缩在一起，再上传它们。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(myContext)</span><br><span class="line">    <span class="comment">// Candidates to run in parallel</span></span><br><span class="line">    .beginWith(listOf(filter1, filter2, filter3))</span><br><span class="line">    <span class="comment">// Dependent work (only runs after all previous work in chain)</span></span><br><span class="line">    .then(compress)</span><br><span class="line">    .then(upload)</span><br><span class="line">    <span class="comment">// Don't forget to enqueue()</span></span><br><span class="line">    .enqueue()</span><br></pre></td></tr></table></figure>

<h5 id="Input-Merger"><a href="#Input-Merger" class="headerlink" title="Input Merger"></a>Input Merger</h5><p>在使用 <code>OneTimeWorkRequest</code> 链时，父级 <code>OneTimeWorkRequest</code> 的输出将作为输入传递给子级。因此在上面的示例中，<code>filter1</code>、<code>filter2</code> 和 <code>filter3</code> 的输出将作为输入传递给 <code>compress</code> 请求。</p>
<p>为了管理来自多个父级 <code>OneTimeWorkRequest</code> 的输入，WorkManager 使用 <a href="https://developer.android.com/reference/androidx/work/InputMerger" target="_blank" rel="noopener"><code>InputMerger</code></a>。</p>
<p>WorkManager 提供两种不同类型的 <code>InputMerger</code>：</p>
<ul>
<li><a href="https://developer.android.com/reference/androidx/work/OverwritingInputMerger" target="_blank" rel="noopener"><code>OverwritingInputMerger</code></a> 会尝试将所有输入中的所有键添加到输出中。如果发生冲突，它会覆盖先前设置的键。</li>
<li><a href="https://developer.android.com/reference/androidx/work/ArrayCreatingInputMerger" target="_blank" rel="noopener"><code>ArrayCreatingInputMerger</code></a> 会尝试合并输入，并在必要时创建数组。</li>
</ul>
<p>对于上面的示例，假设我们要保留所有图像滤镜的输出，则应使用 <code>ArrayCreatingInputMerger</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> compress: OneTimeWorkRequest = OneTimeWorkRequestBuilder&lt;CompressWorker&gt;()</span><br><span class="line">    .setInputMerger(ArrayCreatingInputMerger::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">    .setConstraints(constraints)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<h5 id="链接和工作状态"><a href="#链接和工作状态" class="headerlink" title="链接和工作状态"></a>链接和工作状态</h5><p>创建 <code>OneTimeWorkRequest</code> 链时，需要注意以下几点：</p>
<ul>
<li>从属 <code>OneTimeWorkRequest</code> 仅在其所有父级 <code>OneTimeWorkRequest</code> 都成功完成（即返回 <code>Result.success()</code>）时才会被解除阻塞（变为 <code>ENQUEUED</code> 状态）。</li>
<li>如果有任何父级 <code>OneTimeWorkRequest</code> 失败（返回 <code>Result.failure()</code>），则所有从属 <code>OneTimeWorkRequest</code> 也会被标记为 <code>FAILED</code>。</li>
<li>如果有任何父级 <code>OneTimeWorkRequest</code> 被取消，则所有从属 <code>OneTimeWorkRequest</code> 也会被标记为 <code>CANCELLED</code>。</li>
</ul>
<h4 id="取消和停止工作"><a href="#取消和停止工作" class="headerlink" title="取消和停止工作"></a>取消和停止工作</h4><p>如果您不再需要运行先前加入队列的作业，则可以申请取消。最简单的方法是使用其 <code>id</code> 并调用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#cancelWorkById(java.util.UUID)" target="_blank" rel="noopener"><code>WorkManager.cancelWorkById(UUID)</code></a> 来取消单个 WorkRequest：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.cancelWorkById(workRequest.id)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  在后台，WorkManager 会检查工作的 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State" target="_blank" rel="noopener"><code>State</code></a>。如果工作已经<a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#isFinished()" target="_blank" rel="noopener">完成</a>，则不会发生任何变化。否则，其状态将更改为 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#CANCELLED" target="_blank" rel="noopener"><code>CANCELLED</code></a>，之后就不会运行这个工作。任何<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/chain-work" target="_blank" rel="noopener">依赖于这项工作</a>的 <a href="https://developer.android.com/reference/androidx/work/WorkRequest" target="_blank" rel="noopener"><code>WorkRequests</code></a> 的状态也将变为 <code>CANCELLED</code>。</p>
<p>  此外，如果工作当前的状态为 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State#RUNNING" target="_blank" rel="noopener"><code>RUNNING</code></a>，则工作器也会收到对 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#onStopped()" target="_blank" rel="noopener"><code>ListenableWorker.onStopped()</code></a> 的调用。替换此方法以处理任何可能的清理操作。我们会<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work#stopping" target="_blank" rel="noopener">在下文</a>详细讨论相关内容。</p>
<p>  您也可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#cancelAllWorkByTag(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.cancelAllWorkByTag(String)</code></a> 按标记取消 WorkRequest。请注意，此方法会取消所有具有此标记的工作。此外，您还可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager#cancelUniqueWork(java.lang.String)" target="_blank" rel="noopener"><code>WorkManager.cancelUniqueWork(String)</code></a> 取消具有唯一名称的所有工作。</p>
</blockquote>
<h5 id="停止正在运行的工作器"><a href="#停止正在运行的工作器" class="headerlink" title="停止正在运行的工作器"></a>停止正在运行的工作器</h5><p>WorkManager 停止正在运行的工作器可能有几种不同的原因：</p>
<ul>
<li>您明确要求取消它（例如，通过调用 <code>WorkManager.cancelWorkById(UUID)</code> 取消）。</li>
<li>如果是<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/unique-work" target="_blank" rel="noopener">唯一工作</a>，使用 <a href="https://developer.android.com/reference/androidx/work/ExistingWorkPolicy" target="_blank" rel="noopener"><code>ExistingWorkPolicy</code></a> <a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/' target="_blank" rel="noopener"reference/androidx/work/ExistingWorkPolicy#REPLACE"><code>REPLACE</code></a> 明确地将新的 <code>WorkRequest</code> 加入队列。旧的 <code>WorkRequest</code> 会立即被视为已终止。</li>
<li>您的工作约束已不再得到满足。</li>
<li>系统出于某种原因指示您的应用停止工作。如果超过 10 分钟的执行期限，可能会发生这种情况。系统将工作安排在稍后重试。</li>
</ul>
<p>在这些情况下，您的员工会收到对 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#onStopped()" target="_blank" rel="noopener"><code>ListenableWorker.onStopped()</code></a> 的调用。如果操作系统决定关闭您的应用，您应执行清理工作并以协作方式完成工作器。例如，您应该在此时或者尽早关闭数据库和文件的打开句柄。此外，如果您想要确认系统是否已经停止您的应用，都可以调用 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#isStopped()" target="_blank" rel="noopener"><code>ListenableWorker.isStopped()</code></a>。即使您通过在调用 <code>onStopped()</code> 后返回 <a href="https://developer.android.com/reference/androidx/work/Result" target="_blank" rel="noopener"><code>Result</code></a> 来指示工作已完成，WorkManager 都会忽略该 <code>Result</code>，因为工作器已经被视为停止。</p>
<h4 id="处理重复性工作"><a href="#处理重复性工作" class="headerlink" title="处理重复性工作"></a>处理重复性工作</h4><blockquote>
<p>应用场景：</p>
<p>应用有时可能需要定期运行某些任务。例如，您可能要定期备份数据、下载应用中的新鲜内容，或者上传日志到服务器。将 <a href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest" target="_blank" rel="noopener"><code>PeriodicWorkRequest</code></a> 用于这种需要定期执行的任务。</p>
</blockquote>
<p><code>PeriodicWorkRequest</code> 无法<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/chain-work" target="_blank" rel="noopener">链接</a>。如果您的任务需要链接任务，请考虑 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" target="_blank" rel="noopener"><code>OneTimeWorkRequest</code></a>。</p>
<p>您可以按照以下方式创建 PeriodicWorkRequest：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">        .setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> saveRequest =</span><br><span class="line">PeriodicWorkRequestBuilder&lt;SaveImageToFileWorker&gt;(<span class="number">1</span>, TimeUnit.HOURS)</span><br><span class="line">    .setConstraints(constraints)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(myContext)</span><br><span class="line">    .enqueue(saveRequest)</span><br></pre></td></tr></table></figure>

<p>示例中展示了一个重复间隔为一小时的定期工作请求。</p>
<p>重复间隔定义为重复之间的最短时间。工作器的确切执行时间取决于您在工作请求中使用的约束，也取决于系统进行的优化。</p>
<p>在示例中，PeriodicWorkRequest 还要求设备接通电源。在这种情况下，即使过了定义的一小时重复间隔，PeriodicWorkRequest 也将在设备接通电源时运行。</p>
<p><strong>注意</strong>：可以定义的最短重复间隔是 15 分钟（与 <a href="https://developer.android.com/reference/android/app/job/JobScheduler" target="_blank" rel="noopener">JobScheduler API</a> 相同）。</p>
<h4 id="处理唯一作业"><a href="#处理唯一作业" class="headerlink" title="处理唯一作业"></a>处理唯一作业</h4><blockquote>
<p>唯一工作是一个概念性非常强的术语，可确保一次只有一个具有特定名称的工作链。与 <code>id</code> 不同的是，唯一名称是人类可读的，由开发者指定，而不是由 WorkManager 自动生成。与<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work#tag" target="_blank" rel="noopener">标记</a>不同，唯一名称仅与“一个”工作链关联。</p>
</blockquote>
<p>您可以通过调用 [<code>WorkManager.enqueueUniqueWork(String, ExistingWorkPolicy, OneTimeWorkRequest)</code>](<a href="https://developer.android.com/reference/androidx/work/WorkManager#enqueueUniqueWork" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/work/WorkManager#enqueueUniqueWork</a>(java.lang.String, androidx.work.ExistingWorkPolicy, androidx.work.OneTimeWorkRequest)) 或 [<code>WorkManager.enqueueUniquePeriodicWork(String, ExistingPeriodicWorkPolicy, PeriodicWorkRequest)</code>](<a href="https://developer.android.com/reference/androidx/work/WorkManager#enqueueUniquePeriodicWork" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/work/WorkManager#enqueueUniquePeriodicWork</a>(java.lang.String, androidx.work.ExistingPeriodicWorkPolicy, androidx.work.PeriodicWorkRequest)) 创建唯一工作序列。第一个参数是唯一名称 - 这是我们用来标识 <code>WorkRequest</code> 的键。第二个参数是冲突解决策略，它指定了如果已经存在一个具有该唯一名称的未完成工作链，WorkManager 应该如何处理：</p>
<ul>
<li>取消现有工作链，并将其 <a href="https://developer.android.com/reference/androidx/work/ExistingWorkPolicy#REPLACE" target="_blank" rel="noopener"><code>REPLACE</code></a> 为新工作链。</li>
<li><a href="https://developer.android.com/reference/androidx/work/ExistingWorkPolicy#KEEP" target="_blank" rel="noopener"><code>KEEP</code></a> 现有序列并忽略您的新请求。</li>
<li>将新序列 <a href="https://developer.android.com/reference/androidx/work/ExistingWorkPolicy#APPEND" target="_blank" rel="noopener"><code>APPEND</code></a> 到现有序列，在现有序列的最后一个任务完成后运行新序列的第一个任务。您不能将 <code>APPEND</code> 与 <code>PeriodicWorkRequest</code> 一起使用。</li>
</ul>
<p>当您有不能够多次排队的任务时，唯一工作将非常有用。例如，如果您的应用需要将其数据同步到网络，您可能需要对一个名为“sync”的序列进行排队，并指定当已经存在具有该名称的序列时，应该忽略新的任务。</p>
<p>当您需要逐步构建一个长任务链时，也可以利用唯一工作序列。例如，照片编辑应用可能允许用户撤消一长串操作。其中的每一项撤消操作可能都需要一些时间来完成，但必须按正确的顺序执行。在这种情况下，应用可以创建一个“撤消”链，并根据需要将每个撤消操作附加到该链上。</p>
<p>最后，如果您需要创建一个唯一工作链，可以使用 [<code>WorkManager.beginUniqueWork(String, ExistingWorkPolicy, OneTimeWorkRequest)</code>](<a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=en#beginUniqueWork" target="_blank" rel="noopener">https://developer.android.com/reference/androidx/work/WorkManager?hl=en#beginUniqueWork</a>(java.lang.String, androidx.work.ExistingWorkPolicy, androidx.work.OneTimeWorkRequest)) 代替 <code>beginWith()</code>。</p>
<h4 id="测试Worker实现"><a href="#测试Worker实现" class="headerlink" title="测试Worker实现"></a>测试Worker实现</h4><blockquote>
<p>从2.1.0版本开始，WorkerManager提供了APIs，用来测试Woker，ListenableWorker，以及ListenableWorker的子类（CoroutineWorker / RxWorker / Worker）</p>
<p>在V2.1.0之前，如果要测试Workers，需要使用WorkManagerTestInitHelper去初始化WorkerManager。通过V2.1.0，不需要WorkerManagerTestInitHelper，就可以测试Woker的实现。</p>
</blockquote>
<h5 id="测试ListenableWorker及其子类"><a href="#测试ListenableWorker及其子类" class="headerlink" title="测试ListenableWorker及其子类"></a>测试ListenableWorker及其子类</h5><p>测试ListenableWorker或者它的子类（CoroutineWorker / RxWorker），使用TestListenableWorkerBuilder。这个构建器可以帮助构建ListenableWorker的实例，用于测试Worker的业务逻辑。</p>
<p>比如，假设我们需要测试一个如下的CoroutineWorker：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepWorker</span></span>(context: Context, parameters: WorkerParameters) :</span><br><span class="line">    CoroutineWorker(context, parameters) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        delay(<span class="number">1000</span>) <span class="comment">// milliseconds</span></span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了测试SleepWorker，我们首先通过TestListenableWorkerBuilder创建Worker的实例。这个构建器也可以用来设置标签、inputData、runAttemptCount等等。具体请参考 <a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/reference/androidx/work/testing/TestListenableWorkerBuilder" target="_blank" rel="noopener"><code>TestListenableWorker</code></a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(AndroidJUnit4::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepWorkerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> context: Context</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        context = ApplicationProvider.getApplicationContext()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testSleepWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Kotlin code can use the TestListenableWorkerBuilder extension to</span></span><br><span class="line">        <span class="comment">// build the ListenableWorker</span></span><br><span class="line">        <span class="keyword">val</span> worker = TestListenableWorkerBuilder&lt;SleepWorker&gt;(context).build()</span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            <span class="keyword">val</span> result = worker.doWork()</span><br><span class="line">            assertThat(result, `<span class="keyword">is</span>`(Result.success()))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="测试Workers"><a href="#测试Workers" class="headerlink" title="测试Workers"></a>测试Workers</h5><p>假设我们有一个Worker，如下所示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepWorker</span></span>(context: Context, parameters: WorkerParameters) :</span><br><span class="line">    Worker(context, parameters) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> SLEEP_DURATION = <span class="string">"SLEEP_DURATION"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="comment">// Sleep on a background thread.</span></span><br><span class="line">        <span class="keyword">val</span> sleepDuration = inputData.getLong(SLEEP_DURATION, <span class="number">1000</span>)</span><br><span class="line">        Thread.sleep(sleepDuration)</span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了测试这个Worker，现在我们可以使用TestWorkerBuilder。TestWorkerBuilder和TestListenableWorkerBuilder的主要区别在于，TestWorkerBuilder允许你指定Executor来运行Worker</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kotlin code can use the TestWorkerBuilder extension to</span></span><br><span class="line"><span class="comment">// build the Worker</span></span><br><span class="line"><span class="meta">@RunWith(AndroidJUnit4::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepWorkerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> context: Context</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> executor: Executor</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        context = ApplicationProvider.getApplicationContext()</span><br><span class="line">        executor = Executors.newSingleThreadExecutor()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testSleepWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> worker = TestWorkerBuilder&lt;SleepWorker&gt;(</span><br><span class="line">            context = context,</span><br><span class="line">            executor = executor,</span><br><span class="line">            inputData = workDataOf(<span class="string">"SLEEP_DURATION"</span> to <span class="number">10000L</span>)</span><br><span class="line">        ).build()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> result = worker.doWork()</span><br><span class="line">        assertThat(result, `<span class="keyword">is</span>`(Result.success()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用WorkManager进行集成测试"><a href="#使用WorkManager进行集成测试" class="headerlink" title="使用WorkManager进行集成测试"></a>使用WorkManager进行集成测试</h4><h5 id="介绍和设置"><a href="#介绍和设置" class="headerlink" title="介绍和设置"></a>介绍和设置</h5><p>  WorkManager提供了一个work-testing神器，可以帮助Wokers进行Android Instrumentation测试的单元测试。</p>
<p>  为了使用work-testing神器，需要在build.gradle添加依赖</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// optional - Test helpers</span></span><br><span class="line">       androidTestImplementation <span class="string">"androidx.work:work-testing:$work_version"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：从2.1.0开始，WorkManager提供了新的TestWorkerBuilder和TestListenableWorkerBuilder类，这两个类可以让你在不需要用WorkManagerTestInitHelper初始化WorkManager的情况下，就可以测试Worker中的业务逻辑。本页中的材料对于你需要在Worker实现之外进行Worker测试时仍然很有用。</p>
</blockquote>
<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>  测试模式下，work-testing提供了WorkerManager的特殊实现，通过WorkerManagerTestInitHelper初始化。</p>
<p>  work-testing还提供了一个SynchronousExecutor，它让我们可以更容易地以同步的方式编写测试，而不需要处理多个线程、锁或锁的问题。</p>
<p>  通过下面的例子，来展示一起使用这些类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(AndroidJUnit4::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicInstrumentationTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> context = InstrumentationRegistry.getTargetContext()</span><br><span class="line">        <span class="keyword">val</span> config = Configuration.Builder()</span><br><span class="line">            <span class="comment">// Set log level to Log.DEBUG to make it easier to debug</span></span><br><span class="line">            .setMinimumLoggingLevel(Log.DEBUG)</span><br><span class="line">            <span class="comment">// Use a SynchronousExecutor here to make it easier to write tests</span></span><br><span class="line">            .setExecutor(SynchronousExecutor())</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize WorkManager for instrumentation tests.</span></span><br><span class="line">        WorkManagerTestInitHelper.initializeTestWorkManager(context, config)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="结构化测试"><a href="#结构化测试" class="headerlink" title="结构化测试"></a>结构化测试</h5><p>假设我们有一个EchoWorker，期望有一些输入数据，并简单地将其复制（回传）到其输出数据</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoWorker</span></span>(context: Context, parameters: WorkerParameters)</span><br><span class="line">   : Worker(context, parameters) &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">when</span>(inputData.size()) &#123;</span><br><span class="line">           <span class="number">0</span> -&gt; Result.failure()</span><br><span class="line">           <span class="keyword">else</span> -&gt; Result.success(inputData)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="基本测试"><a href="#基本测试" class="headerlink" title="基本测试"></a>基本测试</h6><p>​    下面是一个测试EchoWorker的Android Instrumentation测试。这里的要点是，在测试模式下测试EchoWorker与实际应用中使用EchoWorker的方式非常相似。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Throws(Exception::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testSimpleEchoWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Define input data</span></span><br><span class="line">    <span class="keyword">val</span> input = workDataOf(KEY_1 to <span class="number">1</span>, KEY_2 to <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create request</span></span><br><span class="line">    <span class="keyword">val</span> request = OneTimeWorkRequestBuilder&lt;EchoWorker&gt;()</span><br><span class="line">        .setInputData(input)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> workManager = WorkManager.getInstance(applicationContext)</span><br><span class="line">    <span class="comment">// Enqueue and wait for result. This also runs the Worker synchronously</span></span><br><span class="line">    <span class="comment">// because we are using a SynchronousExecutor.</span></span><br><span class="line">    workManager.enqueue(request).result.<span class="keyword">get</span>()</span><br><span class="line">    <span class="comment">// Get WorkInfo and outputData</span></span><br><span class="line">    <span class="keyword">val</span> workInfo = workManager.getWorkInfoById(request.id).<span class="keyword">get</span>()</span><br><span class="line">    <span class="keyword">val</span> outputData = workInfo.outputData</span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    assertThat(workInfo.state, `<span class="keyword">is</span>`(WorkInfo.State.SUCCEEDED))</span><br><span class="line">    assertThat(outputData, `<span class="keyword">is</span>`(input))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当EchoWorker没有获取到任何输入数据的时候，我们希望返回的Result是Result.failure()</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Throws(Exception::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testEchoWorkerNoInput</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// Create request</span></span><br><span class="line">   <span class="keyword">val</span> request = OneTimeWorkRequestBuilder&lt;EchoWorker&gt;()</span><br><span class="line">       .build()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> workManager = WorkManager.getInstance(applicationContext)</span><br><span class="line">   <span class="comment">// Enqueue and wait for result. This also runs the Worker synchronously</span></span><br><span class="line">   <span class="comment">// because we are using a SynchronousExecutor.</span></span><br><span class="line">   workManager.enqueue(request).result.<span class="keyword">get</span>()</span><br><span class="line">   <span class="comment">// Get WorkInfo</span></span><br><span class="line">   <span class="keyword">val</span> workInfo = workManager.getWorkInfoById(request.id).<span class="keyword">get</span>()</span><br><span class="line">   <span class="comment">// Assert</span></span><br><span class="line">   assertThat(workInfo.state, `<span class="keyword">is</span>`(WorkInfo.State.FAILED))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="模拟约束、延迟和周期性工作"><a href="#模拟约束、延迟和周期性工作" class="headerlink" title="模拟约束、延迟和周期性工作"></a>模拟约束、延迟和周期性工作</h5><blockquote>
<p>WorkManagerTestInitHelper为你提供了一个TestDriver的实例，它可以用来模拟初始化延迟、ListenableWorkers满足约束的条件，以及PeriodicWorkRequests的时间间隔。</p>
</blockquote>
<h6 id="测试初始化延迟"><a href="#测试初始化延迟" class="headerlink" title="测试初始化延迟"></a>测试初始化延迟</h6><p>Worker可以有初始延迟。要测试EchoWorker的初始延迟，相比于在测试中等待初始延迟，我们更倾向于使用TestDriver将WorkRequests的初始延迟标记为满足。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Throws(Exception::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testWithInitialDelay</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Define input data</span></span><br><span class="line">    <span class="keyword">val</span> input = workDataOf(KEY_1 to <span class="number">1</span>, KEY_2 to <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create request</span></span><br><span class="line">    <span class="keyword">val</span> request = OneTimeWorkRequestBuilder&lt;EchoWorker&gt;()</span><br><span class="line">        .setInputData(input)</span><br><span class="line">        .setInitialDelay(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> workManager = WorkManager.getInstance(getApplicationContext())</span><br><span class="line">    <span class="keyword">val</span> testDriver = WorkManagerTestInitHelper.getTestDriver()</span><br><span class="line">    <span class="comment">// Enqueue and wait for result.</span></span><br><span class="line">    workManager.enqueue(request).result.<span class="keyword">get</span>()</span><br><span class="line">    testDriver.setInitialDelayMet(request.id)</span><br><span class="line">    <span class="comment">// Get WorkInfo and outputData</span></span><br><span class="line">    <span class="keyword">val</span> workInfo = workManager.getWorkInfoById(request.id).<span class="keyword">get</span>()</span><br><span class="line">    <span class="keyword">val</span> outputData = workInfo.outputData</span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    assertThat(workInfo.state, `<span class="keyword">is</span>`(WorkInfo.State.SUCCEEDED))</span><br><span class="line">    assertThat(outputData, `<span class="keyword">is</span>`(input))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="测试约束"><a href="#测试约束" class="headerlink" title="测试约束"></a>测试约束</h6><p>TestDriver通过setAllConstraintsMet方法，可以标记约束条件被满足。</p>
<p>下面是一个关于如何用约束来测试Worker的例子。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Throws(Exception::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testWithConstraints</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Define input data</span></span><br><span class="line">    <span class="keyword">val</span> input = workDataOf(KEY_1 to <span class="number">1</span>, KEY_2 to <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">        .setRequiredNetworkType(NetworkType.CONNECTED)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create request</span></span><br><span class="line">    <span class="keyword">val</span> request = OneTimeWorkRequestBuilder&lt;EchoWorker&gt;()</span><br><span class="line">        .setInputData(input)</span><br><span class="line">        .setConstraints(constraints)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> workManager = WorkManager.getInstance(myContext)</span><br><span class="line">    <span class="keyword">val</span> testDriver = WorkManagerTestInitHelper.getTestDriver()</span><br><span class="line">    <span class="comment">// Enqueue and wait for result.</span></span><br><span class="line">    workManager.enqueue(request).result.<span class="keyword">get</span>()</span><br><span class="line">    testDriver.setAllConstraintsMet(request.id)</span><br><span class="line">    <span class="comment">// Get WorkInfo and outputData</span></span><br><span class="line">    <span class="keyword">val</span> workInfo = workManager.getWorkInfoById(request.id).<span class="keyword">get</span>()</span><br><span class="line">    <span class="keyword">val</span> outputData = workInfo.outputData</span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    assertThat(workInfo.state, `<span class="keyword">is</span>`(WorkInfo.State.SUCCEEDED))</span><br><span class="line">    assertThat(outputData, `<span class="keyword">is</span>`(input))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="测试周期性工作"><a href="#测试周期性工作" class="headerlink" title="测试周期性工作"></a>测试周期性工作</h6><p>TestDriver还公开了一个setPeriodDelayMet，它可以用来表示一个间隔已经完成。</p>
<p>下面是一个使用setPeriodDelayMet的例子。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Throws(Exception::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testPeriodicWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Define input data</span></span><br><span class="line">    <span class="keyword">val</span> input = workDataOf(KEY_1 to <span class="number">1</span>, KEY_2 to <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create request</span></span><br><span class="line">    <span class="keyword">val</span> request = PeriodicWorkRequestBuilder&lt;EchoWorker&gt;(<span class="number">15</span>, MINUTES)</span><br><span class="line">        .setInputData(input)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> workManager = WorkManager.getInstance(myContext)</span><br><span class="line">    <span class="keyword">val</span> testDriver = WorkManagerTestInitHelper.getTestDriver()</span><br><span class="line">    <span class="comment">// Enqueue and wait for result.</span></span><br><span class="line">    workManager.enqueue(request).result.<span class="keyword">get</span>()</span><br><span class="line">    <span class="comment">// Tells the testing framework the period delay is met</span></span><br><span class="line">    testDriver.setPeriodDelayMet(request.id)</span><br><span class="line">    <span class="comment">// Get WorkInfo and outputData</span></span><br><span class="line">    <span class="keyword">val</span> workInfo = workManager.getWorkInfoById(request.id).<span class="keyword">get</span>()</span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    assertThat(workInfo.state, `<span class="keyword">is</span>`(WorkInfo.State.ENQUEUED))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调试WorkManager"><a href="#调试WorkManager" class="headerlink" title="调试WorkManager"></a>调试WorkManager</h4><h3 id="高级概念"><a href="#高级概念" class="headerlink" title="高级概念"></a>高级概念</h3><h4 id="配置和初始化"><a href="#配置和初始化" class="headerlink" title="配置和初始化"></a>配置和初始化</h4><blockquote>
<p>默认情况下，当您的应用启动时，WorkManager 使用适合大多数应用的合理选项自动进行配置。如果您需要进一步控制 WorkManager 管理和调度工作的方式，可以通过自己初始化 WorkManager 自定义 WorkManager 配置。</p>
</blockquote>
<h5 id="WorkManager-2-1-0及更高版本"><a href="#WorkManager-2-1-0及更高版本" class="headerlink" title="WorkManager 2.1.0及更高版本"></a>WorkManager 2.1.0及更高版本</h5><blockquote>
<p>WorkManager 2.1.0 有多种配置 WorkManager 的方式。为 WorkManager 提供自定义初始化的最灵活方式是使用 WorkManager 2.1.0 及更高版本中提供的<a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/custom-configuration#on-demand" target="_blank" rel="noopener"><em>按需初始化</em></a>。</p>
</blockquote>
<h6 id="按需初始化"><a href="#按需初始化" class="headerlink" title="按需初始化"></a>按需初始化</h6><p>通过按需初始化，您可以仅在需要 WorkManager 时创建该组件，而不必每次应用启动时都创建。这样做可将 WorkManager 从关键启动路径中移出，从而提高应用启动性能。</p>
<h6 id="移除默认初始化程序"><a href="#移除默认初始化程序" class="headerlink" title="移除默认初始化程序"></a>移除默认初始化程序</h6><p>要提供自己的配置，必须先移除默认初始化程序。为此，请使用合并规则 <code>tools:node=&quot;remove&quot;</code> 更新 <a href="https://developer.android.com/guide/topics/manifest/manifest-intro" target="_blank" rel="noopener"><code>AndroidManifest.xml</code></a>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"androidx.work.impl.WorkManagerInitializer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.workmanager-init"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:node</span>=<span class="string">"remove"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>要详细了解如何在清单中使用合并规则，请参阅有关<a href="https://developer.android.com/studio/build/manifest-merge" target="_blank" rel="noopener">合并多个清单文件</a>的文档。</p>
</blockquote>
<h6 id="实现Configration-Provider"><a href="#实现Configration-Provider" class="headerlink" title="实现Configration.Provider"></a>实现Configration.Provider</h6><p>让您的 <code>Application</code> 类实现 <a href="https://developer.android.com/reference/androidx/work/Configuration.Provider" target="_blank" rel="noopener"><code>Configuration.Provider</code></a> 接口，并提供您自己的 <a href="https://developer.android.com/reference/androidx/work/Configuration.Provider#getWorkManagerConfiguration()" target="_blank" rel="noopener"><code>Configuration.Provider.getWorkManagerConfiguration()</code></a> 实现。</p>
<p>当您需要使用 WorkManager 时，请确保调用方法 <a href="https://developer.android.com/reference/androidx/work/WorkManager#getInstance(android.content.Context)" target="_blank" rel="noopener"><code>WorkManager.getInstance(Context)</code></a>。WorkManager 调用应用的自定义 <code>getWorkManagerConfiguration()</code> 方法来发现其 <code>Configuration</code>。（您无需自己调用 <code>WorkManager.initialize()</code>。）</p>
<p><strong>注意</strong>：如果您在 WorkManager 初始化之前调用已弃用的无参数 <code>WorkManager.getInstance()</code> 方法，该方法将抛出异常。您应始终使用 <code>WorkManager.getInstance(Context)</code> 方法，即使您不自定义 WorkManager。</p>
<p>以下示例展示了自定义 <code>getWorkManagerConfiguration()</code> 实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myApplication</span></span>() : Application(), Configuration.Provider &#123;</span><br><span class="line">     <span class="keyword">override</span> getWorkManagerConfiguration() =</span><br><span class="line">           Configuration.Builder()</span><br><span class="line">                .setMinimumLoggingLevel(android.util.Log.INFO)</span><br><span class="line">                .build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WorkManager-2-0-1及更早版本"><a href="#WorkManager-2-0-1及更早版本" class="headerlink" title="WorkManager 2.0.1及更早版本"></a>WorkManager 2.0.1及更早版本</h5><h6 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h6><blockquote>
<p>当您的应用启动时，WorkManager 使用自定义 <code>ContentProvider</code> 进行初始化。此代码位于内部类 <code>androidx.work.impl.WorkManagerInitializer</code> 中，并使用默认 <a href="https://developer.android.com/reference/androidx/work/Configuration" target="_blank" rel="noopener"><code>Configuration</code></a>。自动使用默认初始化程序（除非<a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/custom-configuration#remove-default" target="_blank" rel="noopener">明确停用它</a>）。默认初始化程序适合大多数应用。</p>
</blockquote>
<h6 id="自定义初始化"><a href="#自定义初始化" class="headerlink" title="自定义初始化"></a>自定义初始化</h6><p>如果您想控制初始化进程，则必须<a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/custom-configuration#remove-default" target="_blank" rel="noopener">停用默认初始化程序</a>，然后定义您自己的自定义配置。</p>
<p>移除默认初始化程序后，可以手动初始化 WorkManager：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// provide custom configuration</span></span><br><span class="line"><span class="keyword">val</span> myConfig = Configuration.Builder()</span><br><span class="line">    .setMinimumLoggingLevel(android.util.Log.INFO)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize WorkManager</span></span><br><span class="line">WorkManager.initialize(<span class="keyword">this</span>, myConfig)</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.android.com/reference/androidx/work/WorkManager" target="_blank" rel="noopener"><code>WorkManager</code></a> 单例。确保初始化在 <a href="https://developer.android.com/reference/android/app/Application#onCreate()" target="_blank" rel="noopener"><code>Application.onCreate()</code></a> 或 <a href="https://developer.android.com/reference/android/content/ContentProvider#onCreate()" target="_blank" rel="noopener"><code>ContentProvider.onCreate()</code></a> 中运行。</p>
<p>有关可用自定义的完整列表，请参阅 <a href="https://developer.android.com/reference/androidx/work/Configuration.Builder" target="_blank" rel="noopener"><code>Configuration.Builder()</code></a> 参考文档。</p>
<h4 id="WorkManager中的线程处理"><a href="#WorkManager中的线程处理" class="headerlink" title="WorkManager中的线程处理"></a>WorkManager中的线程处理</h4><h5 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h5><p>WorkManager 提供了四种不同类型的工作基元：</p>
<ul>
<li><a href="https://developer.android.com/reference/androidx/work/Worker" target="_blank" rel="noopener"><code>Worker</code></a> 是最简单的实现，前面几节已经有所介绍。WorkManager 会在后台线程上自动运行它（您可以将它替换掉）。请参阅<a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/worker" target="_blank" rel="noopener">工作器中的线程处理</a>，详细了解 <code>Worker</code> 中的线程处理。</li>
<li>建议 Kotlin 用户实现 <a href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker" target="_blank" rel="noopener"><code>CoroutineWorker</code></a>。<code>CoroutineWorker</code> 针对后台工作公开挂起函数。默认情况下，它们运行默认的 <code>Dispatcher</code>，您可以对其进行自定义。请参阅 <a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/coroutineworker" target="_blank" rel="noopener">CorventineWorker 中的线程处理</a>，详细了解 <code>CoroutineWorker</code> 中的线程处理。</li>
<li>建议 RxJava2 用户实现 <a href="https://developer.android.com/reference/androidx/work/RxWorker" target="_blank" rel="noopener"><code>RxWorker</code></a>。如果您有很多现有异步代码是用 RxJava 建模的，则应使用 RxWirkers。与所有 RxJava2 概念一样，您可以自由选择所需的线程处理策略。请参阅 <a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/rxworker" target="_blank" rel="noopener">RxWorker 中的线程处理</a>，详细了解 <code>RxWorker</code> 中的线程处理。</li>
<li><a href="https://developer.android.com/reference/androidx/work/ListenableWorker" target="_blank" rel="noopener"><code>ListenableWorker</code></a> 是 <code>Worker</code>、<code>CoroutineWorker</code> 和 <code>RxWorker</code> 的基类。该类专为需要与基于回调的异步 API（例如 <code>FusedLocationProviderClient</code>）进行交互并且不使用 RxJava2 的 Java 开发者而设计。请参阅 <a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/listenableworker" target="_blank" rel="noopener">ListenableWorker 中的线程处理</a>，详细了解 <code>ListenableWorker</code> 中的线程处理。</li>
</ul>
<h5 id="用Worker处理线程"><a href="#用Worker处理线程" class="headerlink" title="用Worker处理线程"></a>用Worker处理线程</h5><p>​    当您使用 <a href="https://developer.android.com/reference/androidx/work/Worker" target="_blank" rel="noopener"><code>Worker</code></a> 时，WorkManager 会自动在后台线程中调用 <a href="https://developer.android.com/reference/androidx/work/Worker#doWork()" target="_blank" rel="noopener"><code>Worker.doWork()</code></a>。该后台线程来自于 WorkManager 的 <a href="https://developer.android.com/reference/androidx/work/Configuration" target="_blank" rel="noopener"><code>Configuration</code></a> 中指定的 <code>Executor</code>。</p>
<p>​    默认情况下，WorkManager 会为您设置 <code>Executor</code>，但您也可以自己进行自定义。</p>
<p>​    例如，您可以在应用中共享现有的后台 <code>Executor</code>，也可以创建单线程 <code>Executor</code> 以确保所有后台工作都按顺序执行，甚至可以指定一个具有不同线程数的 <code>ThreadPool</code>。</p>
<p>​    要自定义 <code>Executor</code>，请确保您已启用 <a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/custom-configuration" target="_blank" rel="noopener">WorkManager 的手动初始化</a>。在配置 WorkManager 时，您可以按以下方式指定 <code>Executor</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.initialize(</span><br><span class="line">    context,</span><br><span class="line">    Configuration.Builder()</span><br><span class="line">        .setExecutor(Executors.newFixedThreadPool(<span class="number">8</span>))</span><br><span class="line">        .build())</span><br></pre></td></tr></table></figure>

<p>下面是一个简单的工作器示例，它按顺序下载某些网站的内容：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadWorker</span></span>(context: Context, params: WorkerParameters) : Worker(context, params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: ListenableWorker.Result &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">99</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                downloadSynchronously(<span class="string">"https://www.google.com"</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">return</span> ListenableWorker.Result.failure()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ListenableWorker.Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，<a href="https://developer.android.com/reference/androidx/work/Worker#doWork()" target="_blank" rel="noopener"><code>Worker.doWork()</code></a> 是同步调用 - 您将会以阻塞方式完成整个后台工作，并在方法退出时完成工作。如果您在 <code>doWork()</code> 中调用异步 API 并返回 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result" target="_blank" rel="noopener"><code>Result</code></a>，则回调可能无法正常运行。如果您遇到这种情况，请考虑使用 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker" target="_blank" rel="noopener"><code>ListenableWorker</code></a>（请参阅<a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/listenableworker" target="_blank" rel="noopener">在 ListenableWorker 中进行线程处理</a>）。</p>
</blockquote>
<p>当前正在运行的 <code>Worker</code> <a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work" target="_blank" rel="noopener">因为任何原因而停止</a>时，它会收到对 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#onStopped()" target="_blank" rel="noopener"><code>Worker.onStopped()</code></a> 的调用。替换此方法或在代码的检查点处调用 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#isStopped()" target="_blank" rel="noopener"><code>Worker.isStopped()</code></a>，并在必要时释放资源。当上述示例中的 <code>Worker</code> 被停止时，下载项目可能才下载了一半，并且会继续下载，即使已经被停止也不受影响。要优化此行为，您可以执行以下操作：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadWorker</span></span>(context: Context, params: WorkerParameters) : Worker(context, params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: ListenableWorker.Result &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">99</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isStopped) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                downloadSynchronously(<span class="string">"https://www.google.com"</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">return</span> ListenableWorker.Result.failure()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ListenableWorker.Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Worker</code> 停止后，从 <code>Worker.doWork()</code> 返回什么已不重要；<code>Result</code> 将被忽略。</p>
<h5 id="用CoroutineWorker处理线程"><a href="#用CoroutineWorker处理线程" class="headerlink" title="用CoroutineWorker处理线程"></a>用CoroutineWorker处理线程</h5><p>对于 Kotlin 用户，WorkManager 为<a href="https://kotlinlang.org/docs/reference/coroutines-overview.html" target="_blank" rel="noopener">协程</a>提供了一流的支持。要开始使用，请将 <a href="https://developer.android.com/jetpack/androidx/releases/work#declaring_dependencies" target="_blank" rel="noopener"><code>work-runtime-ktx</code> 包含到您的 gradle 文件中</a>。不要扩展 <a href="https://developer.android.com/reference/androidx/work/Worker" target="_blank" rel="noopener"><code>Worker</code></a>，而应扩展 <a href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker" target="_blank" rel="noopener"><code>CoroutineWorker</code></a>，后者使用的 API 略有不同。例如，如果要构建简单的 <code>CoroutineWorker</code> 来执行某些网络操作，则需要执行以下操作：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineDownloadWorker</span></span>(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result = coroutineScope &#123;</span><br><span class="line">        <span class="keyword">val</span> jobs = (<span class="number">0</span> until <span class="number">100</span>).map &#123;</span><br><span class="line">            async &#123;</span><br><span class="line">                downloadSynchronously(<span class="string">"https://www.google.com"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// awaitAll will throw an exception if a download fails, which CoroutineWorker will treat as a failure</span></span><br><span class="line">        jobs.awaitAll()</span><br><span class="line">        Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，<a href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker#doWork()" target="_blank" rel="noopener"><code>CoroutineWorker.doWork()</code></a> 是一个“挂起”函数。不同于 <code>Worker</code>，此代码不会在 <a href="https://developer.android.com/reference/androidx/work/Configuration" target="_blank" rel="noopener"><code>Configuration</code></a> 中指定的 <code>Executor</code> 上运行，而是默认为 <code>Dispatchers.Default</code>。您可以提供自己的 <code>CoroutineContext</code> 来自定义这个行为。在上面的示例中，您可能希望在 <code>Dispatchers.IO</code> 上完成此操作，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineDownloadWorker</span></span>(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext = Dispatchers.IO</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result = coroutineScope &#123;</span><br><span class="line">        <span class="keyword">val</span> jobs = (<span class="number">0</span> until <span class="number">100</span>).map &#123;</span><br><span class="line">            async &#123;</span><br><span class="line">                downloadSynchronously(<span class="string">"https://www.google.com"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// awaitAll will throw an exception if a download fails, which CoroutineWorker will treat as a failure</span></span><br><span class="line">        jobs.awaitAll()</span><br><span class="line">        Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CoroutineWorker</code> 通过取消协程并传播取消信号来自动处理停工情况。您无需执行任何特殊操作来处理<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work" target="_blank" rel="noopener">停工情况</a>。</p>
<h5 id="用RxWorker处理线程"><a href="#用RxWorker处理线程" class="headerlink" title="用RxWorker处理线程"></a>用RxWorker处理线程</h5><p>我们提供了 WorkManager 与 RxJava2 之间的互操作性。要开始使用这种互操作性，除了 <a href="https://developer.android.com/jetpack/androidx/releases/work#declaring_dependencies" target="_blank" rel="noopener"><code>work-runtime</code>，还应将 <code>work-rxjava2</code></a> 包含到 gradle 文件中。然后，您应该扩展 <code>RxWorker</code>，而不是扩展 <code>Worker</code>。最后替换 <a href="https://developer.android.com/reference/androidx/work/RxWorker#createWork()" target="_blank" rel="noopener"><code>RxWorker.createWork()</code></a> 方法以返回 <code>Single&lt;Result&gt;</code>，用于表示您执行的 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result" target="_blank" rel="noopener"><code>Result</code></a>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxDownloadWorker</span> <span class="keyword">extends</span> <span class="title">RxWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RxDownloadWorker</span><span class="params">(Context context, WorkerParameters params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Single&lt;Result&gt; <span class="title">createWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.range(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">            .flatMap &#123; download(<span class="string">"https://www.google.com"</span>) &#125;</span><br><span class="line">            .toList()</span><br><span class="line">            .map &#123; Result.success() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，<code>RxWorker.createWork()</code> 在主线程上调用，但默认情况下会在后台线程上订阅返回值。您可以替换 <a href="https://developer.android.com/reference/androidx/work/RxWorker#getBackgroundScheduler()" target="_blank" rel="noopener"><code>RxWorker.getBackgroundScheduler()</code></a> 来更改订阅线程。</p>
<p>停止 <code>RxWorker</code> 会妥善处理 <code>Observer</code>，因此您无需以任何特殊方式处理<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work" target="_blank" rel="noopener">停工</a>。</p>
<h5 id="用ListenableWorker处理线程"><a href="#用ListenableWorker处理线程" class="headerlink" title="用ListenableWorker处理线程"></a>用ListenableWorker处理线程</h5><p>在某些情况下，您可能需要提供自定义线程处理策略。例如，您可能需要处理基于回调的异步操作。在这种情况下，不能只依靠 <code>Worker</code> 来完成操作，因为它无法以阻塞方式完成这项任务。WorkManager 通过 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker" target="_blank" rel="noopener"><code>ListenableWorker</code></a> 支持该用例。<code>ListenableWorker</code> 是最低层级的工作器 API；<a href="https://developer.android.com/reference/androidx/work/Worker" target="_blank" rel="noopener"><code>Worker</code></a>、<a href="https://developer.android.com/reference/androidx/work/CoroutineWorker" target="_blank" rel="noopener"><code>CoroutineWorker</code></a> 和 <a href="https://developer.android.com/reference/androidx/work/RxWorker" target="_blank" rel="noopener"><code>RxWorker</code></a> 都是从这个类衍生而来的。<code>ListenableWorker</code> 只会发出信号以表明应该开始和停止工作，而线程处理则完全交由您负责完成。开始工作信号在主线程上调用，因此请务必手动转到您选择的后台线程。</p>
<p>抽象方法 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker#startWork()" target="_blank" rel="noopener"><code>ListenableWorker.startWork()</code></a> 会返回一个将使用操作的 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result" target="_blank" rel="noopener"><code>Result</code></a> 设置的 <code>ListenableFuture</code>。<code>ListenableFuture</code> 是一个轻量级接口：它是一个 <code>Future</code>，用于提供附加监听器和传播异常的功能。在 <code>startWork</code> 方法中，应该返回 <code>ListenableFuture</code>，完成操作后，您需要使用操作的 <code>Result</code> 设置这个返回结果。您可以通过以下两种方式创建 <code>ListenableFuture</code>：</p>
<ol>
<li>如果您使用的是 Guava，请使用 <code>ListeningExecutorService</code>。</li>
<li>否则，请将 <a href="https://developer.android.com/jetpack/androidx/releases/concurrent#declaring_dependencies" target="_blank" rel="noopener"><code>councurrent-futures</code></a> 包含到您的 gradle 文件并使用 <a href="https://developer.android.com/reference/androidx/concurrent/futures/CallbackToFutureAdapter" target="_blank" rel="noopener"><code>CallbackToFutureAdapter</code></a>。</li>
</ol>
<p>如果您希望基于异步回调执行某些工作，可以执行如下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackWorker</span> <span class="keyword">extends</span> <span class="title">ListenableWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallbackWorker</span><span class="params">(Context context, WorkerParameters params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListenableFuture&lt;Result&gt; <span class="title">startWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CallbackToFutureAdapter.getFuture(completer -&gt; &#123;</span><br><span class="line">            Callback callback = <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                <span class="keyword">int</span> successes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                    completer.setException(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> </span>&#123;</span><br><span class="line">                    ++successes;</span><br><span class="line">                    <span class="keyword">if</span> (successes == <span class="number">100</span>) &#123;</span><br><span class="line">                        completer.set(Result.success());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">                downloadAsynchronously(<span class="string">"https://www.google.com"</span>, callback);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> callback;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您的工作<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work" target="_blank" rel="noopener">停止</a>会发生什么？如果预计工作会停止，则始终会取消 <code>ListenableWorker</code> 的 <code>ListenableFuture</code>。通过使用 <code>CallbackToFutureAdapter</code>，您只需添加一个取消监听器即可，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackWorker</span> <span class="title">extends</span> <span class="title">ListenableWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CallbackWorker(Context context, WorkerParameters params) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ListenableFuture&lt;Result&gt; startWork() &#123;</span><br><span class="line">        <span class="keyword">return</span> CallbackToFutureAdapter.getFuture(completer -&gt; &#123;</span><br><span class="line">            Callback callback = new Callback() &#123;</span><br><span class="line">                int successes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> void onFailure(Call call, IOException e) &#123;</span><br><span class="line">                    completer.setException(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> void onResponse(Call call, Response response) &#123;</span><br><span class="line">                    ++successes;</span><br><span class="line">                    <span class="keyword">if</span> (successes == <span class="number">100</span>) &#123;</span><br><span class="line">                        completer.<span class="keyword">set</span>(Result.success());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            completer.addCancellationListener(cancelDownloadsRunnable, executor);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">                downloadAsynchronously(<span class="string">"https://www.google.com"</span>, callback);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> callback;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="支持长时间运行的工作器"><a href="#支持长时间运行的工作器" class="headerlink" title="支持长时间运行的工作器"></a>支持长时间运行的工作器</h4><p>​    WorkManager 2.3.0-alpha02增加了对长期运行的工作者的一流支持。在这种情况下，WorkManager可以向操作系统提供一个信号，即如果可能的话，在执行该工作的同时，应该保持进程的活力。这些Worker的运行时间可以超过10分钟。这个新功能的用例包括批量上传或下载（不能分组），在本地进行ML模型的压缩，或对应用的用户来说很重要的任务。</p>
<p>​    在引擎盖下，WorkManager代表你管理并运行一个前台服务来执行WorkRequest，同时也会显示一个可配置的通知。</p>
<p>​    ListenableWorker现在支持setForegroundAsync()API，而CoroutineWorker则支持暂停setForeground()API。这些API允许开发人员指定这个WorkRequest是重要的（从用户的角度来看）或长期运行的WorkRequest。</p>
<p>​    从 2.3.0-alpha03 版本开始，WorkManager还允许用户创建一个PendingIntent，无需使用createCancelPendingIntent()API注册一个新的Android组件，就可以用来取消Worker。这种方法在与setForegroundAsync()或setForeground()API一起使用时特别有用，可以用来添加一个取消Worker的通知动作。</p>
<h5 id="创建和管理长时间运行的任务"><a href="#创建和管理长时间运行的任务" class="headerlink" title="创建和管理长时间运行的任务"></a>创建和管理长时间运行的任务</h5><h6 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h6><p>使用ListenableWorker或Worker的开发者可以调用setForegroundAsync()API，返回一个ListenableFuture<Void>。你也可以调用setForegroundAsync()，来更新一个正在运行的Notification。</p>
<p>下面是一个简单的例子，它是一个长期运行的worker下载文件。这个Worker会跟踪进度，更新一个正在进行的Notification，显示下载进度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_INPUT_URL = <span class="string">"KEY_INPUT_URL"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_OUTPUT_FILE_NAME = <span class="string">"KEY_OUTPUT_FILE_NAME"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NotificationManager notificationManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadWorker</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull WorkerParameters parameters)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(context, parameters);</span><br><span class="line">            notificationManager = (NotificationManager)</span><br><span class="line">                context.getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Data inputData = getInputData();</span><br><span class="line">        String inputUrl = inputData.getString(KEY_INPUT_URL);</span><br><span class="line">        String outputFile = inputData.getString(KEY_OUTPUT_FILE_NAME);</span><br><span class="line">        <span class="comment">// Mark the Worker as important</span></span><br><span class="line">        String progress = <span class="string">"Starting Download"</span>;</span><br><span class="line">        setForegroundAsync(createForegroundInfo(progress));</span><br><span class="line">        download(inputUrl, outputFile);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String inputUrl, String outputFile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Downloads a file and updates bytes read</span></span><br><span class="line">        <span class="comment">// Calls setForegroundInfoAsync() periodically when it needs to update</span></span><br><span class="line">       <span class="comment">// the ongoing Notification</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ForegroundInfo <span class="title">createForegroundInfo</span><span class="params">(@NonNull String progress)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Build a notification using bytesRead and contentLength</span></span><br><span class="line"></span><br><span class="line">        Context context = getApplicationContext();</span><br><span class="line">        String id = context.getString(R.string.notification_channel_id);</span><br><span class="line">        String title = context.getString(R.string.notification_title);</span><br><span class="line">        String cancel = context.getString(R.string.cancel_download);</span><br><span class="line">        <span class="comment">// This PendingIntent can be used to cancel the worker</span></span><br><span class="line">        PendingIntent intent = WorkManager.getInstance(context)</span><br><span class="line">                .createCancelPendingIntent(getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            createChannel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Notification notification = <span class="keyword">new</span> NotificationCompat.Builder(context, id)</span><br><span class="line">                .setContentTitle(title)</span><br><span class="line">                .setTicker(title)</span><br><span class="line">                .setSmallIcon(R.drawable.ic_work_notification)</span><br><span class="line">                .setOngoing(<span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">// Add the cancel action to the notification which can</span></span><br><span class="line">                <span class="comment">// be used to cancel the worker</span></span><br><span class="line">                .addAction(android.R.drawable.ic_delete, cancel, intent)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForegroundInfo(notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi</span>(Build.VERSION_CODES.O)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a Notification channel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h6><p>Kotlin开发者应该使用CoroutineWorker，而不是使用setForegroundAsync()，你可以使用该方法的悬浮版本的setForeground()来代替。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadWorker</span></span>(context: Context, parameters: WorkerParameters) :</span><br><span class="line">    CoroutineWorker(context, parameters) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> notificationManager =</span><br><span class="line">        context.getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span></span><br><span class="line">                NotificationManager</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="keyword">val</span> inputUrl = inputData.getString(KEY_INPUT_URL)</span><br><span class="line">                       ?: <span class="keyword">return</span> Result.failure()</span><br><span class="line">        <span class="keyword">val</span> outputFile = inputData.getString(KEY_OUTPUT_FILE_NAME)</span><br><span class="line">                       ?: <span class="keyword">return</span> Result.failure()</span><br><span class="line">        <span class="comment">// Mark the Worker as important</span></span><br><span class="line">        <span class="keyword">val</span> progress = <span class="string">"Starting Download"</span></span><br><span class="line">        setForeground(createForegroundInfo(progress))</span><br><span class="line">        download(inputUrl, outputFile)</span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">download</span><span class="params">(inputUrl: <span class="type">String</span>, outputFile: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Downloads a file and updates bytes read</span></span><br><span class="line">        <span class="comment">// Calls setForegroundInfo() periodically when it needs to update</span></span><br><span class="line">        <span class="comment">// the ongoing Notification</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Creates an instance of ForegroundInfo which can be used to update the</span></span><br><span class="line">    <span class="comment">// ongoing notification.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createForegroundInfo</span><span class="params">(progress: <span class="type">String</span>)</span></span>: ForegroundInfo &#123;</span><br><span class="line">        <span class="keyword">val</span> id = applicationContext.getString(R.string.notification_channel_id)</span><br><span class="line">        <span class="keyword">val</span> title = applicationContext.getString(R.string.notification_title)</span><br><span class="line">        <span class="keyword">val</span> cancel = applicationContext.getString(R.string.cancel_download)</span><br><span class="line">        <span class="comment">// This PendingIntent can be used to cancel the worker</span></span><br><span class="line">        <span class="keyword">val</span> intent = WorkManager.getInstance(applicationContext)</span><br><span class="line">                .createCancelPendingIntent(getId())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a Notification channel if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            createChannel()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> notification = NotificationCompat.Builder(applicationContext, id)</span><br><span class="line">            .setContentTitle(title)</span><br><span class="line">            .setTicker(title)</span><br><span class="line">            .setContentText(progress)</span><br><span class="line">            .setSmallIcon(R.drawable.ic_work_notification)</span><br><span class="line">            .setOngoing(<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// Add the cancel action to the notification which can</span></span><br><span class="line">            <span class="comment">// be used to cancel the worker</span></span><br><span class="line">            .addAction(android.R.drawable.ic_delete, cancel, intent)</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ForegroundInfo(notification)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.O)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Create a Notification channel</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> KEY_INPUT_URL = <span class="string">"KEY_INPUT_URL"</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> KEY_OUTPUT_FILE_NAME = <span class="string">"KEY_OUTPUT_FILE_NAME"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="从Firebase-JobDispatcher迁移"><a href="#从Firebase-JobDispatcher迁移" class="headerlink" title="从Firebase JobDispatcher迁移"></a>从Firebase JobDispatcher迁移</h3><h3 id="从GCMNetworkManager迁移"><a href="#从GCMNetworkManager迁移" class="headerlink" title="从GCMNetworkManager迁移"></a>从GCMNetworkManager迁移</h3></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">liuclub</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://github.com/liuclub/liuclub.github.io.git/2020/05/28/10-WorkManager/">https://github.com/liuclub/liuclub.github.io.git/2020/05/28/10-WorkManager/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/28/11-%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81/"><i class="fa fa-chevron-left">  </i><span>11-保存状态</span></a></div><div class="next-post pull-right"><a href="/2020/05/28/9-ViewModel/"><span>9-ViewModel</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By liuclub</div><!--.framework-info--><!--  span= _p('footer.driven') + ' - '--><!--  a(href='http://hexo.io')--><!--    span Hexo--><!--  span.footer-separator |--><!--  span= _p('footer.theme') + ' - '--><!--  a(href='https://github.com/Molunerfinn/hexo-theme-melody')--><!--    span Melody--><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>